{"version":3,"file":"icon-manager.2c4c9b5c.js","sources":["../../src/layers/moving-icons/icon-layer.glsl.vert?raw","../../src/layers/moving-icons/icon-layer.glsl.frag?raw","../../src/layers/moving-icons/icon-manager.ts"],"sourcesContent":["export default \"// BC 2021-04-30: this file forked from https://github.com/visgl/deck.gl\\r\\n//\\r\\n// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\\r\\n//\\r\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\r\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\r\\n// in the Software without restriction, including without limitation the rights\\r\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\r\\n// copies of the Software, and to permit persons to whom the Software is\\r\\n// furnished to do so, subject to the following conditions:\\r\\n//\\r\\n// The above copyright notice and this permission notice shall be included in\\r\\n// all copies or substantial portions of the Software.\\r\\n//\\r\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\r\\n// THE SOFTWARE.\\r\\n\\r\\n#define SHADER_NAME icon-layer-vertex-shader\\r\\n\\r\\nattribute vec2 positions;\\r\\n\\r\\nattribute float instanceSizes;\\r\\nattribute vec4 instanceColors;\\r\\nattribute vec3 instancePickingColors;\\r\\nattribute vec4 instanceIconFrames;\\r\\nattribute float instanceColorModes;\\r\\nattribute vec2 instanceOffsets;\\r\\nattribute vec2 instancePixelOffset;\\r\\n\\r\\nuniform float sizeScale;\\r\\nuniform vec2 iconsTextureDim;\\r\\nuniform float sizeMinPixels;\\r\\nuniform float sizeMaxPixels;\\r\\nuniform bool billboard;\\r\\n\\r\\nuniform float currentTime;\\r\\n\\r\\nuniform vec2 iconStillOffsets;\\r\\nuniform vec4 iconStillFrames;\\r\\n\\r\\nattribute float instanceTimestamps;\\r\\nattribute float instanceTimestampsNext;\\r\\nattribute vec2 instanceStartPositions;\\r\\nattribute vec2 instanceEndPositions;\\r\\n\\r\\nvarying float vColorMode;\\r\\nvarying vec4 vColor;\\r\\nvarying vec2 vTextureCoords;\\r\\nvarying vec2 uv;\\r\\nvarying float vPercentComplete;\\r\\n\\r\\n// ------------------------------------------------------------------\\r\\n\\r\\nvec2 rotate_by_angle(vec2 vertex, float angle_radian) {\\r\\n  float cos_angle = cos(angle_radian);\\r\\n  float sin_angle = sin(angle_radian);\\r\\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\\r\\n  return rotationMatrix * vertex;\\r\\n}\\r\\n\\r\\nvec3 interpolate(in vec3 point1, in vec3 point2, in float timestepFraction) {\\r\\n    if (timestepFraction <= 0.0) {\\r\\n        return point1;\\r\\n    } else if (timestepFraction >= 1.0 ) {\\r\\n        return point2;\\r\\n    } else {\\r\\n        vec3 direction = point2 - point1;\\r\\n        return point1 + (direction * timestepFraction);\\r\\n    }\\r\\n}\\r\\n\\r\\nvoid main(void) {\\r\\n\\r\\n  // Calculate progress:\\r\\n  // Skip everything else if this vertex is outside the time window\\r\\n  if (currentTime < instanceTimestamps) {\\r\\n    vPercentComplete = -1.0;\\r\\n    return;\\r\\n  } else if (currentTime > instanceTimestampsNext) {\\r\\n    vPercentComplete = -1.0;\\r\\n    return;\\r\\n  } else {\\r\\n    vPercentComplete = (currentTime - instanceTimestamps) /\\r\\n                       (instanceTimestampsNext - instanceTimestamps);\\r\\n  }\\r\\n\\r\\n  geometry.pickingColor = instancePickingColors;\\r\\n\\r\\n  vec3 startPosition = vec3(instanceStartPositions, 5.0);\\r\\n  vec3 endPosition = vec3(instanceEndPositions, 5.0);\\r\\n\\r\\n  // are we stationary/still\\r\\n  bool still = (instanceStartPositions == instanceEndPositions);\\r\\n\\r\\n  // geometry.uv = positions;\\r\\n  // uv = positions;\\r\\n\\r\\n  // this could be the problem right here;\\r\\n  vec2 iconSize = still ? iconStillFrames.zw : instanceIconFrames.zw;\\r\\n  // convert size in meters to pixels, then scaled and clamp\\r\\n  // project meters to pixels and clamp to limits\\r\\n  float sizePixels = clamp(\\r\\n    project_size_to_pixel(instanceSizes * sizeScale),\\r\\n    sizeMinPixels, sizeMaxPixels\\r\\n  );\\r\\n\\r\\n  // scale icon height to match instanceSize\\r\\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\\r\\n\\r\\n  // // figure out angle based on motion direction\\r\\n  float angle = 0.0;\\r\\n  if (!still) {\\r\\n    vec3 direction = normalize(endPosition - startPosition);\\r\\n    angle = atan( direction.y / direction.x);\\r\\n    if (direction.x < 0.0) angle = angle - PI;\\r\\n  }\\r\\n\\r\\n  // scale and rotate vertex in \\\"pixel\\\" value and convert back to fraction in clipspace\\r\\n  vec2 pixelOffset = positions / 2.0 * iconSize + (still ? iconStillOffsets : instanceOffsets);\\r\\n  pixelOffset = rotate_by_angle(pixelOffset, angle) * instanceScale;\\r\\n  pixelOffset += instancePixelOffset;\\r\\n  pixelOffset.y *= -1.0;\\r\\n\\r\\n  vec3 newPosition = interpolate(startPosition, endPosition, vPercentComplete);\\r\\n\\r\\n  if (billboard)  {\\r\\n    gl_Position = project_position_to_clipspace(newPosition, vec3(0.0), vec3(0.0), geometry.position);\\r\\n    vec3 offset = vec3(pixelOffset, 0.0);\\r\\n    DECKGL_FILTER_SIZE(offset, geometry);\\r\\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\\r\\n\\r\\n  } else {\\r\\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\\r\\n    DECKGL_FILTER_SIZE(offset_common, geometry);\\r\\n    gl_Position = project_position_to_clipspace(newPosition, vec3(0.0), offset_common, geometry.position);\\r\\n  }\\r\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\r\\n\\r\\n  vec2 upperleft = (still ? iconStillFrames.xy : instanceIconFrames.xy);\\r\\n\\r\\n  vTextureCoords = mix(\\r\\n    upperleft,\\r\\n    upperleft + iconSize,\\r\\n    (positions.xy + 1.0) / 2.0\\r\\n  ) / iconsTextureDim;\\r\\n\\r\\n  vColor = instanceColors;\\r\\n  DECKGL_FILTER_COLOR(vColor, geometry);\\r\\n\\r\\n  vColorMode = instanceColorModes;\\r\\n}\\r\\n\"","export default \"// BC 2021-04-30: this file forked from https://github.com/visgl/deck.gl\\r\\n//\\r\\n// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\\r\\n//\\r\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\r\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\r\\n// in the Software without restriction, including without limitation the rights\\r\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\r\\n// copies of the Software, and to permit persons to whom the Software is\\r\\n// furnished to do so, subject to the following conditions:\\r\\n//\\r\\n// The above copyright notice and this permission notice shall be included in\\r\\n// all copies or substantial portions of the Software.\\r\\n//\\r\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\r\\n// THE SOFTWARE.\\r\\n\\r\\n#define SHADER_NAME icon-layer-fragment-shader\\r\\n\\r\\nprecision highp float;\\r\\n\\r\\nuniform float opacity;\\r\\nuniform sampler2D iconsTexture;\\r\\nuniform float alphaCutoff;\\r\\n\\r\\nvarying float vColorMode;\\r\\nvarying vec4 vColor;\\r\\nvarying vec2 vTextureCoords;\\r\\nvarying vec2 uv;\\r\\n\\r\\nuniform float currentTime;\\r\\nvarying float vPercentComplete;\\r\\n\\r\\nvoid main(void) {\\r\\n\\r\\n  if (vPercentComplete == -1.0) discard;\\r\\n\\r\\n  geometry.uv = uv;\\r\\n\\r\\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\\r\\n\\r\\n  // if colorMode == 0, use pixel color from the texture\\r\\n  // if colorMode == 1 or rendering picking buffer, use texture as transparency mask\\r\\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\\r\\n  // Take the global opacity and the alpha from vColor into account for the alpha component\\r\\n  float a = texColor.a * opacity * vColor.a;\\r\\n\\r\\n  if (a < alphaCutoff) {\\r\\n    discard;\\r\\n  }\\r\\n\\r\\n  gl_FragColor = vec4(color, a);\\r\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\r\\n}\\r\\n\"","// BC 2021-04-30: this file forked from https://github.com/visgl/deck.gl\r\n//\r\n/* global document */\r\nimport GL from '@luma.gl/constants'\r\nimport { Texture2D, copyToTexture, cloneTextureFrom } from '@luma.gl/core'\r\nimport { ImageLoader } from '@loaders.gl/images'\r\nimport { load } from '@loaders.gl/core'\r\nimport { createIterable } from '@deck.gl/core'\r\n\r\nconst DEFAULT_CANVAS_WIDTH = 1024\r\nconst DEFAULT_BUFFER = 4\r\n\r\nconst noop = () => {}\r\n\r\nconst DEFAULT_TEXTURE_PARAMETERS = {\r\n  [GL.TEXTURE_MIN_FILTER]: GL.LINEAR_MIPMAP_LINEAR,\r\n  // GL.LINEAR is the default value but explicitly set it here\r\n  [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\r\n  // for texture boundary artifact\r\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\r\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE,\r\n}\r\n\r\nfunction nextPowOfTwo(number: number) {\r\n  return Math.pow(2, Math.ceil(Math.log2(number)))\r\n}\r\n\r\n// update comment to create a new texture and copy original data.\r\nfunction resizeImage(ctx: any, imageData: any, width: any, height: any) {\r\n  if (width === imageData.width && height === imageData.height) {\r\n    return imageData\r\n  }\r\n\r\n  ctx.canvas.height = height\r\n  ctx.canvas.width = width\r\n\r\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)\r\n\r\n  // image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight\r\n  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height)\r\n\r\n  return ctx.canvas\r\n}\r\n\r\nfunction getIconId(icon: any) {\r\n  return icon && (icon.id || icon.url)\r\n}\r\n\r\n// resize texture without losing original data\r\nfunction resizeTexture(gl: any, texture: any, width: any, height: any) {\r\n  const oldWidth = texture.width\r\n  const oldHeight = texture.height\r\n\r\n  const newTexture = cloneTextureFrom(texture, { width, height })\r\n  copyToTexture(texture, newTexture, {\r\n    targetY: 0,\r\n    width: oldWidth,\r\n    height: oldHeight,\r\n  })\r\n\r\n  texture.delete()\r\n  return newTexture\r\n}\r\n\r\n// traverse icons in a row of icon atlas\r\n// extend each icon with left-top coordinates\r\nfunction buildRowMapping(mapping: any, columns: any, yOffset: any) {\r\n  for (let i = 0; i < columns.length; i++) {\r\n    const { icon, xOffset } = columns[i]\r\n    const id = getIconId(icon)\r\n    mapping[id] = {\r\n      ...icon,\r\n      x: xOffset,\r\n      y: yOffset,\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Generate coordinate mapping to retrieve icon left-top position from an icon atlas\r\n * @param icons {Array<Object>} list of icons, each icon requires url, width, height\r\n * @param buffer {Number} add buffer to the right and bottom side of the image\r\n * @param xOffset {Number} right position of last icon in old mapping\r\n * @param yOffset {Number} top position in last icon in old mapping\r\n * @param rowHeight {Number} rowHeight of the last icon's row\r\n * @param canvasWidth {Number} max width of canvas\r\n * @param mapping {object} old mapping\r\n * @returns {{mapping: {'/icon/1': {url, width, height, ...}},, canvasHeight: {Number}}}\r\n */\r\nexport function buildMapping({\r\n  icons,\r\n  buffer,\r\n  mapping = {},\r\n  xOffset = 0,\r\n  yOffset = 0,\r\n  rowHeight = 0,\r\n  canvasWidth,\r\n}: any) {\r\n  let columns = []\r\n  // Strategy to layout all the icons into a texture:\r\n  // traverse the icons sequentially, layout the icons from left to right, top to bottom\r\n  // when the sum of the icons width is equal or larger than canvasWidth,\r\n  // move to next row starting from total height so far plus max height of the icons in previous row\r\n  // row width is equal to canvasWidth\r\n  // row height is decided by the max height of the icons in that row\r\n  // mapping coordinates of each icon is its left-top position in the texture\r\n  for (let i = 0; i < icons.length; i++) {\r\n    const icon = icons[i]\r\n    const id = getIconId(icon)\r\n\r\n    if (!mapping[id]) {\r\n      const { height, width } = icon\r\n\r\n      // fill one row\r\n      if (xOffset + width + buffer > canvasWidth) {\r\n        buildRowMapping(mapping, columns, yOffset)\r\n\r\n        xOffset = 0\r\n        yOffset = rowHeight + yOffset + buffer\r\n        rowHeight = 0\r\n        columns = []\r\n      }\r\n\r\n      columns.push({\r\n        icon,\r\n        xOffset,\r\n      })\r\n\r\n      xOffset = xOffset + width + buffer\r\n      rowHeight = Math.max(rowHeight, height)\r\n    }\r\n  }\r\n\r\n  if (columns.length > 0) {\r\n    buildRowMapping(mapping, columns, yOffset)\r\n  }\r\n\r\n  return {\r\n    mapping,\r\n    rowHeight,\r\n    xOffset,\r\n    yOffset,\r\n    canvasWidth,\r\n    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer),\r\n  }\r\n}\r\n\r\n// extract icons from data\r\n// return icons should be unique, and not cached or cached but url changed\r\nexport function getDiffIcons(data: any, getIcon: any, cachedIcons: any) {\r\n  if (!data || !getIcon) {\r\n    return null\r\n  }\r\n\r\n  cachedIcons = cachedIcons || {}\r\n  const icons = {} as any\r\n  const { iterable, objectInfo } = createIterable(data)\r\n  for (const object of iterable) {\r\n    objectInfo.index++\r\n    const icon = getIcon(object, objectInfo)\r\n    const id = getIconId(icon)\r\n\r\n    if (!icon) {\r\n      throw new Error('Icon is missing.')\r\n    }\r\n\r\n    if (!icon.url) {\r\n      throw new Error('Icon url is missing.')\r\n    }\r\n\r\n    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {\r\n      icons[id] = { ...icon, source: object, sourceIndex: objectInfo.index }\r\n    }\r\n  }\r\n  return icons\r\n}\r\n\r\nexport default class IconManager {\r\n  gl: any\r\n  onUpdate: () => void\r\n  onError: (e: any) => any\r\n  _loadOptions: any\r\n  _getIcon: any\r\n  _texture: any\r\n  _externalTexture: any\r\n  _mapping: any\r\n  _pendingCount: number\r\n  _autoPacking: boolean\r\n  _xOffset: number\r\n  _yOffset: number\r\n  _rowHeight: number\r\n  _buffer: number\r\n  _canvasWidth: number\r\n  _canvasHeight: number\r\n  _canvas: any\r\n\r\n  constructor(\r\n    gl: any,\r\n    {\r\n      onUpdate = noop, // notify IconLayer when icon texture update\r\n      onError = noop,\r\n    }\r\n  ) {\r\n    this.gl = gl\r\n    this.onUpdate = onUpdate\r\n    this.onError = onError\r\n\r\n    // load options used for loading images\r\n    this._loadOptions = null\r\n    this._getIcon = null\r\n\r\n    this._texture = null\r\n    this._externalTexture = null\r\n    this._mapping = {}\r\n    // count of pending requests to fetch icons\r\n    this._pendingCount = 0\r\n\r\n    this._autoPacking = false\r\n\r\n    // internal props used when autoPacking applied\r\n    // right position of last icon\r\n    this._xOffset = 0\r\n    // top position of last icon\r\n    this._yOffset = 0\r\n    this._rowHeight = 0\r\n    this._buffer = DEFAULT_BUFFER\r\n    this._canvasWidth = DEFAULT_CANVAS_WIDTH\r\n    this._canvasHeight = 0\r\n    this._canvas = null\r\n  }\r\n\r\n  finalize() {\r\n    this._texture?.delete()\r\n  }\r\n\r\n  getTexture() {\r\n    return this._texture || this._externalTexture\r\n  }\r\n\r\n  getIconMapping(icon: any) {\r\n    const id = this._autoPacking ? getIconId(icon) : icon\r\n    return this._mapping[id] || {}\r\n  }\r\n\r\n  setProps({ loadOptions, autoPacking, iconAtlas, iconMapping, data, getIcon }: any) {\r\n    if (loadOptions) {\r\n      this._loadOptions = loadOptions\r\n    }\r\n\r\n    if (autoPacking !== undefined) {\r\n      this._autoPacking = autoPacking\r\n    }\r\n\r\n    if (getIcon) {\r\n      this._getIcon = getIcon\r\n    }\r\n\r\n    if (iconMapping) {\r\n      this._mapping = iconMapping\r\n    }\r\n\r\n    if (iconAtlas) {\r\n      this._updateIconAtlas(iconAtlas)\r\n    }\r\n\r\n    if (this._autoPacking && (data || getIcon) && typeof document !== 'undefined') {\r\n      this._canvas = this._canvas || document.createElement('canvas')\r\n\r\n      this._updateAutoPacking(data)\r\n    }\r\n  }\r\n\r\n  get isLoaded() {\r\n    return this._pendingCount === 0\r\n  }\r\n\r\n  _updateIconAtlas(iconAtlas: any) {\r\n    this._texture?.delete()\r\n    this._texture = null\r\n    this._externalTexture = iconAtlas\r\n    this.onUpdate()\r\n  }\r\n\r\n  _updateAutoPacking(data: any) {\r\n    const icons = Object.values(getDiffIcons(data, this._getIcon, this._mapping) || {})\r\n\r\n    if (icons.length > 0) {\r\n      // generate icon mapping\r\n      const { mapping, xOffset, yOffset, rowHeight, canvasHeight } = buildMapping({\r\n        icons,\r\n        buffer: this._buffer,\r\n        canvasWidth: this._canvasWidth,\r\n        mapping: this._mapping,\r\n        rowHeight: this._rowHeight,\r\n        xOffset: this._xOffset,\r\n        yOffset: this._yOffset,\r\n      })\r\n\r\n      this._rowHeight = rowHeight\r\n      this._mapping = mapping\r\n      this._xOffset = xOffset\r\n      this._yOffset = yOffset\r\n      this._canvasHeight = canvasHeight\r\n\r\n      // create new texture\r\n      if (!this._texture) {\r\n        this._texture = new Texture2D(this.gl, {\r\n          width: this._canvasWidth,\r\n          height: this._canvasHeight,\r\n          parameters: DEFAULT_TEXTURE_PARAMETERS,\r\n        })\r\n      }\r\n\r\n      if (this._texture.height !== this._canvasHeight) {\r\n        this._texture = resizeTexture(this.gl, this._texture, this._canvasWidth, this._canvasHeight)\r\n      }\r\n\r\n      this.onUpdate()\r\n\r\n      // load images\r\n      this._loadIcons(icons)\r\n    }\r\n  }\r\n\r\n  _loadIcons(icons: any) {\r\n    const ctx = this._canvas.getContext('2d')\r\n\r\n    for (const icon of icons) {\r\n      this._pendingCount++\r\n      load(icon.url, ImageLoader, this._loadOptions)\r\n        .then(imageData => {\r\n          const id = getIconId(icon)\r\n          const { x, y, width, height } = this._mapping[id]\r\n\r\n          const data = resizeImage(ctx, imageData, width, height)\r\n\r\n          this._texture.setSubImageData({\r\n            data,\r\n            x,\r\n            y,\r\n            width,\r\n            height,\r\n          })\r\n\r\n          // Call to regenerate mipmaps after modifying texture(s)\r\n          this._texture.generateMipmap()\r\n\r\n          this.onUpdate()\r\n        })\r\n        .catch(error => {\r\n          this.onError({\r\n            url: icon.url,\r\n            source: icon.source,\r\n            sourceIndex: icon.sourceIndex,\r\n            loadOptions: this._loadOptions,\r\n            error,\r\n          })\r\n        })\r\n        .finally(() => {\r\n          this._pendingCount--\r\n        })\r\n    }\r\n  }\r\n}\r\n"],"names":["vertShader","fragShader","noop","DEFAULT_TEXTURE_PARAMETERS","GL","TEXTURE_MIN_FILTER","LINEAR_MIPMAP_LINEAR","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","resizeImage","ctx","imageData","width","height","canvas","clearRect","drawImage","getIconId","icon","id","url","buildRowMapping","mapping","columns","yOffset","i","length","xOffset","__spreadProps","x","y","IconManager","constructor","gl","onUpdate","onError","__publicField","this","_loadOptions","_getIcon","_texture","_externalTexture","_mapping","_pendingCount","_autoPacking","_xOffset","_yOffset","_rowHeight","_buffer","_canvasWidth","_canvasHeight","_canvas","finalize","_a","delete","getTexture","getIconMapping","setProps","loadOptions","autoPacking","iconAtlas","iconMapping","data","getIcon","_updateIconAtlas","document","createElement","_updateAutoPacking","isLoaded","icons","Object","values","cachedIcons","iterable","objectInfo","createIterable","object","index","Error","__spreadValues","source","sourceIndex","getDiffIcons","rowHeight","canvasHeight","buffer","canvasWidth","push","Math","max","number","pow","ceil","log2","buildMapping","Texture2D","parameters","texture","oldWidth","oldHeight","newTexture","cloneTextureFrom","copyToTexture","targetY","resizeTexture","_loadIcons","getContext","load","ImageLoader","then","setSubImageData","generateMipmap","catch","error","finally"],"mappings":"gkBAAA,IAAeA,EAAA,kuLCAAC,EAAA,2vECSf,MAGMC,EAAO,OAEPC,EAA6B,CAChC,CAAAC,EAAGC,oBAAqBD,EAAGE,qBAE3B,CAAAF,EAAGG,oBAAqBH,EAAGI,OAE3B,CAAAJ,EAAGK,gBAAiBL,EAAGM,cACvB,CAAAN,EAAGO,gBAAiBP,EAAGM,eAQ1B,SAAqBE,EAAAC,EAAUC,EAAgBC,EAAYC,GACzD,OAAID,IAAUD,EAAUC,OAASC,IAAWF,EAAUE,OAC7CF,GAGTD,EAAII,OAAOD,OAASA,EACpBH,EAAII,OAAOF,MAAQA,EAEnBF,EAAIK,UAAU,EAAG,EAAGL,EAAII,OAAOF,MAAOF,EAAII,OAAOD,QAG7CH,EAAAM,UAAUL,EAAW,EAAG,EAAGA,EAAUC,MAAOD,EAAUE,OAAQ,EAAG,EAAGD,EAAOC,GAExEH,EAAII,QAGb,SAAAG,EAAmBC,GACV,OAAAA,IAAcA,EAAAC,IAAMD,EAAKE,KAqBlC,SAAyBC,EAAAC,EAAcC,EAAcC,GACnD,IAAA,IAASC,EAAI,EAAGA,EAAIF,EAAQG,OAAQD,IAAK,CACjC,MAAAP,KAAEA,EAAMS,QAAAA,GAAYJ,EAAQE,GAE1BH,EADGL,EAAUC,IACPU,OACTV,GADS,CAEZW,EAAGF,EACHG,EAAGN,KAwGwB,MAAAO,EAmB/BC,YACEC,GACAC,SACEA,EAAWnC,EAAAoC,QACXA,EAAUpC,IAtBdqC,EAAAC,KAAA,MACAD,EAAAC,KAAA,YACAD,EAAAC,KAAA,WACAD,EAAAC,KAAA,gBACAD,EAAAC,KAAA,YACAD,EAAAC,KAAA,YACAD,EAAAC,KAAA,oBACAD,EAAAC,KAAA,YACAD,EAAAC,KAAA,iBACAD,EAAAC,KAAA,gBACAD,EAAAC,KAAA,YACAD,EAAAC,KAAA,YACAD,EAAAC,KAAA,cACAD,EAAAC,KAAA,WACAD,EAAAC,KAAA,gBACAD,EAAAC,KAAA,iBACAD,EAAAC,KAAA,WASEA,KAAKJ,GAAKA,EACVI,KAAKH,SAAWA,EAChBG,KAAKF,QAAUA,EAGfE,KAAKC,aAAe,KACpBD,KAAKE,SAAW,KAEhBF,KAAKG,SAAW,KAChBH,KAAKI,iBAAmB,KACxBJ,KAAKK,SAAW,GAEhBL,KAAKM,cAAgB,EAErBN,KAAKO,cAAe,EAIpBP,KAAKQ,SAAW,EAEhBR,KAAKS,SAAW,EAChBT,KAAKU,WAAa,EAClBV,KAAKW,QAvNc,EAwNnBX,KAAKY,aAzNoB,KA0NzBZ,KAAKa,cAAgB,EACrBb,KAAKc,QAAU,KAGjBC,iBACE,OAAAC,EAAAhB,KAAKG,WAAUa,EAAAC,SAGjBC,aACS,OAAAlB,KAAKG,UAAYH,KAAKI,iBAG/Be,eAAetC,GACb,MAAMC,EAAKkB,KAAKO,aAAe3B,EAAUC,GAAQA,EAC1C,OAAAmB,KAAKK,SAASvB,IAAO,GAG9BsC,UAASC,YAAEA,EAAAC,YAAaA,YAAaC,EAAWC,YAAAA,EAAAC,KAAaA,UAAMC,IAC7DL,IACFrB,KAAKC,aAAeoB,QAGF,IAAhBC,IACFtB,KAAKO,aAAee,GAGlBI,IACF1B,KAAKE,SAAWwB,GAGdF,IACFxB,KAAKK,SAAWmB,GAGdD,GACFvB,KAAK2B,iBAAiBJ,GAGpBvB,KAAKO,eAAiBkB,GAAQC,IAAgC,oBAAbE,WACnD5B,KAAKc,QAAUd,KAAKc,SAAWc,SAASC,cAAc,UAEtD7B,KAAK8B,mBAAmBL,IAAAM,eAK1B,OAA8B,IAAvB/B,KAAKM,cAGdqB,iBAAiBJ,SACf,OAAAP,EAAAhB,KAAKG,WAAUa,EAAAC,SACfjB,KAAKG,SAAW,KAChBH,KAAKI,iBAAmBmB,EACnBvB,KAAAH,WAGPiC,mBAAmBL,GACX,MAAAO,EAAQC,OAAOC,OAvII,SAAAT,EAAWC,EAAcS,GAChD,IAACV,IAASC,EACL,OAAA,KAGTS,EAAcA,GAAe,GAC7B,MAAMH,EAAQ,IACRI,SAAEA,EAAUC,WAAAA,GAAeC,EAAeb,GAChD,IAAA,MAAWc,KAAUH,EAAU,CAClBC,EAAAG,QACL,MAAA3D,EAAO6C,EAAQa,EAAQF,GACvBvD,EAAKF,EAAUC,GAErB,IAAKA,EACH,MAAM,IAAI4D,MAAM,oBAGd,IAAC5D,EAAKE,IACR,MAAM,IAAI0D,MAAM,wBAGbT,EAAMlD,IAASqD,EAAYrD,IAAOD,EAAKE,MAAQoD,EAAYrD,GAAIC,MAClEiD,EAAMlD,GAAMS,EAAKmD,EAAA,GAAA7D,GAAL,CAAW8D,OAAQJ,EAAQK,YAAaP,EAAWG,SAG5D,OAAAR,EA8GuBa,CAAapB,EAAMzB,KAAKE,SAAUF,KAAKK,WAAa,IAE5E,GAAA2B,EAAM3C,OAAS,EAAG,CAEpB,MAAMJ,QAAEA,EAASK,QAAAA,EAAAH,QAASA,EAAS2D,UAAAA,EAAAC,aAAWA,GAvMvB,UAAAf,MAC3BA,EAAAgB,OACAA,EAAA/D,QACAA,EAAU,GAAAK,QACVA,EAAU,EAAAH,QACVA,EAAU,EAAA2D,UACVA,EAAY,EAAAG,YACZA,IAEA,IAAI/D,EAAU,GAQd,IAAA,IAASE,EAAI,EAAGA,EAAI4C,EAAM3C,OAAQD,IAAK,CACrC,MAAMP,EAAOmD,EAAM5C,GAGf,IAACH,EAFML,EAAUC,IAEH,CACV,MAAAL,OAAEA,QAAQD,GAAUM,EAGtBS,EAAUf,EAAQyE,EAASC,IAC7BjE,EAAgBC,EAASC,EAASC,GAExBG,EAAA,EACVH,EAAU2D,EAAY3D,EAAU6D,EACpBF,EAAA,EACF5D,EAAA,IAGZA,EAAQgE,KAAK,CACXrE,KAAAA,EACAS,QAAAA,IAGFA,EAAUA,EAAUf,EAAQyE,EAChBF,EAAAK,KAAKC,IAAIN,EAAWtE,IAQ7B,OAJHU,EAAQG,OAAS,GACnBL,EAAgBC,EAASC,EAASC,GAG7B,CACLF,QAAAA,EACA6D,UAAAA,EACAxD,QAAAA,EACAH,QAAAA,EACA8D,YAAAA,EACAF,cAxHkBM,EAwHSP,EAAY3D,EAAU6D,EAvH5CG,KAAKG,IAAI,EAAGH,KAAKI,KAAKJ,KAAKK,KAAKH,OADzC,IAAsBA,EAyQ+CI,CAAa,CAC1EzB,MAAAA,EACAgB,OAAQhD,KAAKW,QACbsC,YAAajD,KAAKY,aAClB3B,QAASe,KAAKK,SACdyC,UAAW9C,KAAKU,WAChBpB,QAASU,KAAKQ,SACdrB,QAASa,KAAKS,WAGhBT,KAAKU,WAAaoC,EAClB9C,KAAKK,SAAWpB,EAChBe,KAAKQ,SAAWlB,EAChBU,KAAKS,SAAWtB,EAChBa,KAAKa,cAAgBkC,EAGhB/C,KAAKG,WACRH,KAAKG,SAAW,IAAIuD,EAAU1D,KAAKJ,GAAI,CACrCrB,MAAOyB,KAAKY,aACZpC,OAAQwB,KAAKa,cACb8C,WAAYhG,KAIZqC,KAAKG,SAAS3B,SAAWwB,KAAKa,gBAC3Bb,KAAAG,SAzQb,SAAuBP,EAASgE,EAAcrF,EAAYC,GACxD,MAAMqF,EAAWD,EAAQrF,MACnBuF,EAAYF,EAAQpF,OAEpBuF,EAAaC,EAAiBJ,EAAS,CAAErF,MAAAA,EAAOC,OAAAA,IAQ/C,OAPPyF,EAAcL,EAASG,EAAY,CACjCG,QAAS,EACT3F,MAAOsF,EACPrF,OAAQsF,IAGFF,EAAA3C,SACD8C,EA6PeI,CAAcnE,KAAKJ,GAAII,KAAKG,SAAUH,KAAKY,aAAcZ,KAAKa,gBAG3Eb,KAAAH,WAGLG,KAAKoE,WAAWpC,IAIpBoC,WAAWpC,GACH,MAAA3D,EAAM2B,KAAKc,QAAQuD,WAAW,MAEpC,IAAA,MAAWxF,KAAQmD,EACZhC,KAAAM,gBACLgE,EAAKzF,EAAKE,IAAKwF,EAAavE,KAAKC,cAC9BuE,MAAkBlG,IACjB,MAAMQ,EAAKF,EAAUC,IACfW,EAAEA,EAAGC,EAAAA,EAAAlB,MAAGA,EAAOC,OAAAA,GAAWwB,KAAKK,SAASvB,GAExC2C,EAAOrD,EAAYC,EAAKC,EAAWC,EAAOC,GAEhDwB,KAAKG,SAASsE,gBAAgB,CAC5BhD,KAAAA,EACAjC,EAAAA,EACAC,EAAAA,EACAlB,MAAAA,EACAC,OAAAA,IAIFwB,KAAKG,SAASuE,iBAET1E,KAAAH,cAEN8E,OAAeC,IACd5E,KAAKF,QAAQ,CACXf,IAAKF,EAAKE,IACV4D,OAAQ9D,EAAK8D,OACbC,YAAa/D,EAAK+D,YAClBvB,YAAarB,KAAKC,aAClB2E,MAAAA,OAGHC,SAAQ,KACF7E,KAAAM"}