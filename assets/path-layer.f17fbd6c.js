var t=Object.defineProperty,e=Object.defineProperties,n=Object.getOwnPropertyDescriptors,i=Object.getOwnPropertySymbols,o=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable,r=(e,n,i)=>n in e?t(e,n,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[n]=i,a=(t,e)=>{for(var n in e||(e={}))o.call(e,n)&&r(t,n,e[n]);if(i)for(var n of i(e))s.call(e,n)&&r(t,n,e[n]);return t},l=(t,i)=>e(t,n(i));import{_ as c,a5 as d,a6 as h,a7 as p,W as f,a8 as u,a as g,b as v,c as m,U as y,M as P,G as x}from"./layer.b20bd88e.js";class b{constructor(t){c(this,"opts",void 0),c(this,"typedArrayManager",void 0),c(this,"indexStarts",[0]),c(this,"vertexStarts",[0]),c(this,"vertexCount",0),c(this,"instanceCount",0),c(this,"attributes",void 0),c(this,"_attributeDefs",void 0),c(this,"data",void 0),c(this,"getGeometry",void 0),c(this,"geometryBuffer",void 0),c(this,"buffers",void 0),c(this,"positionSize",void 0),c(this,"normalize",void 0);const{attributes:e={}}=t;this.typedArrayManager=d,this.attributes={},this._attributeDefs=e,this.opts=t,this.updateGeometry(t)}updateGeometry(t){Object.assign(this.opts,t);const{data:e,buffers:n={},getGeometry:i,geometryBuffer:o,positionFormat:s,dataChanged:r,normalize:a=!0}=this.opts;if(this.data=e,this.getGeometry=i,this.positionSize=o&&o.size||("XY"===s?2:3),this.buffers=n,this.normalize=a,o&&(h(e.startIndices),this.getGeometry=this.getGeometryFromBuffer(o),a||(n.positions=o)),this.geometryBuffer=n.positions,Array.isArray(r))for(const l of r)this._rebuildGeometry(l);else this._rebuildGeometry()}updatePartialGeometry({startRow:t,endRow:e}){this._rebuildGeometry({startRow:t,endRow:e})}getGeometryFromBuffer(t){const e=t.value||t;return ArrayBuffer.isView(e)?p(e,{size:this.positionSize,offset:t.offset,stride:t.stride,startIndices:this.data.startIndices}):null}_allocate(t,e){const{attributes:n,buffers:i,_attributeDefs:o,typedArrayManager:s}=this;for(const r in o)if(r in i)s.release(n[r]),n[r]=null;else{const i=o[r];i.copy=e,n[r]=s.allocate(n[r],t,i)}}_forEachGeometry(t,e,n){const{data:i,getGeometry:o}=this,{iterable:s,objectInfo:r}=f(i,e,n);for(const a of s){r.index++;t(o?o(a,r):null,r.index)}}_rebuildGeometry(t){if(!this.data)return;let{indexStarts:e,vertexStarts:n,instanceCount:i}=this;const{data:o,geometryBuffer:s}=this,{startRow:r=0,endRow:a=1/0}=t||{},l={};if(t||(e=[0],n=[0]),this.normalize||!s)this._forEachGeometry(((t,e)=>{const i=t&&this.normalizeGeometry(t);l[e]=i,n[e+1]=n[e]+(i?this.getGeometrySize(i):0)}),r,a),i=n[n.length-1];else if(n=o.startIndices,i=n[o.length]||0,ArrayBuffer.isView(s))i=i||s.length/this.positionSize;else if(s instanceof u){const t=s.accessor.stride||4*this.positionSize;i=i||s.byteLength/t}else if(s.buffer){const t=s.stride||4*this.positionSize;i=i||s.buffer.byteLength/t}else if(s.value){const t=s.value,e=s.stride/t.BYTES_PER_ELEMENT||this.positionSize;i=i||t.length/e}this._allocate(i,Boolean(t)),this.indexStarts=e,this.vertexStarts=n,this.instanceCount=i;const c={};this._forEachGeometry(((t,o)=>{const s=l[o]||t;c.vertexStart=n[o],c.indexStart=e[o];const r=o<n.length-1?n[o+1]:i;c.geometrySize=r-n[o],c.geometryIndex=o,this.updateGeometryAttributes(s,c)}),r,a),this.vertexCount=e[e.length-1]}}function S(t,e){const n=e.length,i=t.length;if(i>0){let o=!0;for(let s=0;s<n;s++)if(t[i-n+s]!==e[s]){o=!1;break}if(o)return!1}for(let o=0;o<n;o++)t[i+o]=e[o];return!0}function w(t,e){const n=e.length;for(let i=0;i<n;i++)t[i]=e[i]}function _(t,e,n,i,o=[]){const s=i+e*n;for(let r=0;r<n;r++)o[r]=t[s+r];return o}function L(t,e,n,i,o=[]){let s,r;if(8&n)s=(i[3]-t[1])/(e[1]-t[1]),r=3;else if(4&n)s=(i[1]-t[1])/(e[1]-t[1]),r=1;else if(2&n)s=(i[2]-t[0])/(e[0]-t[0]),r=2;else{if(!(1&n))return null;s=(i[0]-t[0])/(e[0]-t[0]),r=0}for(let a=0;a<t.length;a++)o[a]=(1&r)===a?i[r]:s*(e[a]-t[a])+t[a];return o}function z(t,e){let n=0;return t[0]<e[0]?n|=1:t[0]>e[2]&&(n|=2),t[1]<e[1]?n|=4:t[1]>e[3]&&(n|=8),n}function E(t,e){const{size:n=2,broken:i=!1,gridResolution:o=10,gridOffset:s=[0,0],startIndex:r=0,endIndex:a=t.length}=e||{},l=(a-r)/n;let c=[];const d=[c],h=_(t,0,n,r);let p,f;const u=O(h,o,s,[]),g=[];S(c,h);for(let v=1;v<l;v++){for(p=_(t,v,n,r,p),f=z(p,u);f;){L(h,p,f,u,g);const t=z(g,u);t&&(L(h,g,t,u,g),f=t),S(c,g),w(h,g),M(u,o,f),i&&c.length>n&&(c=[],d.push(c),S(c,h)),f=z(p,u)}S(c,p),w(h,p)}return i?d:d[0]}function A(t,e){for(let n=0;n<e.length;n++)t.push(e[n]);return t}function C(t,e=null,n){if(!t.length)return[];const{size:i=2,gridResolution:o=10,gridOffset:s=[0,0],edgeTypes:r=!1}=n||{},a=[],l=[{pos:t,types:r?new Array(t.length/i).fill(1):null,holes:e||[]}],c=[[],[]];let d=[];for(;l.length;){const{pos:t,types:e,holes:n}=l.shift();I(t,i,n[0]||t.length,c),d=O(c[0],o,s,d);const h=z(c[1],d);if(h){let o=T(t,e,i,0,n[0]||t.length,d,h);const s={pos:o[0].pos,types:o[0].types,holes:[]},a={pos:o[1].pos,types:o[1].types,holes:[]};l.push(s,a);for(let l=0;l<n.length;l++)o=T(t,e,i,n[l],n[l+1]||t.length,d,h),o[0]&&(s.holes.push(s.pos.length),s.pos=A(s.pos,o[0].pos),r&&(s.types=A(s.types,o[0].types))),o[1]&&(a.holes.push(a.pos.length),a.pos=A(a.pos,o[1].pos),r&&(a.types=A(a.types,o[1].types)))}else{const i={positions:t};r&&(i.edgeTypes=e),n.length&&(i.holeIndices=n),a.push(i)}}return a}function T(t,e,n,i,o,s,r){const a=(o-i)/n,l=[],c=[],d=[],h=[],p=[];let f,u,g;const v=_(t,a-1,n,i);let m=Math.sign(8&r?v[1]-s[3]:v[0]-s[2]),y=e&&e[a-1],P=0,x=0;for(let b=0;b<a;b++)f=_(t,b,n,i,f),u=Math.sign(8&r?f[1]-s[3]:f[0]-s[2]),g=e&&e[i/n+b],u&&m&&m!==u&&(L(v,f,r,s,p),S(l,p)&&d.push(y),S(c,p)&&h.push(y)),u<=0?(S(l,f)&&d.push(g),P-=u):d.length&&(d[d.length-1]=0),u>=0?(S(c,f)&&h.push(g),x+=u):h.length&&(h[h.length-1]=0),w(v,f),m=u,y=g;return[P?{pos:l,types:e&&d}:null,x?{pos:c,types:e&&h}:null]}function O(t,e,n,i){const o=Math.floor((t[0]-n[0])/e)*e+n[0],s=Math.floor((t[1]-n[1])/e)*e+n[1];return i[0]=o,i[1]=s,i[2]=o+e,i[3]=s+e,i}function M(t,e,n){8&n?(t[1]+=e,t[3]+=e):4&n?(t[1]-=e,t[3]-=e):2&n?(t[0]+=e,t[2]+=e):1&n&&(t[0]-=e,t[2]-=e)}function I(t,e,n,i){let o=1/0,s=-1/0,r=1/0,a=-1/0;for(let l=0;l<n;l+=e){const e=t[l],n=t[l+1];o=e<o?e:o,s=e>s?e:s,r=n<r?n:r,a=n>a?n:a}return i[0][0]=o,i[0][1]=r,i[1][0]=s,i[1][1]=a,i}function R(t,e=null,n){const{size:i=2,normalize:o=!0,edgeTypes:s=!1}=n||{};e=e||[];const r=[],a=[];let l=0,c=0;for(let h=0;h<=e.length;h++){const o=e[h]||t.length,s=c,d=G(t,i,l,o);for(let e=d;e<o;e++)r[c++]=t[e];for(let e=l;e<d;e++)r[c++]=t[e];F(r,i,s,c),B(r,i,s,c,null==n?void 0:n.maxLatitude),l=o,a[h]=c}a.pop();const d=C(r,a,{size:i,gridResolution:360,gridOffset:[-180,-180],edgeTypes:s});if(o)for(const h of d)j(h.positions,i);return d}function G(t,e,n,i){let o=-1,s=-1;for(let r=n+1;r<i;r+=e){const e=Math.abs(t[r]);e>o&&(o=e,s=r-1)}return s}function B(t,e,n,i,o=85.051129){const s=t[n],r=t[i-e];if(Math.abs(s-r)>180){const i=_(t,0,e,n);i[0]+=360*Math.round((r-s)/360),S(t,i),i[1]=Math.sign(i[1])*o,S(t,i),i[0]=s,S(t,i)}}function F(t,e,n,i){let o,s=t[0];for(let r=n;r<i;r+=e){o=t[r];const e=o-s;(e>180||e<-180)&&(o-=360*Math.round(e/360)),t[r]=s=o}}function j(t,e){let n;const i=t.length/e;for(let s=0;s<i&&(n=t[s*e],(n+180)%360==0);s++);const o=360*-Math.round(n/360);if(0!==o)for(let s=0;s<i;s++)t[s*e]+=o}function k(t,e,n,i){let o;if(Array.isArray(t[0])){const n=t.length*e;o=new Array(n);for(let i=0;i<t.length;i++)for(let n=0;n<e;n++)o[i*e+n]=t[i][n]||0}else o=t;return n?E(o,{size:e,gridResolution:n}):i?function(t,e){const{size:n=2,startIndex:i=0,endIndex:o=t.length,normalize:s=!0}=e||{},r=t.slice(i,o);F(r,n,0,o-i);const a=E(r,{size:n,broken:!0,gridResolution:360,gridOffset:[-180,-180]});if(s)for(const l of a)j(l,n);return a}(o,{size:e}):o}class D extends b{constructor(t){super(l(a({},t),{attributes:{positions:{size:3,padding:18,initialize:!0,type:t.fp64?Float64Array:Float32Array},segmentTypes:{size:1,type:Uint8ClampedArray}}}))}get(t){return this.attributes[t]}getGeometryFromBuffer(t){return this.normalize?super.getGeometryFromBuffer(t):null}normalizeGeometry(t){return this.normalize?k(t,this.positionSize,this.opts.resolution,this.opts.wrapLongitude):t}getGeometrySize(t){if(V(t)){let e=0;for(const n of t)e+=this.getGeometrySize(n);return e}const e=this.getPathLength(t);return e<2?0:this.isClosed(t)?e<3?0:e+2:e}updateGeometryAttributes(t,e){if(0!==e.geometrySize)if(t&&V(t))for(const n of t){const t=this.getGeometrySize(n);e.geometrySize=t,this.updateGeometryAttributes(n,e),e.vertexStart+=t}else this._updateSegmentTypes(t,e),this._updatePositions(t,e)}_updateSegmentTypes(t,e){const n=this.attributes.segmentTypes,i=!!t&&this.isClosed(t),{vertexStart:o,geometrySize:s}=e;n.fill(0,o,o+s),i?(n[o]=4,n[o+s-2]=4):(n[o]+=1,n[o+s-2]+=2),n[o+s-1]=4}_updatePositions(t,e){const{positions:n}=this.attributes;if(!n||!t)return;const{vertexStart:i,geometrySize:o}=e,s=new Array(3);for(let r=i,a=0;a<o;r++,a++)this.getPointOnPath(t,a,s),n[3*r]=s[0],n[3*r+1]=s[1],n[3*r+2]=s[2]}getPathLength(t){return t.length/this.positionSize}getPointOnPath(t,e,n=[]){const{positionSize:i}=this;e*i>=t.length&&(e+=1-t.length/i);const o=e*i;return n[0]=t[o],n[1]=t[o+1],n[2]=3===i&&t[o+2]||0,n}isClosed(t){if(!this.normalize)return Boolean(this.opts.loop);const{positionSize:e}=this,n=t.length-e;return t[0]===t[n]&&t[1]===t[n+1]&&(2===e||t[2]===t[n+2])}}function V(t){return Array.isArray(t[0])}const N=[0,0,0,255],J={widthUnits:"meters",widthScale:{type:"number",min:0,value:1},widthMinPixels:{type:"number",min:0,value:0},widthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},jointRounded:!1,capRounded:!1,miterLimit:{type:"number",min:0,value:4},billboard:!1,_pathType:null,getPath:{type:"accessor",value:t=>t.path},getColor:{type:"accessor",value:N},getWidth:{type:"accessor",value:1},rounded:{deprecatedFor:["jointRounded","capRounded"]}},U={enter:(t,e)=>e.length?e.subarray(e.length-t.length):t};class H extends g{constructor(...t){super(...t),c(this,"state",void 0)}getShaders(){return super.getShaders({vs:"#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\n\n// calculate line join positions\nvec3 lineJoin(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  // side of the segment - -1: left, 0: center, 1: right\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n\n  // tangent of the corner\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  // direction of the corner\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  // direction of the segment\n  vec2 dir = isEnd ? dirA : dirB;\n  // direction of the extrusion\n  vec2 perp = isEnd ? perpA : perpB;\n  // length of the segment\n  float L = isEnd ? lenA : lenB;\n\n  // A = angle of the corner\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n\n  // -1: right, 1: left\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n\n  // relative position to the corner:\n  // -1: inside (smaller side of the angle)\n  // 0: center\n  // 1: outside (bigger side of the angle)\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  // trim if inside corner extends further than the line segment\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n\n  // special treatment for start cap and end cap\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n\n  // extend out a triangle to envelope the round cap\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n\n  // Generate variables for fragment shader\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return currPoint + offset;\n}\n\n// In clipspace extrusion, if a line extends behind the camera, clip it to avoid visual artifacts\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    // Extrude in clipspace\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 pos = lineJoin(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    // Extrude in commonspace\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec4 pos = vec4(\n      lineJoin(prevPosition, currPosition, nextPosition, width.xy),\n      1.0);\n    geometry.position = pos;\n    gl_Position = project_common_position_to_clipspace(pos);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\n/*\n * vPathPosition represents the relative coordinates of the current fragment on the path segment.\n * vPathPosition.x - position along the width of the path, between [-1, 1]. 0 is the center line.\n * vPathPosition.y - position along the length of the path, between [0, L / width].\n */\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    // if joint is rounded, test distance from the corner\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    // trim miter\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[v,m]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({positions:{size:3,vertexOffset:1,type:5130,fp64:this.use64bitPositions(),transition:U,accessor:"getPath",update:this.calculatePositions,noAlloc:true,shaderAttributes:{instanceLeftPositions:{vertexOffset:0},instanceStartPositions:{vertexOffset:1},instanceEndPositions:{vertexOffset:2},instanceRightPositions:{vertexOffset:3}}},instanceTypes:{size:1,type:5121,update:this.calculateSegmentTypes,noAlloc:true},instanceStrokeWidths:{size:1,accessor:"getWidth",transition:U,defaultValue:1},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,accessor:"getColor",transition:U,defaultValue:N},instancePickingColors:{size:3,type:5121,accessor:(t,{index:e,target:n})=>this.encodePickingColor(t&&t.__source?t.__source.index:e,n)}}),this.setState({pathTesselator:new D({fp64:this.use64bitPositions()})})}updateState(t){super.updateState(t);const{props:e,changeFlags:n}=t,i=this.getAttributeManager();if(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getPath)){const{pathTesselator:t}=this.state,o=e.data.attributes||{};t.updateGeometry({data:e.data,geometryBuffer:o.getPath,buffers:o,normalize:!e._pathType,loop:"loop"===e._pathType,getGeometry:e.getPath,positionFormat:e.positionFormat,wrapLongitude:e.wrapLongitude,resolution:this.context.viewport.resolution,dataChanged:n.dataChanged}),this.setState({numInstances:t.instanceCount,startIndices:t.vertexStarts}),n.dataChanged||i.invalidateAll()}if(n.extensionsChanged){var o;const{gl:t}=this.context;null===(o=this.state.model)||void 0===o||o.delete(),this.state.model=this._getModel(t),i.invalidateAll()}}getPickingInfo(t){const e=super.getPickingInfo(t),{index:n}=e,{data:i}=this.props;return i[0]&&i[0].__source&&(e.object=i.find((t=>t.__source.index===n))),e}disablePickingIndex(t){const{data:e}=this.props;if(e[0]&&e[0].__source)for(let n=0;n<e.length;n++)e[n].__source.index===t&&this._disablePickingIndex(n);else this._disablePickingIndex(t)}draw({uniforms:t}){const{jointRounded:e,capRounded:n,billboard:i,miterLimit:o,widthUnits:s,widthScale:r,widthMinPixels:a,widthMaxPixels:l}=this.props;this.state.model.setUniforms(t).setUniforms({jointType:Number(e),capType:Number(n),billboard:i,widthUnits:y[s],widthScale:r,miterLimit:o,widthMinPixels:a,widthMaxPixels:l}).draw()}_getModel(t){return new P(t,l(a({},this.getShaders()),{id:this.props.id,geometry:new x({drawMode:4,attributes:{indices:new Uint16Array([0,1,2,1,4,2,1,3,4,3,5,4]),positions:{value:new Float32Array([0,0,0,-1,0,1,1,-1,1,1,1,0]),size:2}}}),isInstanced:!0}))}calculatePositions(t){const{pathTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("positions")}calculateSegmentTypes(t){const{pathTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("segmentTypes")}}c(H,"defaultProps",J),c(H,"layerName","PathLayer");export{H as P,b as T,R as a,C as c};
//# sourceMappingURL=path-layer.f17fbd6c.js.map
