{"version":3,"file":"DashboardDataManager.e0d06cdd.js","sources":["../../node_modules/d3-array/src/identity.js","../../node_modules/d3-array/src/group.js","../../src/js/DashboardDataManager.ts"],"sourcesContent":["export default function identity(x) {\n  return x;\n}\n","import {InternMap} from \"internmap\";\nimport identity from \"./identity.js\";\n\nexport default function group(values, ...keys) {\n  return nest(values, identity, identity, keys);\n}\n\nexport function groups(values, ...keys) {\n  return nest(values, Array.from, identity, keys);\n}\n\nfunction flatten(groups, keys) {\n  for (let i = 1, n = keys.length; i < n; ++i) {\n    groups = groups.flatMap(g => g.pop().map(([key, value]) => [...g, key, value]));\n  }\n  return groups;\n}\n\nexport function flatGroup(values, ...keys) {\n  return flatten(groups(values, ...keys), keys);\n}\n\nexport function flatRollup(values, reduce, ...keys) {\n  return flatten(rollups(values, reduce, ...keys), keys);\n}\n\nexport function rollup(values, reduce, ...keys) {\n  return nest(values, identity, reduce, keys);\n}\n\nexport function rollups(values, reduce, ...keys) {\n  return nest(values, Array.from, reduce, keys);\n}\n\nexport function index(values, ...keys) {\n  return nest(values, identity, unique, keys);\n}\n\nexport function indexes(values, ...keys) {\n  return nest(values, Array.from, unique, keys);\n}\n\nfunction unique(values) {\n  if (values.length !== 1) throw new Error(\"duplicate key\");\n  return values[0];\n}\n\nfunction nest(values, map, reduce, keys) {\n  return (function regroup(values, i) {\n    if (i >= keys.length) return reduce(values);\n    const groups = new InternMap();\n    const keyof = keys[i++];\n    let index = -1;\n    for (const value of values) {\n      const key = keyof(value, ++index, values);\n      const group = groups.get(key);\n      if (group) group.push(value);\n      else groups.set(key, [value]);\n    }\n    for (const [key, values] of groups) {\n      groups.set(key, regroup(values, i));\n    }\n    return map(groups);\n  })(values, 0);\n}\n","/**\r\n * DashboardDataManager: this class loads, caches, and filters CSV and XML datasets\r\n * for use by dashboard charts and maps. Loosely based on the VizWit system\r\n * (see http://vizwit.io/) but we don't have a Carto database so all of the data\r\n * is stored internally in this class.\r\n *\r\n * Each tabbed dashboard should instantiate this class once, and destroy it when the dashboard\r\n * is closed. Datasets can be big, we don't want them to stick around forever!\r\n *\r\n * Data queries always return -both- the full dataset AND a filtered dataset.\r\n * That way, the filtered data can be visually layered on top of the full data.\r\n */\r\n\r\nimport { rollup } from 'd3-array'\r\n\r\nimport globalStore from '@/store'\r\nimport HTTPFileSystem from './HTTPFileSystem'\r\nimport { DataTable, DataTableColumn, DataType, FileSystemConfig, Status } from '@/Globals'\r\nimport { findMatchingGlobInFiles } from '@/js/util'\r\n\r\nimport DataFetcherWorker from '@/workers/DataFetcher.worker.ts?worker'\r\nimport RoadNetworkLoader from '@/workers/RoadNetworkLoader.worker.ts?worker'\r\n\r\ninterface configuration {\r\n  dataset: string\r\n  groupBy?: string\r\n  value?: string\r\n  usedCol?: string[]\r\n  columns?: string[]\r\n  ignoreColumns?: any[]\r\n  skipFirstRow?: boolean\r\n  useLastRow?: boolean\r\n  x?: string\r\n}\r\n\r\nexport interface FilterDefinition {\r\n  dataset: string\r\n  column: string\r\n  value: any\r\n  operator?: string\r\n  invert?: boolean\r\n  range?: boolean\r\n}\r\n\r\nexport interface NetworkLinks {\r\n  source: Float32Array\r\n  dest: Float32Array\r\n  linkIds: any[]\r\n  projection: String\r\n}\r\n\r\n// This tells us if our environment has the Chrome File System Access API, meaning we are in Chrome\r\n//@ts-ignore\r\nconst isChrome = !!window.showDirectoryPicker\r\nconst isFirefox = !isChrome\r\n\r\nexport default class DashboardDataManager {\r\n  constructor(...args: string[]) {\r\n    // hello\r\n    this.root = args.length ? args[0] : ''\r\n    this.subfolder = args.length ? args[1] : ''\r\n    this.fileApi = this._getFileSystem(this.root)\r\n  }\r\n\r\n  private files: any[] = []\r\n  private threads: Worker[] = []\r\n  private subfolder = ''\r\n  private root = ''\r\n  private fileApi: FileSystemConfig\r\n  private networks: { [id: string]: Promise<NetworkLinks> } = {}\r\n\r\n  public kill() {\r\n    for (const worker of this.threads) worker.terminate()\r\n  }\r\n\r\n  public getFilteredDataset(config: { dataset: string }): { filteredRows: any[] | null } {\r\n    if (!(config.dataset in this.datasets)) return { filteredRows: null }\r\n\r\n    const filteredRows = this.datasets[config.dataset].filteredRows\r\n    return { filteredRows }\r\n  }\r\n\r\n  public async OLDgetFiltered(config: { dataset: string; groupBy?: string; value?: string }) {\r\n    const rows = this.datasets[config.dataset].filteredRows\r\n    if (!rows) return { filteredRows: null }\r\n\r\n    // group the rows as needed\r\n    let bars: any = {}\r\n\r\n    if (config.value && config.groupBy) {\r\n      const columnValues = config.value\r\n      const columnGroups = config.groupBy\r\n      bars = rollup(\r\n        rows,\r\n        v => v.reduce((a, b) => a + b[columnValues], 0),\r\n        (d: any) => d[columnGroups] // group-by\r\n      )\r\n    } else {\r\n      // TODO need to handle non-value, non-group here\r\n    }\r\n    const x = Array.from(bars.keys())\r\n    const y = Array.from(bars.values())\r\n\r\n    // filter the rows, too\r\n\r\n    return { filteredRows: { x, y } }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param config the configuration params from the YAML file. Must include dataset,\r\n   *               and may include other optional parameters as needed by the viz\r\n   * @returns allRows object, containing a DataTableColumn for each column in this dataset\r\n   */\r\n  public async getDataset(config: configuration, options?: { highPrecision: boolean }) {\r\n    try {\r\n      // first, get the dataset\r\n      if (!this.datasets[config.dataset]) {\r\n        console.log('load:', config.dataset)\r\n\r\n        // fetchDataset() immediately returns a Promise<>, which we await on\r\n        // so that multiple charts don't all try to fetch the dataset individually\r\n        this.datasets[config.dataset] = {\r\n          dataset: this._fetchDataset(config, options),\r\n          activeFilters: {},\r\n          filteredRows: null,\r\n          filterListeners: new Set(),\r\n        }\r\n      }\r\n\r\n      // wait for dataset to load\r\n      // (this will immediately return dataset if it is already loaded)\r\n      let myDataset = await this.datasets[config.dataset].dataset\r\n\r\n      // make a copy because each viz in a dashboard might be hacking it differently\r\n      // TODO: be more \"functional\" and return the object itself, and let views create copies if they need to\r\n      let allRows = { ...myDataset }\r\n\r\n      // remove ignored columns\r\n      if (config.ignoreColumns) {\r\n        config.ignoreColumns.forEach(column => {\r\n          delete allRows[column]\r\n        })\r\n      }\r\n\r\n      // if useLastRow, drop all rows except the last row\r\n      if (config.useLastRow) {\r\n        Object.keys(allRows).forEach(colName => {\r\n          const values = myDataset[colName].values\r\n          allRows[colName] = values[values.length - 1]\r\n        })\r\n      }\r\n\r\n      return { allRows }\r\n    } catch (e) {\r\n      // const message = '' + e\r\n      return { allRows: {} }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert features array from GeoJSONs and Shapefiles into DataTable\r\n   * @param filename\r\n   * @param featureProperties array of feature objects\r\n   */\r\n  public setFeatureProperties(fullpath: string, featureProperties: any[], config: any) {\r\n    const key = fullpath.substring(fullpath.lastIndexOf('/') + 1)\r\n\r\n    // merge key with keep/drop params (etc)\r\n    let fullConfig = { dataset: key }\r\n    if ('string' !== typeof config) fullConfig = Object.assign(fullConfig, config)\r\n\r\n    this.datasets[key] = {\r\n      activeFilters: {},\r\n      filteredRows: null,\r\n      filterListeners: new Set(),\r\n      dataset: new Promise<DataTable>((resolve, reject) => {\r\n        const thread = new DataFetcherWorker()\r\n        // console.log('NEW WORKER', thread)\r\n        this.threads.push(thread)\r\n\r\n        try {\r\n          thread.postMessage({ config: fullConfig, featureProperties })\r\n\r\n          thread.onmessage = e => {\r\n            thread.terminate()\r\n            if (e.data.error) {\r\n              console.log(e.data.error)\r\n              globalStore.commit('setStatus', {\r\n                type: Status.ERROR,\r\n                msg: `Problem loading properties in ${fullpath}`,\r\n                desc: 'File loaded from storage, but properties table could not be parsed',\r\n              })\r\n              reject()\r\n            }\r\n            resolve(e.data)\r\n          }\r\n        } catch (err) {\r\n          thread.terminate()\r\n          console.error(err)\r\n          reject(err)\r\n        }\r\n      }),\r\n    }\r\n    // this is a promise:\r\n    return this.datasets[key].dataset\r\n  }\r\n\r\n  /**\r\n   *  Register an existing in-memory DataTable as a dataset in this Dashboard\r\n   * @param props key, dataTable, and filename associated with this DataTable\r\n   */\r\n  public setPreloadedDataset(props: { key: string; dataTable: DataTable }) {\r\n    // let filters = {}\r\n    // if (this.datasets[props.key]) {\r\n    //   filters = this.datasets[props.key].activeFilters\r\n    // }\r\n\r\n    this.datasets[props.key] = {\r\n      dataset: new Promise<DataTable>((resolve, reject) => {\r\n        resolve(props.dataTable)\r\n      }),\r\n      activeFilters: {}, // filters,\r\n      filteredRows: null,\r\n      filterListeners: new Set(),\r\n    }\r\n  }\r\n\r\n  public async getRoadNetwork(\r\n    filename: string,\r\n    subfolder: string,\r\n    vizDetails: any,\r\n    cbStatus?: any\r\n  ) {\r\n    const path = `/${subfolder}/${filename}`\r\n    // Get the dataset the first time it is requested\r\n    if (!this.networks[path]) {\r\n      this.networks[path] = this._fetchNetwork({ subfolder, filename, vizDetails, cbStatus })\r\n    }\r\n\r\n    // wait for the worker to provide the network\r\n    let network = await this.networks[path]\r\n    return network\r\n  }\r\n\r\n  // /**\r\n  //  * Load simple dataset without grouping/filtering\r\n  //  * @param allRows Each row\r\n  //  * @returns TBD\r\n  //  */\r\n  // public loadSimple(config: configuration, allRows: any[]) {\r\n  //   // Simple requires x and columns/usedCol\r\n  //   if (!config.x || (!config.columns && !config.usedCol)) {\r\n  //     throw Error('Config requires \"x\" and \"columns\" parameters')\r\n  //   }\r\n\r\n  //   var useOwnNames = false\r\n\r\n  //   const x = [] as any[]\r\n\r\n  //   for (var i = 0; i < allRows.length; i++) {\r\n  //     if (i == 0 && config.skipFirstRow) {\r\n  //     } else {\r\n  //       x.push(allRows[i][config.x])\r\n  //     }\r\n  //   }\r\n\r\n  //   const columns = config.columns || config.usedCol || []\r\n\r\n  //   for (let i = 0; i < columns.length; i++) {\r\n  //     const name = columns[i]\r\n  //     let legendName = ''\r\n  //     if (columns[i] !== 'undefined') {\r\n  //       if (useOwnNames) {\r\n  //         legendName = this.config.legendTitles[i]\r\n  //       } else {\r\n  //         legendName = name\r\n  //       }\r\n  //       const value = []\r\n  //       for (var j = 0; j < this.dataRows.length; j++) {\r\n  //         if (j == 0 && this.config.skipFirstRow) {\r\n  //         } else {\r\n  //           value.push(this.dataRows[j][name])\r\n  //         }\r\n  //       }\r\n  //       this.data.push({\r\n  //         x: x,\r\n  //         y: value,\r\n  //         name: legendName,\r\n  //         type: 'bar',\r\n  //         textinfo: 'label+percent',\r\n  //         textposition: 'inside',\r\n  //         automargin: true,\r\n  //       })\r\n  //     }\r\n  //   }\r\n  // }\r\n\r\n  public setFilter(filter: FilterDefinition) {\r\n    const { dataset, column, value, invert, range } = filter\r\n\r\n    if (!this.datasets[dataset]) {\r\n      console.warn(`${dataset} doesn't exist yet`)\r\n      console.warn(Object.keys(this.datasets))\r\n      return\r\n    }\r\n    console.log('> setFilter', dataset, column, value)\r\n\r\n    // Filter might be single or an array; make it an array.\r\n    const values = Array.isArray(value) ? value : [value]\r\n    if (this.datasets[dataset].activeFilters == null) {\r\n      this.datasets[dataset].activeFilters = {}\r\n    }\r\n    const allFilters = this.datasets[dataset].activeFilters\r\n    // a second click on a filter means REMOVE this filter.\r\n    // if (allFilters[column] !== undefined && allFilters[column] === values) {\r\n    //   console.log('A1', allFilters[column])\r\n    //   delete allFilters[column]\r\n    // } else\r\n    if (!values.length) {\r\n      delete allFilters[column]\r\n    } else {\r\n      allFilters[column] = { values, invert, range }\r\n    }\r\n    this._updateFilters(dataset) // this is async\r\n  }\r\n\r\n  public addFilterListener(config: { dataset: string }, listener: any) {\r\n    const selectedDataset = this.datasets[config.dataset]\r\n    if (!selectedDataset) throw Error('No dataset named: ' + config.dataset)\r\n\r\n    // console.log(22, config.dataset, this.datasets[config.dataset])\r\n    this.datasets[config.dataset].filterListeners.add(listener)\r\n  }\r\n\r\n  public removeFilterListener(config: { dataset: string }, listener: any) {\r\n    try {\r\n      if (this.datasets[config.dataset].filterListeners) {\r\n        this.datasets[config.dataset].filterListeners.delete(listener)\r\n      }\r\n    } catch (e) {\r\n      // doesn't matter\r\n    }\r\n  }\r\n\r\n  public clearCache() {\r\n    this.kill() // any stragglers must die\r\n    this.datasets = {}\r\n    this.networks = {}\r\n  }\r\n\r\n  // ---- PRIVATE STUFFS -----------------------\r\n\r\n  private async _updateFilters(datasetId: string) {\r\n    console.log('> updateFilters ', datasetId)\r\n    const metaData = this.datasets[datasetId]\r\n    console.log({ metaData })\r\n\r\n    if (!Object.keys(metaData.activeFilters).length) {\r\n      console.log('no keys')\r\n      metaData.filteredRows = null\r\n      this._notifyListeners(datasetId)\r\n      return\r\n    }\r\n\r\n    // Let's do this the stupid way first, and make it better once we get it working.\r\n    const dataset = await metaData.dataset\r\n    const allColumns = Object.keys(dataset)\r\n    let filteredRows: any[] = []\r\n\r\n    const numberOfRowsInFullDataset = dataset[allColumns[0]].values.length\r\n    console.log('FILTERS:', metaData.activeFilters)\r\n    console.log('TOTLROWS', numberOfRowsInFullDataset)\r\n\r\n    // we will go thru each filter for this dataset and set the elements\r\n    // to false whenever a row fails a filter.\r\n    // This implements \"AND\" logic.\r\n    const hasMatchedFilters = new Array(numberOfRowsInFullDataset).fill(true)\r\n\r\n    const ltgt = /^(<|>)/ // starts with < or >\r\n    //            (╯° °)╯︵ ┻━┻\r\n\r\n    for (const [column, spec] of Object.entries(metaData.activeFilters)) {\r\n      const dataColumn = dataset[column]\r\n      if (spec.values[0] === undefined || spec.values[0] === '') {\r\n        globalStore.commit('error', datasetId + ': filter error')\r\n      }\r\n\r\n      // prep LT/GT\r\n      if (ltgt.test(spec.values[0])) {\r\n        if (spec.values[0].startsWith('<=')) {\r\n          spec.conditional = '<='\r\n          spec.values[0] = spec.values[0].substring(2).trim()\r\n        } else if (spec.values[0].startsWith('>=')) {\r\n          spec.conditional = '>='\r\n          spec.values[0] = spec.values[0].substring(2).trim()\r\n        } else if (spec.values[0].startsWith('<')) {\r\n          spec.conditional = '<'\r\n          spec.values[0] = spec.values[0].substring(1).trim()\r\n        } else if (spec.values[0].startsWith('>')) {\r\n          spec.conditional = '>'\r\n          spec.values[0] = spec.values[0].substring(1).trim()\r\n        }\r\n      } else {\r\n        // handle case where we are testing equal/inequal and its a \"numeric\" string\r\n        if (spec.values.length === 1 && typeof spec.values[0] === 'string') {\r\n          const numericString = parseFloat(spec.values[0])\r\n          if (Number.isFinite(numericString)) spec.values.push(numericString)\r\n        }\r\n      }\r\n\r\n      // test every row: falsify if it fails the test.\r\n      for (let i = 0; i < numberOfRowsInFullDataset; i++) {\r\n        if (!checkFilterValue(spec, dataColumn.values[i])) {\r\n          hasMatchedFilters[i] = false\r\n        }\r\n      }\r\n    }\r\n\r\n    // Build the final filtered dataset based on hasMatchedFilters\r\n    for (let i = 0; i < numberOfRowsInFullDataset; i++) {\r\n      if (hasMatchedFilters[i]) {\r\n        const row = {} as any\r\n        allColumns.forEach(col => (row[col] = dataset[col].values[i]))\r\n        filteredRows.push(row)\r\n      }\r\n    }\r\n\r\n    // For now let's leave the filtered rows as an array of data objects\r\n\r\n    // // CONVERT array of objects to column-based DataTableColumns\r\n    // const filteredDataTable: { [id: string]: DataTableColumn } = {}\r\n    // allColumns.forEach(columnId => {\r\n    //   const column = { name: columnId, values: [], type: DataType.UNKNOWN } as any\r\n    //   for (const row of filteredRows) column.values.push(row[columnId])\r\n    //   filteredDataTable[columnId] = column\r\n    // })\r\n\r\n    // metaData.filteredRows = filteredDataTable as any\r\n\r\n    metaData.filteredRows = filteredRows\r\n    this._notifyListeners(datasetId)\r\n  }\r\n\r\n  // private _checkFilterValue(\r\n  //   spec: { conditional: string; invert: boolean; values: any[] },\r\n  //   elementValue: any\r\n  // ) {\r\n  //   // lookup closure functions for < > <= >=\r\n  //   const conditionals: any = {\r\n  //     '<': () => {\r\n  //       return elementValue < spec.values[0]\r\n  //     },\r\n  //     '<=': () => {\r\n  //       return elementValue <= spec.values[0]\r\n  //     },\r\n  //     '>': () => {\r\n  //       return elementValue > spec.values[0]\r\n  //     },\r\n  //     '>=': () => {\r\n  //       return elementValue >= spec.values[0]\r\n  //     },\r\n  //   }\r\n\r\n  //   let isValueInFilterSpec: boolean\r\n\r\n  //   if (spec.conditional) {\r\n  //     isValueInFilterSpec = conditionals[spec.conditional]()\r\n  //   } else {\r\n  //     isValueInFilterSpec = spec.values.includes(elementValue)\r\n  //   }\r\n\r\n  //   if (spec.invert) return !isValueInFilterSpec\r\n  //   return isValueInFilterSpec\r\n  // }\r\n\r\n  private _notifyListeners(datasetId: string) {\r\n    const dataset = this.datasets[datasetId]\r\n    for (const notifyListener of dataset.filterListeners) {\r\n      notifyListener(datasetId)\r\n    }\r\n  }\r\n\r\n  private async _fetchDataset(config: { dataset: string }, options?: { highPrecision: boolean }) {\r\n    if (!this.files.length) {\r\n      const { files } = await new HTTPFileSystem(this.fileApi).getDirectory(this.subfolder)\r\n      this.files = files\r\n    }\r\n\r\n    return new Promise<DataTable>((resolve, reject) => {\r\n      const thread = new DataFetcherWorker()\r\n      this.threads.push(thread)\r\n      // console.log('NEW WORKER', thread)\r\n      try {\r\n        thread.postMessage({\r\n          fileSystemConfig: this.fileApi,\r\n          subfolder: this.subfolder,\r\n          files: this.files,\r\n          config: config,\r\n          options,\r\n        })\r\n\r\n        thread.onmessage = e => {\r\n          thread.terminate()\r\n          if (e.data.error) {\r\n            let msg = '' + e.data.error\r\n            msg = msg.replace('[object Response]', 'Error loading file')\r\n\r\n            if (config?.dataset && msg.indexOf(config.dataset) === -1) msg += `: ${config.dataset}`\r\n\r\n            globalStore.commit('setStatus', {\r\n              type: Status.ERROR,\r\n              msg,\r\n              desc: JSON.stringify(config),\r\n            })\r\n            reject()\r\n          }\r\n          resolve(e.data)\r\n        }\r\n      } catch (err) {\r\n        thread.terminate()\r\n        console.error(err)\r\n        reject(err)\r\n      }\r\n    })\r\n  }\r\n\r\n  private async _fetchNetwork(props: {\r\n    subfolder: string\r\n    filename: string\r\n    vizDetails: any\r\n    cbStatus?: any\r\n  }) {\r\n    return new Promise<NetworkLinks>(async (resolve, reject) => {\r\n      const { subfolder, filename, vizDetails, cbStatus } = props\r\n\r\n      const path = `/${subfolder}/${filename}`\r\n      console.log('load network:', path)\r\n\r\n      // get folder\r\n      let folder =\r\n        path.indexOf('/') > -1 ? path.substring(0, path.lastIndexOf('/')) : this.subfolder\r\n\r\n      // get file path search pattern\r\n      const { files } = await new HTTPFileSystem(this.fileApi).getDirectory(folder)\r\n      let pattern = path.indexOf('/') === -1 ? path : path.substring(path.lastIndexOf('/') + 1)\r\n      const match = findMatchingGlobInFiles(files, pattern)\r\n\r\n      if (match.length !== 1) reject('File not found: ' + path)\r\n\r\n      const thread = new RoadNetworkLoader() as any\r\n      try {\r\n        thread.onmessage = (e: MessageEvent) => {\r\n          // perhaps network has no CRS and we need to ask user\r\n          if (e.data.promptUserForCRS) {\r\n            let crs =\r\n              prompt('Enter the coordinate reference system, e.g. EPSG:25832') || 'EPSG:31468'\r\n            if (Number.isInteger(parseInt(crs))) crs = `EPSG:${crs}`\r\n\r\n            thread.postMessage({ crs })\r\n            return\r\n          }\r\n\r\n          // notify client of status update messages\r\n          if (e.data.status) {\r\n            if (cbStatus) cbStatus(e.data.status)\r\n            return\r\n          }\r\n\r\n          // normal exit\r\n          thread.terminate()\r\n\r\n          if (e.data.error) {\r\n            console.error(e.data.error)\r\n            reject(e.data.error)\r\n          }\r\n\r\n          resolve(e.data.links)\r\n        }\r\n\r\n        thread.postMessage({\r\n          filePath: path,\r\n          fileSystem: this.fileApi,\r\n          vizDetails,\r\n          isFirefox, // we need this for now, because Firefox bug #260\r\n        })\r\n      } catch (err) {\r\n        thread.terminate()\r\n        console.error(err)\r\n        reject(err)\r\n      }\r\n    })\r\n  }\r\n\r\n  private _getFileSystem(name: string) {\r\n    const svnProject: FileSystemConfig[] = globalStore.state.svnProjects.filter(\r\n      (a: FileSystemConfig) => a.slug === name\r\n    )\r\n    if (svnProject.length === 0) {\r\n      console.error('DDM: no such project')\r\n      throw Error\r\n    }\r\n    return svnProject[0]\r\n  }\r\n\r\n  private datasets: {\r\n    [id: string]: {\r\n      dataset: Promise<DataTable>\r\n      filteredRows: any[] | null\r\n      activeFilters: { [column: string]: any }\r\n      filterListeners: Set<any>\r\n    }\r\n  } = {}\r\n}\r\n\r\nexport function checkFilterValue(\r\n  spec: { conditional: string; invert: boolean; values: any[]; range?: boolean },\r\n  elementValue: any\r\n) {\r\n  // lookup closure functions for < > <= >=\r\n  const conditionals: any = {\r\n    '<': () => {\r\n      return elementValue < spec.values[0]\r\n    },\r\n    '<=': () => {\r\n      return elementValue <= spec.values[0]\r\n    },\r\n    '>': () => {\r\n      return elementValue > spec.values[0]\r\n    },\r\n    '>=': () => {\r\n      return elementValue >= spec.values[0]\r\n    },\r\n  }\r\n\r\n  let isValueInFilterSpec: boolean\r\n\r\n  if (spec.range) {\r\n    isValueInFilterSpec = elementValue >= spec.values[0] && elementValue <= spec.values[1]\r\n  } else if (spec.conditional) {\r\n    isValueInFilterSpec = conditionals[spec.conditional]()\r\n  } else {\r\n    isValueInFilterSpec = spec.values.includes(elementValue)\r\n  }\r\n\r\n  if (spec.invert) return !isValueInFilterSpec\r\n  return isValueInFilterSpec\r\n}\r\n"],"names":["identity","x","group","values","keys","nest","rollup","reduce","map","regroup","values2","i","length","groups","InternMap","keyof","index","value","key","group2","get","push","set","values3","isFirefox","window","showDirectoryPicker","DashboardDataManager","constructor","args","__publicField","this","root","subfolder","fileApi","_getFileSystem","kill","worker","threads","terminate","getFilteredDataset","config","dataset","datasets","filteredRows","OLDgetFiltered","rows","bars","groupBy","columnValues","columnGroups","v","a","b","d","Array","from","y","getDataset","options","console","log","_fetchDataset","activeFilters","filterListeners","Set","myDataset","allRows","__spreadValues","ignoreColumns","forEach","column","useLastRow","Object","colName","e","setFeatureProperties","fullpath","featureProperties","substring","lastIndexOf","fullConfig","assign","Promise","resolve","reject","thread","DataFetcherWorker","postMessage","onmessage","data","error","globalStore","commit","type","Status","ERROR","msg","desc","err","setPreloadedDataset","props","dataTable","getRoadNetwork","filename","vizDetails","cbStatus","path","networks","_fetchNetwork","setFilter","filter","invert","range","warn","isArray","allFilters","_updateFilters","addFilterListener","listener","Error","add","removeFilterListener","delete","clearCache","datasetId","metaData","_notifyListeners","allColumns","numberOfRowsInFullDataset","hasMatchedFilters","fill","ltgt","spec","entries","dataColumn","test","startsWith","conditional","trim","numericString","parseFloat","Number","isFinite","checkFilterValue","row","col","notifyListener","files","HTTPFileSystem","getDirectory","fileSystemConfig","replace","indexOf","JSON","stringify","async","folder","pattern","findMatchingGlobInFiles","RoadNetworkLoader","promptUserForCRS","crs","prompt","isInteger","parseInt","status","links","filePath","fileSystem","name","svnProject","state","svnProjects","slug","elementValue","conditionals","isValueInFilterSpec","includes"],"mappings":"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"}