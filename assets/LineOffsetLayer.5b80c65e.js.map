{"version":3,"file":"LineOffsetLayer.5b80c65e.js","sources":["../../src/layers/LineOffsetLayer.ts","../../src/layers/line-offset-shader-full.vert?raw"],"sourcesContent":["import { LineLayer } from '@deck.gl/layers'\r\n\r\nimport globalStore from '@/store'\r\nimport SHADER_VERTEX_FULL from './line-offset-shader-full.vert?raw'\r\n\r\nexport const OFFSET_DIRECTION = {\r\n  NONE: 0,\r\n  LEFT: 1,\r\n  RIGHT: -1,\r\n}\r\n\r\nexport class LineOffsetLayer extends LineLayer {\r\n  initializeState(context: any) {\r\n    super.initializeState(context)\r\n  }\r\n\r\n  getShaders() {\r\n    return {\r\n      ...super.getShaders(),\r\n      vs: SHADER_VERTEX_FULL,\r\n    }\r\n  }\r\n\r\n  draw({ uniforms }: any) {\r\n    const { offsetDirection } = this.props\r\n\r\n    const combinedUniforms = {\r\n      ...uniforms,\r\n      offsetDirection,\r\n      bearing: (globalStore.state.viewState.bearing * Math.PI) / 180.0,\r\n    }\r\n\r\n    super.draw({\r\n      uniforms: combinedUniforms,\r\n    })\r\n  }\r\n}\r\n\r\nLineOffsetLayer.layerName = 'LineOffsetLayer'\r\nLineOffsetLayer.defaultProps = {\r\n  bearing: 0,\r\n  offsetDirection: OFFSET_DIRECTION.RIGHT,\r\n}\r\n","export default \"#define SHADER_NAME line-layer-vertex-shader\\r\\n\\r\\nattribute vec3 positions;\\r\\nattribute vec3 instanceSourcePositions;\\r\\nattribute vec3 instanceTargetPositions;\\r\\nattribute vec3 instanceSourcePositions64Low;\\r\\nattribute vec3 instanceTargetPositions64Low;\\r\\nattribute vec4 instanceColors;\\r\\nattribute vec3 instancePickingColors;\\r\\nattribute float instanceWidths;\\r\\n\\r\\nuniform float opacity;\\r\\nuniform float widthScale;\\r\\nuniform float widthMinPixels;\\r\\nuniform float widthMaxPixels;\\r\\nuniform float useShortestPath;\\r\\nuniform int widthUnits;\\r\\n\\r\\nuniform float offsetDirection;\\r\\nuniform float bearing;\\r\\n\\r\\nvarying vec4 vColor;\\r\\nvarying vec2 uv;\\r\\n\\r\\n// offset vector by strokeWidth pixels\\r\\n// offset_direction is -1 (left) or 1 (right)\\r\\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\\r\\n  // normalized direction of the line\\r\\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\\r\\n  // rotate by 90 degrees\\r\\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\\r\\n\\r\\n  return dir_screenspace * offset_direction * width / 2.0;\\r\\n}\\r\\n\\r\\nvec3 splitLine(vec3 a, vec3 b, float x) {\\r\\n  float t = (x - a.x) / (b.x - a.x);\\r\\n  return vec3(x, mix(a.yz, b.yz, t));\\r\\n}\\r\\n\\r\\nvoid drivingSideOffset(inout vec3 size, float widthPixels) {\\r\\n\\r\\n    // a -> b\\r\\n    vec3 link = geometry.worldPositionAlt.xyz - geometry.worldPosition.xyz;\\r\\n\\r\\n    // normalized direction of the line\\r\\n    vec2 direction = normalize(link.xy * project_uViewportSize);\\r\\n\\r\\n    // rotate by map bearing\\r\\n    vec2 rotation;\\r\\n    rotation.x = direction.x * cos(bearing) + direction.y * -sin(bearing);\\r\\n    rotation.y = direction.x * sin(bearing) + direction.y *  cos(bearing);\\r\\n\\r\\n    // rotate by 90 degrees to get offset direction\\r\\n    rotation = vec2(-rotation.y, rotation.x);\\r\\n\\r\\n    // offset the coordinates\\r\\n    vec2 offset = rotation * offsetDirection * widthPixels / 2.0;\\r\\n\\r\\n    size.x += offset.x;\\r\\n    size.y += offset.y;\\r\\n}\\r\\n\\r\\nvoid main(void) {\\r\\n  geometry.worldPosition = instanceSourcePositions;\\r\\n  geometry.worldPositionAlt = instanceTargetPositions;\\r\\n\\r\\n  vec3 source_world = instanceSourcePositions;\\r\\n  vec3 target_world = instanceTargetPositions;\\r\\n  vec3 source_world_64low = instanceSourcePositions64Low;\\r\\n  vec3 target_world_64low = instanceTargetPositions64Low;\\r\\n\\r\\n  if (useShortestPath > 0.5 || useShortestPath < -0.5) {\\r\\n    source_world.x = mod(source_world.x + 180., 360.0) - 180.;\\r\\n    target_world.x = mod(target_world.x + 180., 360.0) - 180.;\\r\\n    float deltaLng = target_world.x - source_world.x;\\r\\n\\r\\n    if (deltaLng * useShortestPath > 180.) {\\r\\n      source_world.x += 360. * useShortestPath;\\r\\n      source_world = splitLine(source_world, target_world, 180. * useShortestPath);\\r\\n      source_world_64low = vec3(0.0);\\r\\n    } else if (deltaLng * useShortestPath < -180.) {\\r\\n      target_world.x += 360. * useShortestPath;\\r\\n      target_world = splitLine(source_world, target_world, 180. * useShortestPath);\\r\\n      target_world_64low = vec3(0.0);\\r\\n    } else if (useShortestPath < 0.) {\\r\\n      // Line is not split, abort\\r\\n      gl_Position = vec4(0.);\\r\\n      return;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // Position\\r\\n  vec4 source_commonspace;\\r\\n  vec4 target_commonspace;\\r\\n  vec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);\\r\\n  vec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);\\r\\n\\r\\n  // linear interpolation of source & target to pick right coord\\r\\n  float segmentIndex = positions.x;\\r\\n  vec4 p = mix(source, target, segmentIndex);\\r\\n  geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);\\r\\n  uv = positions.xy;\\r\\n  geometry.uv = uv;\\r\\n  geometry.pickingColor = instancePickingColors;\\r\\n\\r\\n  // Multiply out width and clamp to limits\\r\\n  float widthPixels = clamp(\\r\\n    project_size_to_pixel(instanceWidths * widthScale, widthUnits),\\r\\n    widthMinPixels, widthMaxPixels\\r\\n  );\\r\\n\\r\\n  // extrude\\r\\n  vec3 offset = vec3(\\r\\n    getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),\\r\\n    0.0);\\r\\n\\r\\n  drivingSideOffset(offset, 1.0 + widthPixels);\\r\\n\\r\\n  DECKGL_FILTER_SIZE(offset, geometry);\\r\\n  gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\\r\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\r\\n\\r\\n  // Color\\r\\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\\r\\n  DECKGL_FILTER_COLOR(vColor, geometry);\\r\\n}\\r\\n\""],"names":["OFFSET_DIRECTION","NONE","LEFT","RIGHT","LineOffsetLayer","LineLayer","initializeState","context","super","getShaders","__spreadProps","__spreadValues","vs","draw","uniforms","offsetDirection","this","props","combinedUniforms","bearing","globalStore","state","viewState","Math","PI","layerName","defaultProps"],"mappings":"kfAKO,MAAMA,EAAmB,CAC9BC,KAAM,EACNC,KAAM,EACNC,OAAO,GAGF,MAAAC,UAA8BC,EACnCC,gBAAgBC,GACdC,MAAMF,gBAAgBC,GAGxBE,aACS,OAAAC,EAAAC,EAAA,GACFH,MAAMC,cADJ,CAELG,GCnBS,oiJDuBbC,MAAKC,SAAEA,IACC,MAAAC,gBAAEA,GAAoBC,KAAKC,MAE3BC,EAAmBR,OACpBI,GADoB,CAEvBC,gBAAAA,EACAI,QAAUC,EAAYC,MAAMC,UAAUH,QAAUI,KAAKC,GAAM,MAG7DhB,MAAMK,KAAK,CACTC,SAAUI,KAKhBd,EAAgBqB,UAAY,kBAC5BrB,EAAgBsB,aAAe,CAC7BP,QAAS,EACTJ,gBAAiBf,EAAiBG"}