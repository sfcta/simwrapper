{"version":3,"file":"index.0d83a8f9.js","sources":["../../node_modules/crossfilter2/src/array.js","../../node_modules/crossfilter2/src/filter.js","../../node_modules/crossfilter2/src/identity.js","../../node_modules/crossfilter2/src/null.js","../../node_modules/crossfilter2/src/zero.js","../../node_modules/crossfilter2/src/heap.js","../../node_modules/crossfilter2/src/heapselect.js","../../node_modules/crossfilter2/src/bisect.js","../../node_modules/crossfilter2/src/permute.js","../../node_modules/crossfilter2/src/reduce.js","../../node_modules/crossfilter2/src/result.js","../../node_modules/@ranfdev/deepobj/dist/deepobj.m.js","../../node_modules/crossfilter2/src/index.js"],"sourcesContent":["let array8 = arrayUntyped,\n    array16 = arrayUntyped,\n    array32 = arrayUntyped,\n    arrayLengthen = arrayLengthenUntyped,\n    arrayWiden = arrayWidenUntyped;\nif (typeof Uint8Array !== \"undefined\") {\n  array8 = function(n) { return new Uint8Array(n); };\n  array16 = function(n) { return new Uint16Array(n); };\n  array32 = function(n) { return new Uint32Array(n); };\n\n  arrayLengthen = function(array, length) {\n    if (array.length >= length) return array;\n    var copy = new array.constructor(length);\n    copy.set(array);\n    return copy;\n  };\n\n  arrayWiden = function(array, width) {\n    var copy;\n    switch (width) {\n      case 16: copy = array16(array.length); break;\n      case 32: copy = array32(array.length); break;\n      default: throw new Error(\"invalid array width!\");\n    }\n    copy.set(array);\n    return copy;\n  };\n}\n\nfunction arrayUntyped(n) {\n  var array = new Array(n), i = -1;\n  while (++i < n) array[i] = 0;\n  return array;\n}\n\nfunction arrayLengthenUntyped(array, length) {\n  var n = array.length;\n  while (n < length) array[n++] = 0;\n  return array;\n}\n\nfunction arrayWidenUntyped(array, width) {\n  if (width > 32) throw new Error(\"invalid array width!\");\n  return array;\n}\n\n// An arbitrarily-wide array of bitmasks\nfunction bitarray(n) {\n  this.length = n;\n  this.subarrays = 1;\n  this.width = 8;\n  this.masks = {\n    0: 0\n  }\n\n  this[0] = array8(n);\n}\n\nbitarray.prototype.lengthen = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    this[i] = arrayLengthen(this[i], n);\n  }\n  this.length = n;\n};\n\n// Reserve a new bit index in the array, returns {offset, one}\nbitarray.prototype.add = function() {\n  var m, w, one, i, len;\n\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    m = this.masks[i];\n    w = this.width - (32 * i);\n    // isolate the rightmost zero bit and return it as an unsigned int of 32 bits, if NaN or -1, return a 0 \n    one = (~m & (m + 1)) >>> 0;\n\n    if (w >= 32 && !one) {\n      continue;\n    }\n\n    if (w < 32 && (one & (1 << w))) {\n      // widen this subarray\n      this[i] = arrayWiden(this[i], w <<= 1);\n      this.width = 32 * i + w;\n    }\n\n    this.masks[i] |= one;\n\n    return {\n      offset: i,\n      one: one\n    };\n  }\n\n  // add a new subarray\n  this[this.subarrays] = array8(this.length);\n  this.masks[this.subarrays] = 1;\n  this.width += 8;\n  return {\n    offset: this.subarrays++,\n    one: 1\n  };\n};\n\n// Copy record from index src to index dest\nbitarray.prototype.copy = function(dest, src) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    this[i][dest] = this[i][src];\n  }\n};\n\n// Truncate the array to the given length\nbitarray.prototype.truncate = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    for (var j = this.length - 1; j >= n; j--) {\n      this[i][j] = 0;\n    }\n  }\n  this.length = n;\n};\n\n// Checks that all bits for the given index are 0\nbitarray.prototype.zero = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that all bits for the given index are 0 except for possibly one\nbitarray.prototype.zeroExcept = function(n, offset, zero) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (i === offset ? this[i][n] & zero : this[i][n]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that all bits for the given index are 0 except for the specified mask.\n// The mask should be an array of the same size as the filter subarrays width.\nbitarray.prototype.zeroExceptMask = function(n, mask) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n] & mask[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Checks that only the specified bit is set for the given index\nbitarray.prototype.only = function(n, offset, one) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n] != (i === offset ? one : 0)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that only the specified bit is set for the given index except for possibly one other\nbitarray.prototype.onlyExcept = function(n, offset, zero, onlyOffset, onlyOne) {\n  var mask;\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    mask = this[i][n];\n    if (i === offset)\n      mask = (mask & zero) >>> 0;\n    if (mask != (i === onlyOffset ? onlyOne : 0)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport default {\n  array8: arrayUntyped,\n  array16: arrayUntyped,\n  array32: arrayUntyped,\n  arrayLengthen: arrayLengthenUntyped,\n  arrayWiden: arrayWidenUntyped,\n  bitarray: bitarray\n};\n","const filterExact = (bisect, value) => {\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, value, 0, n), bisect.right(values, value, 0, n)];\n  };\n}\n\nconst filterRange = (bisect, range) => {\n  var min = range[0],\n      max = range[1];\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, min, 0, n), bisect.left(values, max, 0, n)];\n  };\n}\n\nconst filterAll = values => {\n  return [0, values.length];\n}\n\nexport default {\n  filterExact,\n  filterRange,\n  filterAll\n};\n","export default d => {\n  return d;\n};\n","export default () =>  {\n  return null;\n}\n","export default () => {\n  return 0;\n}\n","import identity from './identity';\n\nfunction heap_by(f) {\n\n  // Builds a binary heap within the specified array a[lo:hi]. The heap has the\n  // property such that the parent a[lo+i] is always less than or equal to its\n  // two children: a[lo+2*i+1] and a[lo+2*i+2].\n  function heap(a, lo, hi) {\n    var n = hi - lo,\n        i = (n >>> 1) + 1;\n    while (--i > 0) sift(a, i, n, lo);\n    return a;\n  }\n\n  // Sorts the specified array a[lo:hi] in descending order, assuming it is\n  // already a heap.\n  function sort(a, lo, hi) {\n    var n = hi - lo,\n        t;\n    while (--n > 0) t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);\n    return a;\n  }\n\n  // Sifts the element a[lo+i-1] down the heap, where the heap is the contiguous\n  // slice of array a[lo:lo+n]. This method can also be used to update the heap\n  // incrementally, without incurring the full cost of reconstructing the heap.\n  function sift(a, i, n, lo) {\n    var d = a[--lo + i],\n        x = f(d),\n        child;\n    while ((child = i << 1) <= n) {\n      if (child < n && f(a[lo + child]) > f(a[lo + child + 1])) child++;\n      if (x <= f(a[lo + child])) break;\n      a[lo + i] = a[lo + child];\n      i = child;\n    }\n    a[lo + i] = d;\n  }\n\n  heap.sort = sort;\n  return heap;\n}\n\nconst h = heap_by(identity);\nh.by = heap_by;\n\nexport default h;\n","import identity from './identity';\nimport xFilterHeap from './heap';\n\nfunction heapselect_by(f) {\n  var heap = xFilterHeap.by(f);\n\n  // Returns a new array containing the top k elements in the array a[lo:hi].\n  // The returned array is not sorted, but maintains the heap property. If k is\n  // greater than hi - lo, then fewer than k elements will be returned. The\n  // order of elements in a is unchanged by this operation.\n  function heapselect(a, lo, hi, k) {\n    var queue = new Array(k = Math.min(hi - lo, k)),\n        min,\n        i,\n        d;\n\n    for (i = 0; i < k; ++i) queue[i] = a[lo++];\n    heap(queue, 0, k);\n\n    if (lo < hi) {\n      min = f(queue[0]);\n      do {\n        if (f(d = a[lo]) > min) {\n          queue[0] = d;\n          min = f(heap(queue, 0, k)[0]);\n        }\n      } while (++lo < hi);\n    }\n\n    return queue;\n  }\n\n  return heapselect;\n}\n\n\nconst h = heapselect_by(identity);\nh.by = heapselect_by; // assign the raw function to the export as well\n\nexport default h;\n","import identity from './identity';\n\nfunction bisect_by(f) {\n\n  // Locate the insertion point for x in a to maintain sorted order. The\n  // arguments lo and hi may be used to specify a subset of the array which\n  // should be considered; by default the entire array is used. If x is already\n  // present in a, the insertion point will be before (to the left of) any\n  // existing entries. The return value is suitable for use as the first\n  // argument to `array.splice` assuming that a is already sorted.\n  //\n  // The returned insertion point i partitions the array a into two halves so\n  // that all v < x for v in a[lo:i] for the left side and all v >= x for v in\n  // a[i:hi] for the right side.\n  function bisectLeft(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (f(a[mid]) < x) lo = mid + 1;\n      else hi = mid;\n    }\n    return lo;\n  }\n\n  // Similar to bisectLeft, but returns an insertion point which comes after (to\n  // the right of) any existing entries of x in a.\n  //\n  // The returned insertion point i partitions the array into two halves so that\n  // all v <= x for v in a[lo:i] for the left side and all v > x for v in\n  // a[i:hi] for the right side.\n  function bisectRight(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (x < f(a[mid])) hi = mid;\n      else lo = mid + 1;\n    }\n    return lo;\n  }\n\n  bisectRight.right = bisectRight;\n  bisectRight.left = bisectLeft;\n  return bisectRight;\n}\n\nconst bisect = bisect_by(identity);\nbisect.by = bisect_by; // assign the raw function to the export as well\n\nexport default bisect;\n\n","export default (array, index, deep) => {\n  for (var i = 0, n = index.length, copy = deep ? JSON.parse(JSON.stringify(array)) : new Array(n); i < n; ++i) {\n    copy[i] = array[index[i]];\n  }\n  return copy;\n}\n","const reduceIncrement = p => {\n  return p + 1;\n}\n\nconst reduceDecrement = p => {\n  return p - 1;\n}\n\nconst reduceAdd = f => {\n  return function(p, v) {\n    return p + +f(v);\n  };\n}\n\nconst reduceSubtract = f => {\n  return function(p, v) {\n    return p - f(v);\n  };\n}\n\nexport default {\n  reduceIncrement,\n  reduceDecrement,\n  reduceAdd,\n  reduceSubtract\n};\n","import deep from \"@ranfdev/deepobj\"\n// Note(cg): result was previsouly using lodash.result, not ESM compatible.\n \nconst get = (obj, prop) => {\n  const value = obj[prop];\n  return (typeof value === 'function') ? value.call(obj) : value;\n}\n\n/**\n * get value of object at a deep path.\n * if the resolved value is a function,\n * it's invoked with the `this` binding of \n * its parent object and its result is returned. \n *  \n * @param  {Object} obj  the object (e.g. { 'a': [{ 'b': { 'c1': 3, 'c2': 4} }], 'd': {e:1} }; )\n * @param  {String} path deep path (e.g. `d.e`` or `a[0].b.c1`. Dot notation (a.0.b)is also supported)\n * @return {Any}      the resolved value\n */\nconst reg = /\\[([\\w\\d]+)\\]/g;\nexport default (obj, path) => {\n  return deep(get, obj, path.replace(reg, '.$1'))\n}\n","export default function(t,e,i,n,r){for(r in n=(i=i.split(\".\")).splice(-1,1),i)e=e[i[r]]=e[i[r]]||{};return t(e,n)};\n//# sourceMappingURL=deepobj.m.js.map\n","import xfilterArray from './array';\nimport xfilterFilter from './filter';\nimport cr_identity from './identity';\nimport cr_null from './null';\nimport cr_zero from './zero';\nimport xfilterHeapselect from './heapselect';\nimport xfilterHeap from './heap';\nimport bisect from './bisect';\nimport permute from './permute';\nimport xfilterReduce from './reduce';\nimport result from './result';\n\n// constants\nvar REMOVED_INDEX = -1;\n\ncrossfilter.heap = xfilterHeap;\ncrossfilter.heapselect = xfilterHeapselect;\ncrossfilter.bisect = bisect;\ncrossfilter.permute = permute;\nexport default crossfilter;\n\nfunction crossfilter() {\n  var crossfilter = {\n    add: add,\n    remove: removeData,\n    dimension: dimension,\n    groupAll: groupAll,\n    size: size,\n    all: all,\n    allFiltered: allFiltered,\n    onChange: onChange,\n    isElementFiltered: isElementFiltered\n  };\n\n  var data = [], // the records\n      n = 0, // the number of records; data.length\n      filters, // 1 is filtered out\n      filterListeners = [], // when the filters change\n      dataListeners = [], // when data is added\n      removeDataListeners = [], // when data is removed\n      callbacks = [];\n\n  filters = new xfilterArray.bitarray(0);\n\n  // Adds the specified new records to this crossfilter.\n  function add(newData) {\n    var n0 = n,\n        n1 = newData.length;\n\n    // If there's actually new data to add…\n    // Merge the new data into the existing data.\n    // Lengthen the filter bitset to handle the new records.\n    // Notify listeners (dimensions and groups) that new data is available.\n    if (n1) {\n      data = data.concat(newData);\n      filters.lengthen(n += n1);\n      dataListeners.forEach(function(l) { l(newData, n0, n1); });\n      triggerOnChange('dataAdded');\n    }\n\n    return crossfilter;\n  }\n\n  // Removes all records that match the current filters, or if a predicate function is passed,\n  // removes all records matching the predicate (ignoring filters).\n  function removeData(predicate) {\n    var // Mapping from old record indexes to new indexes (after records removed)\n        newIndex = new Array(n),\n        removed = [],\n        usePred = typeof predicate === 'function',\n        shouldRemove = function (i) {\n          return usePred ? predicate(data[i], i) : filters.zero(i)\n        };\n\n    for (var index1 = 0, index2 = 0; index1 < n; ++index1) {\n      if ( shouldRemove(index1) ) {\n        removed.push(index1);\n        newIndex[index1] = REMOVED_INDEX;\n      } else {\n        newIndex[index1] = index2++;\n      }\n    }\n\n    // Remove all matching records from groups.\n    filterListeners.forEach(function(l) { l(-1, -1, [], removed, true); });\n\n    // Update indexes.\n    removeDataListeners.forEach(function(l) { l(newIndex); });\n\n    // Remove old filters and data by overwriting.\n    for (var index3 = 0, index4 = 0; index3 < n; ++index3) {\n      if ( newIndex[index3] !== REMOVED_INDEX ) {\n        if (index3 !== index4) filters.copy(index4, index3), data[index4] = data[index3];\n        ++index4;\n      }\n    }\n\n    data.length = n = index4;\n    filters.truncate(index4);\n    triggerOnChange('dataRemoved');\n  }\n\n  function maskForDimensions(dimensions) {\n    var n,\n        d,\n        len,\n        id,\n        mask = Array(filters.subarrays);\n    for (n = 0; n < filters.subarrays; n++) { mask[n] = ~0; }\n    for (d = 0, len = dimensions.length; d < len; d++) {\n      // The top bits of the ID are the subarray offset and the lower bits are the bit\n      // offset of the \"one\" mask.\n      id = dimensions[d].id();\n      mask[id >> 7] &= ~(0x1 << (id & 0x3f));\n    }\n    return mask;\n  }\n\n  // Return true if the data element at index i is filtered IN.\n  // Optionally, ignore the filters of any dimensions in the ignore_dimensions list.\n  function isElementFiltered(i, ignore_dimensions) {\n    var mask = maskForDimensions(ignore_dimensions || []);\n    return filters.zeroExceptMask(i,mask);\n  }\n\n  // Adds a new dimension with the specified value accessor function.\n  function dimension(value, iterable) {\n\n    if (typeof value === 'string') {\n      var accessorPath = value;\n      value = function(d) { return result(d, accessorPath); };\n    }\n\n    var dimension = {\n      filter: filter,\n      filterExact: filterExact,\n      filterRange: filterRange,\n      filterFunction: filterFunction,\n      filterAll: filterAll,\n      currentFilter: currentFilter,\n      hasCurrentFilter: hasCurrentFilter,\n      top: top,\n      bottom: bottom,\n      group: group,\n      groupAll: groupAll,\n      dispose: dispose,\n      remove: dispose, // for backwards-compatibility\n      accessor: value,\n      id: function() { return id; }\n    };\n\n    var one, // lowest unset bit as mask, e.g., 00001000\n        zero, // inverted one, e.g., 11110111\n        offset, // offset into the filters arrays\n        id, // unique ID for this dimension (reused when dimensions are disposed)\n        values, // sorted, cached array\n        index, // maps sorted value index -> record index (in data)\n        newValues, // temporary array storing newly-added values\n        newIndex, // temporary array storing newly-added index\n        iterablesIndexCount,\n        iterablesIndexFilterStatus,\n        iterablesEmptyRows = [],\n        sortRange = function(n) {\n          return cr_range(n).sort(function(A, B) {\n            var a = newValues[A], b = newValues[B];\n            return a < b ? -1 : a > b ? 1 : A - B;\n          });\n        },\n        refilter = xfilterFilter.filterAll, // for recomputing filter\n        refilterFunction, // the custom filter function in use\n        filterValue, // the value used for filtering (value, array, function or undefined)\n        filterValuePresent, // true if filterValue contains something\n        indexListeners = [], // when data is added\n        dimensionGroups = [],\n        lo0 = 0,\n        hi0 = 0,\n        t = 0,\n        k;\n\n    // Updating a dimension is a two-stage process. First, we must update the\n    // associated filters for the newly-added records. Once all dimensions have\n    // updated their filters, the groups are notified to update.\n    dataListeners.unshift(preAdd);\n    dataListeners.push(postAdd);\n\n    removeDataListeners.push(removeData);\n\n    // Add a new dimension in the filter bitmap and store the offset and bitmask.\n    var tmp = filters.add();\n    offset = tmp.offset;\n    one = tmp.one;\n    zero = ~one;\n\n    // Create a unique ID for the dimension\n    // IDs will be re-used if dimensions are disposed.\n    // For internal use the ID is the subarray offset shifted left 7 bits or'd with the\n    // bit offset of the set bit in the dimension's \"one\" mask.\n    id = (offset << 7) | (Math.log(one) / Math.log(2));\n\n    preAdd(data, 0, n);\n    postAdd(data, 0, n);\n\n    // Incorporates the specified new records into this dimension.\n    // This function is responsible for updating filters, values, and index.\n    function preAdd(newData, n0, n1) {\n      var newIterablesIndexCount,\n          newIterablesIndexFilterStatus;\n\n      if (iterable){\n        // Count all the values\n        t = 0;\n        j = 0;\n        k = [];\n\n        for (var i0 = 0; i0 < newData.length; i0++) {\n          for(j = 0, k = value(newData[i0]); j < k.length; j++) {\n            t++;\n          }\n        }\n\n        newValues = [];\n        newIterablesIndexCount = cr_range(newData.length);\n        newIterablesIndexFilterStatus = cr_index(t,1);\n        var unsortedIndex = cr_range(t);\n\n        for (var l = 0, index1 = 0; index1 < newData.length; index1++) {\n          k = value(newData[index1])\n          //\n          if(!k.length){\n            newIterablesIndexCount[index1] = 0;\n            iterablesEmptyRows.push(index1 + n0);\n            continue;\n          }\n          newIterablesIndexCount[index1] = k.length\n          for (j = 0; j < k.length; j++) {\n            newValues.push(k[j]);\n            unsortedIndex[l] = index1;\n            l++;\n          }\n        }\n\n        // Create the Sort map used to sort both the values and the valueToData indices\n        var sortMap = sortRange(t);\n\n        // Use the sortMap to sort the newValues\n        newValues = permute(newValues, sortMap);\n\n\n        // Use the sortMap to sort the unsortedIndex map\n        // newIndex should be a map of sortedValue -> crossfilterData\n        newIndex = permute(unsortedIndex, sortMap)\n\n      } else{\n        // Permute new values into natural order using a standard sorted index.\n        newValues = newData.map(value);\n        newIndex = sortRange(n1);\n        newValues = permute(newValues, newIndex);\n      }\n\n      // Bisect newValues to determine which new records are selected.\n      var bounds = refilter(newValues), lo1 = bounds[0], hi1 = bounds[1];\n\n      var index2, index3, index4;\n      if(iterable) {\n        n1 = t;\n        if (refilterFunction) {\n          for (index2 = 0; index2 < n1; ++index2) {\n            if (!refilterFunction(newValues[index2], index2)) {\n              if(--newIterablesIndexCount[newIndex[index2]] === 0) {\n                filters[offset][newIndex[index2] + n0] |= one;\n              }\n              newIterablesIndexFilterStatus[index2] = 1;\n            }\n          }\n        } else {\n          for (index3 = 0; index3 < lo1; ++index3) {\n            if(--newIterablesIndexCount[newIndex[index3]] === 0) {\n              filters[offset][newIndex[index3] + n0] |= one;\n            }\n            newIterablesIndexFilterStatus[index3] = 1;\n          }\n          for (index4 = hi1; index4 < n1; ++index4) {\n            if(--newIterablesIndexCount[newIndex[index4]] === 0) {\n              filters[offset][newIndex[index4] + n0] |= one;\n            }\n            newIterablesIndexFilterStatus[index4] = 1;\n          }\n        }\n      } else {\n        if (refilterFunction) {\n          for (index2 = 0; index2 < n1; ++index2) {\n            if (!refilterFunction(newValues[index2], index2)) {\n              filters[offset][newIndex[index2] + n0] |= one;\n            }\n          }\n        } else {\n          for (index3 = 0; index3 < lo1; ++index3) {\n            filters[offset][newIndex[index3] + n0] |= one;\n          }\n          for (index4 = hi1; index4 < n1; ++index4) {\n            filters[offset][newIndex[index4] + n0] |= one;\n          }\n        }\n      }\n\n      // If this dimension previously had no data, then we don't need to do the\n      // more expensive merge operation; use the new values and index as-is.\n      if (!n0) {\n        values = newValues;\n        index = newIndex;\n        iterablesIndexCount = newIterablesIndexCount;\n        iterablesIndexFilterStatus = newIterablesIndexFilterStatus;\n        lo0 = lo1;\n        hi0 = hi1;\n        return;\n      }\n\n\n\n      var oldValues = values,\n        oldIndex = index,\n        oldIterablesIndexFilterStatus = iterablesIndexFilterStatus,\n        old_n0,\n        i1 = 0;\n\n      i0 = 0;\n\n      if(iterable){\n        old_n0 = n0\n        n0 = oldValues.length;\n        n1 = t\n      }\n\n      // Otherwise, create new arrays into which to merge new and old.\n      values = iterable ? new Array(n0 + n1) : new Array(n);\n      index = iterable ? new Array(n0 + n1) : cr_index(n, n);\n      if(iterable) iterablesIndexFilterStatus = cr_index(n0 + n1, 1);\n\n      // Concatenate the newIterablesIndexCount onto the old one.\n      if(iterable) {\n        var oldiiclength = iterablesIndexCount.length;\n        iterablesIndexCount = xfilterArray.arrayLengthen(iterablesIndexCount, n);\n        for(var j=0; j+oldiiclength < n; j++) {\n          iterablesIndexCount[j+oldiiclength] = newIterablesIndexCount[j];\n        }\n      }\n\n      // Merge the old and new sorted values, and old and new index.\n      var index5 = 0;\n      for (; i0 < n0 && i1 < n1; ++index5) {\n        if (oldValues[i0] < newValues[i1]) {\n          values[index5] = oldValues[i0];\n          if(iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n          index[index5] = oldIndex[i0++];\n        } else {\n          values[index5] = newValues[i1];\n          if(iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n          index[index5] = newIndex[i1++] + (iterable ? old_n0 : n0);\n        }\n      }\n\n      // Add any remaining old values.\n      for (; i0 < n0; ++i0, ++index5) {\n        values[index5] = oldValues[i0];\n        if(iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n        index[index5] = oldIndex[i0];\n      }\n\n      // Add any remaining new values.\n      for (; i1 < n1; ++i1, ++index5) {\n        values[index5] = newValues[i1];\n        if(iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n        index[index5] = newIndex[i1] + (iterable ? old_n0 : n0);\n      }\n\n      // Bisect again to recompute lo0 and hi0.\n      bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // When all filters have updated, notify index listeners of the new values.\n    function postAdd(newData, n0, n1) {\n      indexListeners.forEach(function(l) { l(newValues, newIndex, n0, n1); });\n      newValues = newIndex = null;\n    }\n\n    function removeData(reIndex) {\n      if (iterable) {\n        for (var i0 = 0, i1 = 0; i0 < iterablesEmptyRows.length; i0++) {\n          if (reIndex[iterablesEmptyRows[i0]] !== REMOVED_INDEX) {\n            iterablesEmptyRows[i1] = reIndex[iterablesEmptyRows[i0]];\n            i1++;\n          }\n        }\n        iterablesEmptyRows.length = i1;\n        for (i0 = 0, i1 = 0; i0 < n; i0++) {\n          if (reIndex[i0] !== REMOVED_INDEX) {\n            if (i1 !== i0) iterablesIndexCount[i1] = iterablesIndexCount[i0];\n            i1++;\n          }\n        }\n        iterablesIndexCount = iterablesIndexCount.slice(0, i1);\n      }\n      // Rewrite our index, overwriting removed values\n      var n0 = values.length;\n      for (var i = 0, j = 0, oldDataIndex; i < n0; ++i) {\n        oldDataIndex = index[i];\n        if (reIndex[oldDataIndex] !== REMOVED_INDEX) {\n          if (i !== j) values[j] = values[i];\n          index[j] = reIndex[oldDataIndex];\n          if (iterable) {\n            iterablesIndexFilterStatus[j] = iterablesIndexFilterStatus[i];\n          }\n          ++j;\n        }\n      }\n      values.length = j;\n      if (iterable) iterablesIndexFilterStatus = iterablesIndexFilterStatus.slice(0, j);\n      while (j < n0) index[j++] = 0;\n\n      // Bisect again to recompute lo0 and hi0.\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // Updates the selected values based on the specified bounds [lo, hi].\n    // This implementation is used by all the public filter methods.\n    function filterIndexBounds(bounds) {\n\n      var lo1 = bounds[0],\n          hi1 = bounds[1];\n\n      if (refilterFunction) {\n        refilterFunction = null;\n        filterIndexFunction(function(d, i) { return lo1 <= i && i < hi1; }, bounds[0] === 0 && bounds[1] === values.length);\n        lo0 = lo1;\n        hi0 = hi1;\n        return dimension;\n      }\n\n      var i,\n          j,\n          k,\n          added = [],\n          removed = [],\n          valueIndexAdded = [],\n          valueIndexRemoved = [];\n\n\n      // Fast incremental update based on previous lo index.\n      if (lo1 < lo0) {\n        for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (lo1 > lo0) {\n        for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n\n      // Fast incremental update based on previous hi index.\n      if (hi1 > hi0) {\n        for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (hi1 < hi0) {\n        for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n\n      if(!iterable) {\n        // Flip filters normally.\n\n        for(i=0; i<added.length; i++) {\n          filters[offset][added[i]] ^= one;\n        }\n\n        for(i=0; i<removed.length; i++) {\n          filters[offset][removed[i]] ^= one;\n        }\n\n      } else {\n        // For iterables, we need to figure out if the row has been completely removed vs partially included\n        // Only count a row as added if it is not already being aggregated. Only count a row\n        // as removed if the last element being aggregated is removed.\n\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          iterablesIndexCount[added[i]]++\n          iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n          if(iterablesIndexCount[added[i]] === 1) {\n            filters[offset][added[i]] ^= one;\n            newAdded.push(added[i]);\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          iterablesIndexCount[removed[i]]--\n          iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n          if(iterablesIndexCount[removed[i]] === 0) {\n            filters[offset][removed[i]] ^= one;\n            newRemoved.push(removed[i]);\n          }\n        }\n\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if(refilter === xfilterFilter.filterAll) {\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if((filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if(!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n\n      lo0 = lo1;\n      hi0 = hi1;\n      filterListeners.forEach(function(l) { l(one, offset, added, removed); });\n      triggerOnChange('filtered');\n      return dimension;\n    }\n\n    // Filters this dimension using the specified range, value, or null.\n    // If the range is null, this is equivalent to filterAll.\n    // If the range is an array, this is equivalent to filterRange.\n    // Otherwise, this is equivalent to filterExact.\n    function filter(range) {\n      return range == null\n          ? filterAll() : Array.isArray(range)\n          ? filterRange(range) : typeof range === \"function\"\n          ? filterFunction(range)\n          : filterExact(range);\n    }\n\n    // Filters this dimension to select the exact value.\n    function filterExact(value) {\n      filterValue = value;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterExact(bisect, value))(values));\n    }\n\n    // Filters this dimension to select the specified range [lo, hi].\n    // The lower bound is inclusive, and the upper bound is exclusive.\n    function filterRange(range) {\n      filterValue = range;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterRange(bisect, range))(values));\n    }\n\n    // Clears any filters on this dimension.\n    function filterAll() {\n      filterValue = undefined;\n      filterValuePresent = false;\n      return filterIndexBounds((refilter = xfilterFilter.filterAll)(values));\n    }\n\n    // Filters this dimension using an arbitrary function.\n    function filterFunction(f) {\n      filterValue = f;\n      filterValuePresent = true;\n\n      refilterFunction = f;\n      refilter = xfilterFilter.filterAll;\n\n      filterIndexFunction(f, false);\n\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n\n      return dimension;\n    }\n\n    function filterIndexFunction(f, filterAll) {\n      var i,\n          k,\n          x,\n          added = [],\n          removed = [],\n          valueIndexAdded = [],\n          valueIndexRemoved = [],\n          indexLength = values.length;\n\n      if(!iterable) {\n        for (i = 0; i < indexLength; ++i) {\n          if (!(filters[offset][k = index[i]] & one) ^ !!(x = f(values[i], i))) {\n            if (x) added.push(k);\n            else removed.push(k);\n          }\n        }\n      }\n\n      if(iterable) {\n        for(i=0; i < indexLength; ++i) {\n          if(f(values[i], i)) {\n            added.push(index[i]);\n            valueIndexAdded.push(i);\n          } else {\n            removed.push(index[i]);\n            valueIndexRemoved.push(i);\n          }\n        }\n      }\n\n      if(!iterable) {\n        for(i=0; i<added.length; i++) {\n          if(filters[offset][added[i]] & one) filters[offset][added[i]] &= zero;\n        }\n\n        for(i=0; i<removed.length; i++) {\n          if(!(filters[offset][removed[i]] & one)) filters[offset][removed[i]] |= one;\n        }\n      } else {\n\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          // First check this particular value needs to be added\n          if(iterablesIndexFilterStatus[valueIndexAdded[i]] === 1) {\n            iterablesIndexCount[added[i]]++\n            iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n            if(iterablesIndexCount[added[i]] === 1) {\n              filters[offset][added[i]] ^= one;\n              newAdded.push(added[i]);\n            }\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          // First check this particular value needs to be removed\n          if(iterablesIndexFilterStatus[valueIndexRemoved[i]] === 0) {\n            iterablesIndexCount[removed[i]]--\n            iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n            if(iterablesIndexCount[removed[i]] === 0) {\n              filters[offset][removed[i]] ^= one;\n              newRemoved.push(removed[i]);\n            }\n          }\n        }\n\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if(filterAll) {\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if((filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if(!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n\n      filterListeners.forEach(function(l) { l(one, offset, added, removed); });\n      triggerOnChange('filtered');\n    }\n\n    function currentFilter() {\n      return filterValue;\n    }\n\n    function hasCurrentFilter() {\n      return filterValuePresent;\n    }\n\n    // Returns the top K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function top(k, top_offset) {\n      var array = [],\n          i = hi0,\n          j,\n          toSkip = 0;\n\n      if(top_offset && top_offset > 0) toSkip = top_offset;\n\n      while (--i >= lo0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if(toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n      }\n\n      if(iterable){\n        for(i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          // Add row with empty iterable column at the end\n          if(filters.zero(j = iterablesEmptyRows[i])) {\n            if(toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n\n      return array;\n    }\n\n    // Returns the bottom K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function bottom(k, bottom_offset) {\n      var array = [],\n          i,\n          j,\n          toSkip = 0;\n\n      if(bottom_offset && bottom_offset > 0) toSkip = bottom_offset;\n\n      if(iterable) {\n        // Add row with empty iterable column at the top\n        for(i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          if(filters.zero(j = iterablesEmptyRows[i])) {\n            if(toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n\n      i = lo0;\n\n      while (i < hi0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if(toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n        i++;\n      }\n\n      return array;\n    }\n\n    // Adds a new group to this dimension, using the specified key function.\n    function group(key) {\n      var group = {\n        top: top,\n        all: all,\n        reduce: reduce,\n        reduceCount: reduceCount,\n        reduceSum: reduceSum,\n        order: order,\n        orderNatural: orderNatural,\n        size: size,\n        dispose: dispose,\n        remove: dispose // for backwards-compatibility\n      };\n\n      // Ensure that this group will be removed when the dimension is removed.\n      dimensionGroups.push(group);\n\n      var groups, // array of {key, value}\n          groupIndex, // object id ↦ group id\n          groupWidth = 8,\n          groupCapacity = capacity(groupWidth),\n          k = 0, // cardinality\n          select,\n          heap,\n          reduceAdd,\n          reduceRemove,\n          reduceInitial,\n          update = cr_null,\n          reset = cr_null,\n          resetNeeded = true,\n          groupAll = key === cr_null,\n          n0old;\n\n      if (arguments.length < 1) key = cr_identity;\n\n      // The group listens to the crossfilter for when any dimension changes, so\n      // that it can update the associated reduce values. It must also listen to\n      // the parent dimension for when data is added, and compute new keys.\n      filterListeners.push(update);\n      indexListeners.push(add);\n      removeDataListeners.push(removeData);\n\n      // Incorporate any existing data into the grouping.\n      add(values, index, 0, n);\n\n      // Incorporates the specified new values into this group.\n      // This function is responsible for updating groups and groupIndex.\n      function add(newValues, newIndex, n0, n1) {\n\n        if(iterable) {\n          n0old = n0\n          n0 = values.length - newValues.length\n          n1 = newValues.length;\n        }\n\n        var oldGroups = groups,\n            reIndex = iterable ? [] : cr_index(k, groupCapacity),\n            add = reduceAdd,\n            remove = reduceRemove,\n            initial = reduceInitial,\n            k0 = k, // old cardinality\n            i0 = 0, // index of old group\n            i1 = 0, // index of new record\n            j, // object id\n            g0, // old group\n            x0, // old key\n            x1, // new key\n            g, // group to add\n            x; // key of group to add\n\n        // If a reset is needed, we don't need to update the reduce values.\n        if (resetNeeded) add = initial = cr_null;\n        if (resetNeeded) remove = initial = cr_null;\n\n        // Reset the new groups (k is a lower bound).\n        // Also, make sure that groupIndex exists and is long enough.\n        groups = new Array(k), k = 0;\n        if(iterable){\n          groupIndex = k0 ? groupIndex : [];\n        }\n        else{\n          groupIndex = k0 > 1 ? xfilterArray.arrayLengthen(groupIndex, n) : cr_index(n, groupCapacity);\n        }\n\n\n        // Get the first old key (x0 of g0), if it exists.\n        if (k0) x0 = (g0 = oldGroups[0]).key;\n\n        // Find the first new key (x1), skipping NaN keys.\n        while (i1 < n1 && !((x1 = key(newValues[i1])) >= x1)) ++i1;\n\n        // While new keys remain…\n        while (i1 < n1) {\n\n          // Determine the lesser of the two current keys; new and old.\n          // If there are no old keys remaining, then always add the new key.\n          if (g0 && x0 <= x1) {\n            g = g0, x = x0;\n\n            // Record the new index of the old group.\n            reIndex[i0] = k;\n\n            // Retrieve the next old key.\n            g0 = oldGroups[++i0];\n            if (g0) x0 = g0.key;\n          } else {\n            g = {key: x1, value: initial()}, x = x1;\n          }\n\n          // Add the lesser group.\n          groups[k] = g;\n\n          // Add any selected records belonging to the added group, while\n          // advancing the new key and populating the associated group index.\n\n          while (x1 <= x) {\n            j = newIndex[i1] + (iterable ? n0old : n0)\n\n\n            if(iterable){\n              if(groupIndex[j]){\n                groupIndex[j].push(k)\n              }\n              else{\n                groupIndex[j] = [k]\n              }\n            }\n            else{\n              groupIndex[j] = k;\n            }\n\n            // Always add new values to groups. Only remove when not in filter.\n            // This gives groups full information on data life-cycle.\n            g.value = add(g.value, data[j], true);\n            if (!filters.zeroExcept(j, offset, zero)) g.value = remove(g.value, data[j], false);\n            if (++i1 >= n1) break;\n            x1 = key(newValues[i1]);\n          }\n\n          groupIncrement();\n        }\n\n        // Add any remaining old groups that were greater th1an all new keys.\n        // No incremental reduce is needed; these groups have no new records.\n        // Also record the new index of the old group.\n        while (i0 < k0) {\n          groups[reIndex[i0] = k] = oldGroups[i0++];\n          groupIncrement();\n        }\n\n\n        // Fill in gaps with empty arrays where there may have been rows with empty iterables\n        if(iterable){\n          for (var index1 = 0; index1 < n; index1++) {\n            if(!groupIndex[index1]){\n              groupIndex[index1] = [];\n            }\n          }\n        }\n\n        // If we added any new groups before any old groups,\n        // update the group index of all the old records.\n        if(k > i0){\n          if(iterable){\n            for (i0 = 0; i0 < n0old; ++i0) {\n              for (index1 = 0; index1 < groupIndex[i0].length; index1++) {\n                groupIndex[i0][index1] = reIndex[groupIndex[i0][index1]];\n              }\n            }\n          }\n          else{\n            for (i0 = 0; i0 < n0; ++i0) {\n              groupIndex[i0] = reIndex[groupIndex[i0]];\n            }\n          }\n        }\n\n        // Modify the update and reset behavior based on the cardinality.\n        // If the cardinality is less than or equal to one, then the groupIndex\n        // is not needed. If the cardinality is zero, then there are no records\n        // and therefore no groups to update or reset. Note that we also must\n        // change the registered listener to point to the new method.\n        j = filterListeners.indexOf(update);\n        if (k > 1 || iterable) {\n          update = updateMany;\n          reset = resetMany;\n        } else {\n          if (!k && groupAll) {\n            k = 1;\n            groups = [{key: null, value: initial()}];\n          }\n          if (k === 1) {\n            update = updateOne;\n            reset = resetOne;\n          } else {\n            update = cr_null;\n            reset = cr_null;\n          }\n          groupIndex = null;\n        }\n        filterListeners[j] = update;\n\n        // Count the number of added groups,\n        // and widen the group index as needed.\n        function groupIncrement() {\n          if(iterable){\n            k++\n            return\n          }\n          if (++k === groupCapacity) {\n            reIndex = xfilterArray.arrayWiden(reIndex, groupWidth <<= 1);\n            groupIndex = xfilterArray.arrayWiden(groupIndex, groupWidth);\n            groupCapacity = capacity(groupWidth);\n          }\n        }\n      }\n\n      function removeData(reIndex) {\n        if (k > 1 || iterable) {\n          var oldK = k,\n              oldGroups = groups,\n              seenGroups = cr_index(oldK, oldK),\n              i,\n              i0,\n              j;\n\n          // Filter out non-matches by copying matching group index entries to\n          // the beginning of the array.\n          if (!iterable) {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                seenGroups[groupIndex[j] = groupIndex[i]] = 1;\n                ++j;\n              }\n            }\n          } else {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                groupIndex[j] = groupIndex[i];\n                for (i0 = 0; i0 < groupIndex[j].length; i0++) {\n                  seenGroups[groupIndex[j][i0]] = 1;\n                }\n                ++j;\n              }\n            }\n            groupIndex = groupIndex.slice(0, j);\n          }\n\n          // Reassemble groups including only those groups that were referred\n          // to by matching group index entries.  Note the new group index in\n          // seenGroups.\n          groups = [], k = 0;\n          for (i = 0; i < oldK; ++i) {\n            if (seenGroups[i]) {\n              seenGroups[i] = k++;\n              groups.push(oldGroups[i]);\n            }\n          }\n\n          if (k > 1 || iterable) {\n            // Reindex the group index using seenGroups to find the new index.\n            if (!iterable) {\n              for (i = 0; i < j; ++i) groupIndex[i] = seenGroups[groupIndex[i]];\n            } else {\n              for (i = 0; i < j; ++i) {\n                for (i0 = 0; i0 < groupIndex[i].length; ++i0) {\n                  groupIndex[i][i0] = seenGroups[groupIndex[i][i0]];\n                }\n              }\n            }\n          } else {\n            groupIndex = null;\n          }\n          filterListeners[filterListeners.indexOf(update)] = k > 1 || iterable\n              ? (reset = resetMany, update = updateMany)\n              : k === 1 ? (reset = resetOne, update = updateOne)\n              : reset = update = cr_null;\n        } else if (k === 1) {\n          if (groupAll) return;\n          for (var index3 = 0; index3 < n; ++index3) if (reIndex[index3] !== REMOVED_INDEX) return;\n          groups = [], k = 0;\n          filterListeners[filterListeners.indexOf(update)] =\n          update = reset = cr_null;\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is greater than 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateMany(filterOne, filterOffset, added, removed, notFilter) {\n\n        if ((filterOne === one && filterOffset === offset) || resetNeeded) return;\n\n        var i,\n            j,\n            k,\n            n,\n            g;\n\n        if(iterable){\n          // Add the added values.\n          for (i = 0, n = added.length; i < n; ++i) {\n            if (filters.zeroExcept(k = added[i], offset, zero)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceAdd(g.value, data[k], false, j);\n              }\n            }\n          }\n\n          // Remove the removed values.\n          for (i = 0, n = removed.length; i < n; ++i) {\n            if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceRemove(g.value, data[k], notFilter, j);\n              }\n            }\n          }\n          return;\n        }\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateOne(filterOne, filterOffset, added, removed, notFilter) {\n        if ((filterOne === one && filterOffset === offset) || resetNeeded) return;\n\n        var i,\n            k,\n            n,\n            g = groups[0];\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is greater than 1.\n      function resetMany() {\n        var i,\n            j,\n            g;\n\n        // Reset all group values.\n        for (i = 0; i < k; ++i) {\n          groups[i].value = reduceInitial();\n        }\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an 'unfiltered' view even if there are already filters in\n        // place on other dimensions.\n        if(iterable){\n          for (i = 0; i < n; ++i) {\n            for (j = 0; j < groupIndex[i].length; j++) {\n              g = groups[groupIndex[i][j]];\n              g.value = reduceAdd(g.value, data[i], true, j);\n            }\n          }\n          for (i = 0; i < n; ++i) {\n            if (!filters.zeroExcept(i, offset, zero)) {\n              for (j = 0; j < groupIndex[i].length; j++) {\n                g = groups[groupIndex[i][j]];\n                g.value = reduceRemove(g.value, data[i], false, j);\n              }\n            }\n          }\n          return;\n        }\n\n        for (i = 0; i < n; ++i) {\n          g = groups[groupIndex[i]];\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g = groups[groupIndex[i]];\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is 1.\n      function resetOne() {\n        var i,\n            g = groups[0];\n\n        // Reset the singleton group values.\n        g.value = reduceInitial();\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an 'unfiltered' view even if there are already filters in\n        // place on other dimensions.\n        for (i = 0; i < n; ++i) {\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Returns the array of group values, in the dimension's natural order.\n      function all() {\n        if (resetNeeded) reset(), resetNeeded = false;\n        return groups;\n      }\n\n      // Returns a new array containing the top K group values, in reduce order.\n      function top(k) {\n        var top = select(all(), 0, groups.length, k);\n        return heap.sort(top, 0, top.length);\n      }\n\n      // Sets the reduce behavior for this group to use the specified functions.\n      // This method lazily recomputes the reduce values, waiting until needed.\n      function reduce(add, remove, initial) {\n        reduceAdd = add;\n        reduceRemove = remove;\n        reduceInitial = initial;\n        resetNeeded = true;\n        return group;\n      }\n\n      // A convenience method for reducing by count.\n      function reduceCount() {\n        return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n      }\n\n      // A convenience method for reducing by sum(value).\n      function reduceSum(value) {\n        return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n      }\n\n      // Sets the reduce order, using the specified accessor.\n      function order(value) {\n        select = xfilterHeapselect.by(valueOf);\n        heap = xfilterHeap.by(valueOf);\n        function valueOf(d) { return value(d.value); }\n        return group;\n      }\n\n      // A convenience method for natural ordering by reduce value.\n      function orderNatural() {\n        return order(cr_identity);\n      }\n\n      // Returns the cardinality of this group, irrespective of any filters.\n      function size() {\n        return k;\n      }\n\n      // Removes this group and associated event listeners.\n      function dispose() {\n        var i = filterListeners.indexOf(update);\n        if (i >= 0) filterListeners.splice(i, 1);\n        i = indexListeners.indexOf(add);\n        if (i >= 0) indexListeners.splice(i, 1);\n        i = removeDataListeners.indexOf(removeData);\n        if (i >= 0) removeDataListeners.splice(i, 1);\n        i = dimensionGroups.indexOf(group);\n        if (i >= 0) dimensionGroups.splice(i, 1);\n        return group;\n      }\n\n      return reduceCount().orderNatural();\n    }\n\n    // A convenience function for generating a singleton group.\n    function groupAll() {\n      var g = group(cr_null), all = g.all;\n      delete g.all;\n      delete g.top;\n      delete g.order;\n      delete g.orderNatural;\n      delete g.size;\n      g.value = function() { return all()[0].value; };\n      return g;\n    }\n\n    // Removes this dimension and associated groups and event listeners.\n    function dispose() {\n      dimensionGroups.forEach(function(group) { group.dispose(); });\n      var i = dataListeners.indexOf(preAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = dataListeners.indexOf(postAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = removeDataListeners.indexOf(removeData);\n      if (i >= 0) removeDataListeners.splice(i, 1);\n      filters.masks[offset] &= zero;\n      return filterAll();\n    }\n\n    return dimension;\n  }\n\n  // A convenience method for groupAll on a dummy dimension.\n  // This implementation can be optimized since it always has cardinality 1.\n  function groupAll() {\n    var group = {\n      reduce: reduce,\n      reduceCount: reduceCount,\n      reduceSum: reduceSum,\n      value: value,\n      dispose: dispose,\n      remove: dispose // for backwards-compatibility\n    };\n\n    var reduceValue,\n        reduceAdd,\n        reduceRemove,\n        reduceInitial,\n        resetNeeded = true;\n\n    // The group listens to the crossfilter for when any dimension changes, so\n    // that it can update the reduce value. It must also listen to the parent\n    // dimension for when data is added.\n    filterListeners.push(update);\n    dataListeners.push(add);\n\n    // For consistency; actually a no-op since resetNeeded is true.\n    add(data, 0, n);\n\n    // Incorporates the specified new values into this group.\n    function add(newData, n0) {\n      var i;\n\n      if (resetNeeded) return;\n\n      // Cycle through all the values.\n      for (i = n0; i < n; ++i) {\n\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Reduces the specified selected or deselected records.\n    function update(filterOne, filterOffset, added, removed, notFilter) {\n      var i,\n          k,\n          n;\n\n      if (resetNeeded) return;\n\n      // Add the added values.\n      for (i = 0, n = added.length; i < n; ++i) {\n        if (filters.zero(k = added[i])) {\n          reduceValue = reduceAdd(reduceValue, data[k], notFilter);\n        }\n      }\n\n      // Remove the removed values.\n      for (i = 0, n = removed.length; i < n; ++i) {\n        if (filters.only(k = removed[i], filterOffset, filterOne)) {\n          reduceValue = reduceRemove(reduceValue, data[k], notFilter);\n        }\n      }\n    }\n\n    // Recomputes the group reduce value from scratch.\n    function reset() {\n      var i;\n\n      reduceValue = reduceInitial();\n\n      // Cycle through all the values.\n      for (i = 0; i < n; ++i) {\n\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if it is filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Sets the reduce behavior for this group to use the specified functions.\n    // This method lazily recomputes the reduce value, waiting until needed.\n    function reduce(add, remove, initial) {\n      reduceAdd = add;\n      reduceRemove = remove;\n      reduceInitial = initial;\n      resetNeeded = true;\n      return group;\n    }\n\n    // A convenience method for reducing by count.\n    function reduceCount() {\n      return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n    }\n\n    // A convenience method for reducing by sum(value).\n    function reduceSum(value) {\n      return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n    }\n\n    // Returns the computed reduce value.\n    function value() {\n      if (resetNeeded) reset(), resetNeeded = false;\n      return reduceValue;\n    }\n\n    // Removes this group and associated event listeners.\n    function dispose() {\n      var i = filterListeners.indexOf(update);\n      if (i >= 0) filterListeners.splice(i, 1);\n      i = dataListeners.indexOf(add);\n      if (i >= 0) dataListeners.splice(i, 1);\n      return group;\n    }\n\n    return reduceCount();\n  }\n\n  // Returns the number of records in this crossfilter, irrespective of any filters.\n  function size() {\n    return n;\n  }\n\n  // Returns the raw row data contained in this crossfilter\n  function all(){\n    return data;\n  }\n\n  // Returns row data with all dimension filters applied, except for filters in ignore_dimensions\n  function allFiltered(ignore_dimensions) {\n    var array = [],\n        i = 0,\n        mask = maskForDimensions(ignore_dimensions || []);\n\n      for (i = 0; i < n; i++) {\n        if (filters.zeroExceptMask(i, mask)) {\n          array.push(data[i]);\n        }\n      }\n\n      return array;\n  }\n\n  function onChange(cb){\n    if(typeof cb !== 'function'){\n      /* eslint no-console: 0 */\n      console.warn('onChange callback parameter must be a function!');\n      return;\n    }\n    callbacks.push(cb);\n    return function(){\n      callbacks.splice(callbacks.indexOf(cb), 1);\n    };\n  }\n\n  function triggerOnChange(eventName){\n    for (var i = 0; i < callbacks.length; i++) {\n      callbacks[i](eventName);\n    }\n  }\n\n  return arguments.length\n      ? add(arguments[0])\n      : crossfilter;\n}\n\n// Returns an array of size n, big enough to store ids up to m.\nfunction cr_index(n, m) {\n  return (m < 0x101\n      ? xfilterArray.array8 : m < 0x10001\n      ? xfilterArray.array16\n      : xfilterArray.array32)(n);\n}\n\n// Constructs a new array of size n, with sequential values from 0 to n - 1.\nfunction cr_range(n) {\n  var range = cr_index(n, n);\n  for (var i = -1; ++i < n;) range[i] = i;\n  return range;\n}\n\nfunction capacity(w) {\n  return w === 8\n      ? 0x100 : w === 16\n      ? 0x10000\n      : 0x100000000;\n}\n"],"names":["array8","arrayUntyped","array16","array32","arrayLengthen","arrayLengthenUntyped","arrayWiden","arrayWidenUntyped","n","array","Array","i","length","width","Error","bitarray","this","subarrays","masks","Uint8Array","Uint16Array","Uint32Array","copy","constructor","set","prototype","lengthen","len","add","m","w","one","offset","dest","src","truncate","j","zero","zeroExcept","zeroExceptMask","mask","only","onlyExcept","onlyOffset","onlyOne","xfilterArray","xfilterFilter","bisect2","value","values","left","right","range","min","max","cr_identity","d","cr_null","cr_zero","heap_by","f","heap","a","lo","hi","sift","child","x","sort","t","h","identity","heapselect_by","xFilterHeap","by","k","queue","Math","bisect_by","bisectRight","mid","bisect","permute","index","deep2","JSON","parse","stringify","xfilterReduce","p","v","get","obj","prop","call","reg","result","path","e","r","split","splice","deep","replace","crossfilter","filters","crossfilter2","remove","removeData","dimension","groupAll","size","all","allFiltered","onChange","isElementFiltered","data","filterListeners","dataListeners","removeDataListeners","callbacks","newData","n0","n1","concat","forEach","l","triggerOnChange","predicate","newIndex","removed","usePred","index1","index2","push","index3","index4","maskForDimensions","dimensions","n2","id","ignore_dimensions","iterable","accessorPath","newValues","iterablesIndexCount","iterablesIndexFilterStatus","refilterFunction","filterValue","filterValuePresent","dimension2","filter","filterAll2","isArray","filterRange2","filterFunction","filterExact2","filterExact","filterRange","filterAll","currentFilter","hasCurrentFilter","top","k2","top_offset","hi0","toSkip","lo0","iterablesEmptyRows","bottom","bottom_offset","group","g","all2","order","orderNatural","dispose","accessor","sortRange","cr_range","A","B","b","refilter","indexListeners","dimensionGroups","unshift","preAdd","postAdd","removeData2","tmp","newIterablesIndexCount","newIterablesIndexFilterStatus","i0","cr_index","unsortedIndex","sortMap","map","bounds","lo1","hi1","old_n0","oldValues","oldIndex","oldIterablesIndexFilterStatus","i1","oldiiclength","index5","reIndex","slice","oldDataIndex","filterIndexBounds","filterIndexFunction","i2","added","valueIndexAdded","valueIndexRemoved","newAdded","newRemoved","value2","filterAll3","indexLength","key","group2","top2","reduce","reduceCount","reduceSum","size2","dispose2","groups","groupIndex","select","reduceAdd2","reduceRemove","reduceInitial","n0old","groupWidth","groupCapacity","capacity","update","reset","resetNeeded","groupAll3","add2","newValues2","newIndex2","g0","x0","x1","oldGroups","add3","initial","k0","groupIncrement","indexOf","updateMany","resetMany","updateOne","resetOne","removeData3","oldK","seenGroups","filterOne","filterOffset","notFilter","k3","top3","valueOf","xfilterHeapselect","xfilterHeap","arguments","log","reduceValue","cb","console","warn","eventName","heapselect"],"mappings":"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"}