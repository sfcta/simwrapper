var r=Object.defineProperty,e=Object.defineProperties,t=Object.getOwnPropertyDescriptors,o=Object.getOwnPropertySymbols,n=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable,s=(e,t,o)=>t in e?r(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o,a=(r,e)=>{for(var t in e||(e={}))n.call(e,t)&&s(r,t,e[t]);if(o)for(var t of o(e))i.call(e,t)&&s(r,t,e[t]);return r},c=(r,o)=>e(r,t(o));import{g as l}from"./index.2deacc07.js";import{L as d}from"./line-layer.600fa289.js";const f={NONE:0,LEFT:1,RIGHT:-1};class u extends d{initializeState(r){super.initializeState(r)}getShaders(){return c(a({},super.getShaders()),{vs:"#define SHADER_NAME line-layer-vertex-shader\r\n\r\nattribute vec3 positions;\r\nattribute vec3 instanceSourcePositions;\r\nattribute vec3 instanceTargetPositions;\r\nattribute vec3 instanceSourcePositions64Low;\r\nattribute vec3 instanceTargetPositions64Low;\r\nattribute vec4 instanceColors;\r\nattribute vec3 instancePickingColors;\r\nattribute float instanceWidths;\r\n\r\nuniform float opacity;\r\nuniform float widthScale;\r\nuniform float widthMinPixels;\r\nuniform float widthMaxPixels;\r\nuniform float useShortestPath;\r\nuniform int widthUnits;\r\n\r\nuniform float offsetDirection;\r\nuniform float bearing;\r\n\r\nvarying vec4 vColor;\r\nvarying vec2 uv;\r\n\r\n// offset vector by strokeWidth pixels\r\n// offset_direction is -1 (left) or 1 (right)\r\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\r\n  // normalized direction of the line\r\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\r\n  // rotate by 90 degrees\r\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\r\n\r\n  return dir_screenspace * offset_direction * width / 2.0;\r\n}\r\n\r\nvec3 splitLine(vec3 a, vec3 b, float x) {\r\n  float t = (x - a.x) / (b.x - a.x);\r\n  return vec3(x, mix(a.yz, b.yz, t));\r\n}\r\n\r\nvoid drivingSideOffset(inout vec3 size, float widthPixels) {\r\n\r\n    // a -> b\r\n    vec3 link = geometry.worldPositionAlt.xyz - geometry.worldPosition.xyz;\r\n\r\n    // normalized direction of the line\r\n    vec2 direction = normalize(link.xy * project_uViewportSize);\r\n\r\n    // rotate by map bearing\r\n    vec2 rotation;\r\n    rotation.x = direction.x * cos(bearing) + direction.y * -sin(bearing);\r\n    rotation.y = direction.x * sin(bearing) + direction.y *  cos(bearing);\r\n\r\n    // rotate by 90 degrees to get offset direction\r\n    rotation = vec2(-rotation.y, rotation.x);\r\n\r\n    // offset the coordinates\r\n    vec2 offset = rotation * offsetDirection * widthPixels / 2.0;\r\n\r\n    size.x += offset.x;\r\n    size.y += offset.y;\r\n}\r\n\r\nvoid main(void) {\r\n  geometry.worldPosition = instanceSourcePositions;\r\n  geometry.worldPositionAlt = instanceTargetPositions;\r\n\r\n  vec3 source_world = instanceSourcePositions;\r\n  vec3 target_world = instanceTargetPositions;\r\n  vec3 source_world_64low = instanceSourcePositions64Low;\r\n  vec3 target_world_64low = instanceTargetPositions64Low;\r\n\r\n  if (useShortestPath > 0.5 || useShortestPath < -0.5) {\r\n    source_world.x = mod(source_world.x + 180., 360.0) - 180.;\r\n    target_world.x = mod(target_world.x + 180., 360.0) - 180.;\r\n    float deltaLng = target_world.x - source_world.x;\r\n\r\n    if (deltaLng * useShortestPath > 180.) {\r\n      source_world.x += 360. * useShortestPath;\r\n      source_world = splitLine(source_world, target_world, 180. * useShortestPath);\r\n      source_world_64low = vec3(0.0);\r\n    } else if (deltaLng * useShortestPath < -180.) {\r\n      target_world.x += 360. * useShortestPath;\r\n      target_world = splitLine(source_world, target_world, 180. * useShortestPath);\r\n      target_world_64low = vec3(0.0);\r\n    } else if (useShortestPath < 0.) {\r\n      // Line is not split, abort\r\n      gl_Position = vec4(0.);\r\n      return;\r\n    }\r\n  }\r\n\r\n  // Position\r\n  vec4 source_commonspace;\r\n  vec4 target_commonspace;\r\n  vec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);\r\n  vec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);\r\n\r\n  // linear interpolation of source & target to pick right coord\r\n  float segmentIndex = positions.x;\r\n  vec4 p = mix(source, target, segmentIndex);\r\n  geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);\r\n  uv = positions.xy;\r\n  geometry.uv = uv;\r\n  geometry.pickingColor = instancePickingColors;\r\n\r\n  // Multiply out width and clamp to limits\r\n  float widthPixels = clamp(\r\n    project_size_to_pixel(instanceWidths * widthScale, widthUnits),\r\n    widthMinPixels, widthMaxPixels\r\n  );\r\n\r\n  // extrude\r\n  vec3 offset = vec3(\r\n    getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),\r\n    0.0);\r\n\r\n  drivingSideOffset(offset, 1.0 + widthPixels);\r\n\r\n  DECKGL_FILTER_SIZE(offset, geometry);\r\n  gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\r\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\r\n\r\n  // Color\r\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\r\n  DECKGL_FILTER_COLOR(vColor, geometry);\r\n}\r\n"})}draw({uniforms:r}){const{offsetDirection:e}=this.props,t=c(a({},r),{offsetDirection:e,bearing:l.state.viewState.bearing*Math.PI/180});super.draw({uniforms:t})}}u.layerName="LineOffsetLayer",u.defaultProps={bearing:0,offsetDirection:f.RIGHT};export{u as L,f as O};
//# sourceMappingURL=LineOffsetLayer.5b80c65e.js.map
