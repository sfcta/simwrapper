{"version":3,"file":"arc-layer.bf091b3d.js","sources":["../../node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer.js","../../node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-vertex.glsl.js","../../node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-fragment.glsl.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Layer, project32, picking, UNIT } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/core';\nimport vs from './arc-layer-vertex.glsl';\nimport fs from './arc-layer-fragment.glsl';\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  getSourcePosition: {\n    type: 'accessor',\n    value: x => x.sourcePosition\n  },\n  getTargetPosition: {\n    type: 'accessor',\n    value: x => x.targetPosition\n  },\n  getSourceColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getTargetColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getWidth: {\n    type: 'accessor',\n    value: 1\n  },\n  getHeight: {\n    type: 'accessor',\n    value: 1\n  },\n  getTilt: {\n    type: 'accessor',\n    value: 0\n  },\n  greatCircle: false,\n  widthUnits: 'pixels',\n  widthScale: {\n    type: 'number',\n    value: 1,\n    min: 0\n  },\n  widthMinPixels: {\n    type: 'number',\n    value: 0,\n    min: 0\n  },\n  widthMaxPixels: {\n    type: 'number',\n    value: Number.MAX_SAFE_INTEGER,\n    min: 0\n  }\n};\nexport default class ArcLayer extends Layer {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", void 0);\n  }\n\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, picking]\n    });\n  }\n\n  get wrapLongitude() {\n    return false;\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instanceSourcePositions: {\n        size: 3,\n        type: 5130,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getSourcePosition'\n      },\n      instanceTargetPositions: {\n        size: 3,\n        type: 5130,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getTargetPosition'\n      },\n      instanceSourceColors: {\n        size: this.props.colorFormat.length,\n        type: 5121,\n        normalized: true,\n        transition: true,\n        accessor: 'getSourceColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceTargetColors: {\n        size: this.props.colorFormat.length,\n        type: 5121,\n        normalized: true,\n        transition: true,\n        accessor: 'getTargetColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceWidths: {\n        size: 1,\n        transition: true,\n        accessor: 'getWidth',\n        defaultValue: 1\n      },\n      instanceHeights: {\n        size: 1,\n        transition: true,\n        accessor: 'getHeight',\n        defaultValue: 1\n      },\n      instanceTilts: {\n        size: 1,\n        transition: true,\n        accessor: 'getTilt',\n        defaultValue: 0\n      }\n    });\n  }\n\n  updateState(opts) {\n    super.updateState(opts);\n\n    if (opts.changeFlags.extensionsChanged) {\n      var _this$state$model;\n\n      const {\n        gl\n      } = this.context;\n      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();\n      this.state.model = this._getModel(gl);\n      this.getAttributeManager().invalidateAll();\n    }\n  }\n\n  draw({\n    uniforms\n  }) {\n    const {\n      widthUnits,\n      widthScale,\n      widthMinPixels,\n      widthMaxPixels,\n      greatCircle,\n      wrapLongitude\n    } = this.props;\n    this.state.model.setUniforms(uniforms).setUniforms({\n      greatCircle,\n      widthUnits: UNIT[widthUnits],\n      widthScale,\n      widthMinPixels,\n      widthMaxPixels,\n      useShortestPath: wrapLongitude\n    }).draw();\n  }\n\n  _getModel(gl) {\n    let positions = [];\n    const NUM_SEGMENTS = 50;\n\n    for (let i = 0; i < NUM_SEGMENTS; i++) {\n      positions = positions.concat([i, 1, 0, i, -1, 0]);\n    }\n\n    const model = new Model(gl, { ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: 5,\n        attributes: {\n          positions: new Float32Array(positions)\n        }\n      }),\n      isInstanced: true\n    });\n    model.setUniforms({\n      numSegments: NUM_SEGMENTS\n    });\n    return model;\n  }\n\n}\n\n_defineProperty(ArcLayer, \"layerName\", 'ArcLayer');\n\n_defineProperty(ArcLayer, \"defaultProps\", defaultProps);\n//# sourceMappingURL=arc-layer.js.map","export default \"#define SHADER_NAME arc-layer-vertex-shader\\n\\nattribute vec3 positions;\\nattribute vec4 instanceSourceColors;\\nattribute vec4 instanceTargetColors;\\nattribute vec3 instanceSourcePositions;\\nattribute vec3 instanceSourcePositions64Low;\\nattribute vec3 instanceTargetPositions;\\nattribute vec3 instanceTargetPositions64Low;\\nattribute vec3 instancePickingColors;\\nattribute float instanceWidths;\\nattribute float instanceHeights;\\nattribute float instanceTilts;\\n\\nuniform bool greatCircle;\\nuniform bool useShortestPath;\\nuniform float numSegments;\\nuniform float opacity;\\nuniform float widthScale;\\nuniform float widthMinPixels;\\nuniform float widthMaxPixels;\\nuniform int widthUnits;\\n\\nvarying vec4 vColor;\\nvarying vec2 uv;\\nvarying float isValid;\\n\\nfloat paraboloid(float distance, float sourceZ, float targetZ, float ratio) {\\n  // d: distance on the xy plane\\n  // r: ratio of the current point\\n  // p: ratio of the peak of the arc\\n  // h: height multiplier\\n  // z = f(r) = sqrt(r * (p * 2 - r)) * d * h\\n  // f(0) = 0\\n  // f(1) = dz\\n\\n  float deltaZ = targetZ - sourceZ;\\n  float dh = distance * instanceHeights;\\n  if (dh == 0.0) {\\n    return sourceZ + deltaZ * ratio;\\n  }\\n  float unitZ = deltaZ / dh;\\n  float p2 = unitZ * unitZ + 1.0;\\n\\n  // sqrt does not deal with negative values, manually flip source and target if delta.z < 0\\n  float dir = step(deltaZ, 0.0);\\n  float z0 = mix(sourceZ, targetZ, dir);\\n  float r = mix(ratio, 1.0 - ratio, dir);\\n  return sqrt(r * (p2 - r)) * dh + z0;\\n}\\n\\n// offset vector by strokeWidth pixels\\n// offset_direction is -1 (left) or 1 (right)\\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\\n  // normalized direction of the line\\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\\n  // rotate by 90 degrees\\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\\n\\n  return dir_screenspace * offset_direction * width / 2.0;\\n}\\n\\nfloat getSegmentRatio(float index) {\\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\\n}\\n\\nvec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {\\n  float distance = length(source.xy - target.xy);\\n  float z = paraboloid(distance, source.z, target.z, segmentRatio);\\n\\n  float tiltAngle = radians(instanceTilts);\\n  vec2 tiltDirection = normalize(target.xy - source.xy);\\n  vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\\n\\n  return vec3(\\n    mix(source.xy, target.xy, segmentRatio) + tilt,\\n    z * cos(tiltAngle)\\n  );\\n}\\n\\n/* Great circle interpolation\\n * http://www.movable-type.co.uk/scripts/latlong.html\\n */\\nfloat getAngularDist (vec2 source, vec2 target) {\\n  vec2 sourceRadians = radians(source);\\n  vec2 targetRadians = radians(target);\\n  vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);\\n  vec2 shd_sq = sin_half_delta * sin_half_delta;\\n\\n  float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;\\n  return 2.0 * asin(sqrt(a));\\n}\\n\\nvec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {\\n  vec2 lngLat;\\n\\n  // if the angularDist is PI, linear interpolation is applied. otherwise, use spherical interpolation\\n  if(abs(angularDist - PI) < 0.001) {\\n    lngLat = (1.0 - t) * source.xy + t * target.xy;\\n  } else {\\n    float a = sin((1.0 - t) * angularDist);\\n    float b = sin(t * angularDist);\\n    vec3 p = source3D.yxz * a + target3D.yxz * b;\\n    lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));\\n  }\\n\\n  float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);\\n\\n  return vec3(lngLat, z);\\n}\\n\\n/* END GREAT CIRCLE */\\n\\nvoid main(void) {\\n  geometry.worldPosition = instanceSourcePositions;\\n  geometry.worldPositionAlt = instanceTargetPositions;\\n\\n  float segmentIndex = positions.x;\\n  float segmentRatio = getSegmentRatio(segmentIndex);\\n  float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));\\n  float nextSegmentRatio = getSegmentRatio(min(numSegments - 1.0, segmentIndex + 1.0));\\n\\n  // if it's the first point, use next - current as direction\\n  // otherwise use current - prev\\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\\n  isValid = 1.0;\\n\\n  uv = vec2(segmentRatio, positions.y);\\n  geometry.uv = uv;\\n  geometry.pickingColor = instancePickingColors;\\n\\n  vec4 curr;\\n  vec4 next;\\n  vec3 source;\\n  vec3 target;\\n\\n  if ((greatCircle || project_uProjectionMode == PROJECTION_MODE_GLOBE) && project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\\n    source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));\\n    target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));\\n    float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);\\n\\n    vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);\\n    vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);\\n    vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);\\n\\n    if (abs(currPos.x - prevPos.x) > 180.0) {\\n      indexDir = -1.0;\\n      isValid = 0.0;\\n    } else if (abs(currPos.x - nextPos.x) > 180.0) {\\n      indexDir = 1.0;\\n      isValid = 0.0;\\n    }\\n    nextPos = indexDir < 0.0 ? prevPos : nextPos;\\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\\n\\n    if (isValid == 0.0) {\\n      // split at the 180th meridian\\n      nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;\\n      float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);\\n      currPos = mix(currPos, nextPos, t);\\n      segmentRatio = mix(segmentRatio, nextSegmentRatio, t);\\n    }\\n\\n    vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);\\n    vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);\\n  \\n    curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);\\n    next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));\\n  \\n  } else {\\n    vec3 source_world = instanceSourcePositions;\\n    vec3 target_world = instanceTargetPositions;\\n    if (useShortestPath) {\\n      source_world.x = mod(source_world.x + 180., 360.0) - 180.;\\n      target_world.x = mod(target_world.x + 180., 360.0) - 180.;\\n\\n      float deltaLng = target_world.x - source_world.x;\\n      if (deltaLng > 180.) target_world.x -= 360.;\\n      if (deltaLng < -180.) source_world.x -= 360.;\\n    }\\n    source = project_position(source_world, instanceSourcePositions64Low);\\n    target = project_position(target_world, instanceTargetPositions64Low);\\n\\n    // common x at longitude=-180\\n    float antiMeridianX = 0.0;\\n\\n    if (useShortestPath) {\\n      if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\\n        antiMeridianX = -(project_uCoordinateOrigin.x + 180.) / 360. * TILE_SIZE;\\n      }\\n      float thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);\\n\\n      if (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {\\n        isValid = 0.0;\\n        indexDir = sign(segmentRatio - thresholdRatio);\\n        segmentRatio = thresholdRatio;\\n      }\\n    }\\n\\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\\n    vec3 currPos = interpolateFlat(source, target, segmentRatio);\\n    vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);\\n\\n    if (useShortestPath) {\\n      if (nextPos.x < antiMeridianX) {\\n        currPos.x += TILE_SIZE;\\n        nextPos.x += TILE_SIZE;\\n      }\\n    }\\n\\n    curr = project_common_position_to_clipspace(vec4(currPos, 1.0));\\n    next = project_common_position_to_clipspace(vec4(nextPos, 1.0));\\n    geometry.position = vec4(currPos, 1.0);\\n  }\\n\\n  // Multiply out width and clamp to limits\\n  // mercator pixels are interpreted as screen pixels\\n  float widthPixels = clamp(\\n    project_size_to_pixel(instanceWidths * widthScale, widthUnits),\\n    widthMinPixels, widthMaxPixels\\n  );\\n\\n  // extrude\\n  vec3 offset = vec3(\\n    getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels),\\n    0.0);\\n  DECKGL_FILTER_SIZE(offset, geometry);\\n  gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n\\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);\\n  vColor = vec4(color.rgb, color.a * opacity);\\n  DECKGL_FILTER_COLOR(vColor, geometry);\\n}\\n\";\n//# sourceMappingURL=arc-layer-vertex.glsl.js.map","export default \"#define SHADER_NAME arc-layer-fragment-shader\\n\\nprecision highp float;\\n\\nvarying vec4 vColor;\\nvarying vec2 uv;\\nvarying float isValid;\\n\\nvoid main(void) {\\n  if (isValid == 0.0) {\\n    discard;\\n  }\\n\\n  gl_FragColor = vColor;\\n  geometry.uv = uv;\\n\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\";\n//# sourceMappingURL=arc-layer-fragment.glsl.js.map"],"names":["DEFAULT_COLOR","defaultProps","getSourcePosition","type","value","x","sourcePosition","getTargetPosition","targetPosition","getSourceColor","getTargetColor","getWidth","getHeight","getTilt","greatCircle","widthUnits","widthScale","min","widthMinPixels","widthMaxPixels","Number","MAX_SAFE_INTEGER","ArcLayer","Layer","constructor","args","super","_defineProperty","this","getShaders","vs","fs","modules","project32","picking","wrapLongitude","initializeState","getAttributeManager","addInstanced","instanceSourcePositions","size","fp64","use64bitPositions","transition","accessor","instanceTargetPositions","instanceSourceColors","props","colorFormat","length","normalized","defaultValue","instanceTargetColors","instanceWidths","instanceHeights","instanceTilts","updateState","opts","changeFlags","extensionsChanged","_this$state$model","gl","context","state","model","delete","_getModel","invalidateAll","draw","uniforms","setUniforms","UNIT","useShortestPath","positions","i","concat","Model","__spreadValues","id","geometry","Geometry","drawMode","attributes","Float32Array","isInstanced","numSegments"],"mappings":"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"}