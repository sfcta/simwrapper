{"version":3,"file":"path-layer.f17fbd6c.js","sources":["../../node_modules/@deck.gl/core/dist/esm/utils/tesselator.js","../../node_modules/@math.gl/polygon/dist/esm/utils.js","../../node_modules/@math.gl/polygon/dist/esm/lineclip.js","../../node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js","../../node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js","../../node_modules/@deck.gl/layers/dist/esm/path-layer/path.js","../../node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js","../../node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js","../../node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js","../../node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { createIterable, getAccessorFromBuffer } from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\nimport { Buffer } from '@luma.gl/webgl';\nexport default class Tesselator {\n  constructor(opts) {\n    _defineProperty(this, \"opts\", void 0);\n\n    _defineProperty(this, \"typedArrayManager\", void 0);\n\n    _defineProperty(this, \"indexStarts\", [0]);\n\n    _defineProperty(this, \"vertexStarts\", [0]);\n\n    _defineProperty(this, \"vertexCount\", 0);\n\n    _defineProperty(this, \"instanceCount\", 0);\n\n    _defineProperty(this, \"attributes\", void 0);\n\n    _defineProperty(this, \"_attributeDefs\", void 0);\n\n    _defineProperty(this, \"data\", void 0);\n\n    _defineProperty(this, \"getGeometry\", void 0);\n\n    _defineProperty(this, \"geometryBuffer\", void 0);\n\n    _defineProperty(this, \"buffers\", void 0);\n\n    _defineProperty(this, \"positionSize\", void 0);\n\n    _defineProperty(this, \"normalize\", void 0);\n\n    const {\n      attributes = {}\n    } = opts;\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n    this.updateGeometry(opts);\n  }\n\n  updateGeometry(opts) {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    if (geometryBuffer) {\n      assert(data.startIndices);\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        buffers.positions = geometryBuffer;\n      }\n    }\n\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      for (const dataRange of dataChanged) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({\n    startRow,\n    endRow\n  }) {\n    this._rebuildGeometry({\n      startRow,\n      endRow\n    });\n  }\n\n  getGeometryFromBuffer(geometryBuffer) {\n    const value = geometryBuffer.value || geometryBuffer;\n\n    if (!ArrayBuffer.isView(value)) {\n      return null;\n    }\n\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: geometryBuffer.offset,\n      stride: geometryBuffer.stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  _allocate(instanceCount, copy) {\n    const {\n      attributes,\n      buffers,\n      _attributeDefs,\n      typedArrayManager\n    } = this;\n\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        def.copy = copy;\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  _forEachGeometry(visitor, startRow, endRow) {\n    const {\n      data,\n      getGeometry\n    } = this;\n    const {\n      iterable,\n      objectInfo\n    } = createIterable(data, startRow, endRow);\n\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry ? getGeometry(object, objectInfo) : null;\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  _rebuildGeometry(dataRange) {\n    if (!this.data) {\n      return;\n    }\n\n    let {\n      indexStarts,\n      vertexStarts,\n      instanceCount\n    } = this;\n    const {\n      data,\n      geometryBuffer\n    } = this;\n    const {\n      startRow = 0,\n      endRow = Infinity\n    } = dataRange || {};\n    const normalizedData = {};\n\n    if (!dataRange) {\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry((geometry, dataIndex) => {\n        const normalizedGeometry = geometry && this.normalizeGeometry(geometry);\n        normalizedData[dataIndex] = normalizedGeometry;\n        vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);\n      }, startRow, endRow);\n\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else {\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || 0;\n\n      if (ArrayBuffer.isView(geometryBuffer)) {\n        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;\n      } else if (geometryBuffer instanceof Buffer) {\n        const byteStride = geometryBuffer.accessor.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;\n      } else if (geometryBuffer.buffer) {\n        const byteStride = geometryBuffer.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;\n      } else if (geometryBuffer.value) {\n        const bufferValue = geometryBuffer.value;\n        const elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n        instanceCount = instanceCount || bufferValue.length / elementStride;\n      }\n    }\n\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n    const context = {};\n\n    this._forEachGeometry((geometry, dataIndex) => {\n      const normalizedGeometry = normalizedData[dataIndex] || geometry;\n      context.vertexStart = vertexStarts[dataIndex];\n      context.indexStart = indexStarts[dataIndex];\n      const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n      context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n      context.geometryIndex = dataIndex;\n      this.updateGeometryAttributes(normalizedGeometry, context);\n    }, startRow, endRow);\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n\n}\n//# sourceMappingURL=tesselator.js.map","export function push(target, source) {\n  const size = source.length;\n  const startIndex = target.length;\n\n  if (startIndex > 0) {\n    let isDuplicate = true;\n\n    for (let i = 0; i < size; i++) {\n      if (target[startIndex - size + i] !== source[i]) {\n        isDuplicate = false;\n        break;\n      }\n    }\n\n    if (isDuplicate) {\n      return false;\n    }\n  }\n\n  for (let i = 0; i < size; i++) {\n    target[startIndex + i] = source[i];\n  }\n\n  return true;\n}\nexport function copy(target, source) {\n  const size = source.length;\n\n  for (let i = 0; i < size; i++) {\n    target[i] = source[i];\n  }\n}\nexport function getPointAtIndex(positions, index, size, offset, out = []) {\n  const startI = offset + index * size;\n\n  for (let i = 0; i < size; i++) {\n    out[i] = positions[startI + i];\n  }\n\n  return out;\n}\n//# sourceMappingURL=utils.js.map","import { push, copy, getPointAtIndex } from './utils';\nexport function clipPolyline(positions, bbox, options) {\n  const {\n    size = 2,\n    startIndex = 0,\n    endIndex = positions.length\n  } = options || {};\n  const numPoints = (endIndex - startIndex) / size;\n  const result = [];\n  let part = [];\n  let a;\n  let b;\n  let codeA = -1;\n  let codeB;\n  let lastCode;\n\n  for (let i = 1; i < numPoints; i++) {\n    a = getPointAtIndex(positions, i - 1, size, startIndex, a);\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n\n    if (codeA < 0) {\n      codeA = bitCode(a, bbox);\n    }\n\n    codeB = lastCode = bitCode(b, bbox);\n\n    while (true) {\n      if (!(codeA | codeB)) {\n        push(part, a);\n\n        if (codeB !== lastCode) {\n          push(part, b);\n\n          if (i < numPoints - 1) {\n            result.push(part);\n            part = [];\n          }\n        } else if (i === numPoints - 1) {\n          push(part, b);\n        }\n\n        break;\n      } else if (codeA & codeB) {\n        break;\n      } else if (codeA) {\n        intersect(a, b, codeA, bbox, a);\n        codeA = bitCode(a, bbox);\n      } else {\n        intersect(a, b, codeB, bbox, b);\n        codeB = bitCode(b, bbox);\n      }\n    }\n\n    codeA = lastCode;\n  }\n\n  if (part.length) result.push(part);\n  return result;\n}\nexport function clipPolygon(positions, bbox, options) {\n  const {\n    size = 2,\n    endIndex = positions.length\n  } = options || {};\n  let {\n    startIndex = 0\n  } = options || {};\n  let numPoints = (endIndex - startIndex) / size;\n  let result;\n  let p;\n  let prev;\n  let inside;\n  let prevInside;\n\n  for (let edge = 1; edge <= 8; edge *= 2) {\n    result = [];\n    prev = getPointAtIndex(positions, numPoints - 1, size, startIndex, prev);\n    prevInside = !(bitCode(prev, bbox) & edge);\n\n    for (let i = 0; i < numPoints; i++) {\n      p = getPointAtIndex(positions, i, size, startIndex, p);\n      inside = !(bitCode(p, bbox) & edge);\n      if (inside !== prevInside) push(result, intersect(prev, p, edge, bbox));\n      if (inside) push(result, p);\n      copy(prev, p);\n      prevInside = inside;\n    }\n\n    positions = result;\n    startIndex = 0;\n    numPoints = result.length / size;\n    if (!numPoints) break;\n  }\n\n  return result;\n}\nexport function intersect(a, b, edge, bbox, out = []) {\n  let t;\n  let snap;\n\n  if (edge & 8) {\n    t = (bbox[3] - a[1]) / (b[1] - a[1]);\n    snap = 3;\n  } else if (edge & 4) {\n    t = (bbox[1] - a[1]) / (b[1] - a[1]);\n    snap = 1;\n  } else if (edge & 2) {\n    t = (bbox[2] - a[0]) / (b[0] - a[0]);\n    snap = 2;\n  } else if (edge & 1) {\n    t = (bbox[0] - a[0]) / (b[0] - a[0]);\n    snap = 0;\n  } else {\n    return null;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    out[i] = (snap & 1) === i ? bbox[snap] : t * (b[i] - a[i]) + a[i];\n  }\n\n  return out;\n}\nexport function bitCode(p, bbox) {\n  let code = 0;\n  if (p[0] < bbox[0]) code |= 1;else if (p[0] > bbox[2]) code |= 2;\n  if (p[1] < bbox[1]) code |= 4;else if (p[1] > bbox[3]) code |= 8;\n  return code;\n}\n//# sourceMappingURL=lineclip.js.map","import { bitCode, intersect } from './lineclip';\nimport { getPointAtIndex, copy, push } from './utils';\nexport function cutPolylineByGrid(positions, options) {\n  const {\n    size = 2,\n    broken = false,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    startIndex = 0,\n    endIndex = positions.length\n  } = options || {};\n  const numPoints = (endIndex - startIndex) / size;\n  let part = [];\n  const result = [part];\n  const a = getPointAtIndex(positions, 0, size, startIndex);\n  let b;\n  let codeB;\n  const cell = getGridCell(a, gridResolution, gridOffset, []);\n  const scratchPoint = [];\n  push(part, a);\n\n  for (let i = 1; i < numPoints; i++) {\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n    codeB = bitCode(b, cell);\n\n    while (codeB) {\n      intersect(a, b, codeB, cell, scratchPoint);\n      const codeAlt = bitCode(scratchPoint, cell);\n\n      if (codeAlt) {\n        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);\n        codeB = codeAlt;\n      }\n\n      push(part, scratchPoint);\n      copy(a, scratchPoint);\n      moveToNeighborCell(cell, gridResolution, codeB);\n\n      if (broken && part.length > size) {\n        part = [];\n        result.push(part);\n        push(part, a);\n      }\n\n      codeB = bitCode(b, cell);\n    }\n\n    push(part, b);\n    copy(a, b);\n  }\n\n  return broken ? result : result[0];\n}\nconst TYPE_INSIDE = 0;\nconst TYPE_BORDER = 1;\n\nfunction concatInPlace(arr1, arr2) {\n  for (let i = 0; i < arr2.length; i++) {\n    arr1.push(arr2[i]);\n  }\n\n  return arr1;\n}\n\nexport function cutPolygonByGrid(positions, holeIndices = null, options) {\n  if (!positions.length) {\n    return [];\n  }\n\n  const {\n    size = 2,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    edgeTypes = false\n  } = options || {};\n  const result = [];\n  const queue = [{\n    pos: positions,\n    types: edgeTypes ? new Array(positions.length / size).fill(TYPE_BORDER) : null,\n    holes: holeIndices || []\n  }];\n  const bbox = [[], []];\n  let cell = [];\n\n  while (queue.length) {\n    const {\n      pos,\n      types,\n      holes\n    } = queue.shift();\n    getBoundingBox(pos, size, holes[0] || pos.length, bbox);\n    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);\n    const code = bitCode(bbox[1], cell);\n\n    if (code) {\n      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);\n      const polygonLow = {\n        pos: parts[0].pos,\n        types: parts[0].types,\n        holes: []\n      };\n      const polygonHigh = {\n        pos: parts[1].pos,\n        types: parts[1].types,\n        holes: []\n      };\n      queue.push(polygonLow, polygonHigh);\n\n      for (let i = 0; i < holes.length; i++) {\n        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);\n\n        if (parts[0]) {\n          polygonLow.holes.push(polygonLow.pos.length);\n          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);\n\n          if (edgeTypes) {\n            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);\n          }\n        }\n\n        if (parts[1]) {\n          polygonHigh.holes.push(polygonHigh.pos.length);\n          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);\n\n          if (edgeTypes) {\n            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);\n          }\n        }\n      }\n    } else {\n      const polygon = {\n        positions: pos\n      };\n\n      if (edgeTypes) {\n        polygon.edgeTypes = types;\n      }\n\n      if (holes.length) {\n        polygon.holeIndices = holes;\n      }\n\n      result.push(polygon);\n    }\n  }\n\n  return result;\n}\n\nfunction bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {\n  const numPoints = (endIndex - startIndex) / size;\n  const resultLow = [];\n  const resultHigh = [];\n  const typesLow = [];\n  const typesHigh = [];\n  const scratchPoint = [];\n  let p;\n  let side;\n  let type;\n  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);\n  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);\n  let prevType = edgeTypes && edgeTypes[numPoints - 1];\n  let lowPointCount = 0;\n  let highPointCount = 0;\n\n  for (let i = 0; i < numPoints; i++) {\n    p = getPointAtIndex(positions, i, size, startIndex, p);\n    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);\n    type = edgeTypes && edgeTypes[startIndex / size + i];\n\n    if (side && prevSide && prevSide !== side) {\n      intersect(prev, p, edge, bbox, scratchPoint);\n      push(resultLow, scratchPoint) && typesLow.push(prevType);\n      push(resultHigh, scratchPoint) && typesHigh.push(prevType);\n    }\n\n    if (side <= 0) {\n      push(resultLow, p) && typesLow.push(type);\n      lowPointCount -= side;\n    } else if (typesLow.length) {\n      typesLow[typesLow.length - 1] = TYPE_INSIDE;\n    }\n\n    if (side >= 0) {\n      push(resultHigh, p) && typesHigh.push(type);\n      highPointCount += side;\n    } else if (typesHigh.length) {\n      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;\n    }\n\n    copy(prev, p);\n    prevSide = side;\n    prevType = type;\n  }\n\n  return [lowPointCount ? {\n    pos: resultLow,\n    types: edgeTypes && typesLow\n  } : null, highPointCount ? {\n    pos: resultHigh,\n    types: edgeTypes && typesHigh\n  } : null];\n}\n\nfunction getGridCell(p, gridResolution, gridOffset, out) {\n  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];\n  const bottom = Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];\n  out[0] = left;\n  out[1] = bottom;\n  out[2] = left + gridResolution;\n  out[3] = bottom + gridResolution;\n  return out;\n}\n\nfunction moveToNeighborCell(cell, gridResolution, edge) {\n  if (edge & 8) {\n    cell[1] += gridResolution;\n    cell[3] += gridResolution;\n  } else if (edge & 4) {\n    cell[1] -= gridResolution;\n    cell[3] -= gridResolution;\n  } else if (edge & 2) {\n    cell[0] += gridResolution;\n    cell[2] += gridResolution;\n  } else if (edge & 1) {\n    cell[0] -= gridResolution;\n    cell[2] -= gridResolution;\n  }\n}\n\nfunction getBoundingBox(positions, size, endIndex, out) {\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  for (let i = 0; i < endIndex; i += size) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    minX = x < minX ? x : minX;\n    maxX = x > maxX ? x : maxX;\n    minY = y < minY ? y : minY;\n    maxY = y > maxY ? y : maxY;\n  }\n\n  out[0][0] = minX;\n  out[0][1] = minY;\n  out[1][0] = maxX;\n  out[1][1] = maxY;\n  return out;\n}\n//# sourceMappingURL=cut-by-grid.js.map","import { cutPolylineByGrid, cutPolygonByGrid } from './cut-by-grid';\nimport { getPointAtIndex, push } from './utils';\nconst DEFAULT_MAX_LATITUDE = 85.051129;\nexport function cutPolylineByMercatorBounds(positions, options) {\n  const {\n    size = 2,\n    startIndex = 0,\n    endIndex = positions.length,\n    normalize = true\n  } = options || {};\n  const newPositions = positions.slice(startIndex, endIndex);\n  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);\n  const parts = cutPolylineByGrid(newPositions, {\n    size,\n    broken: true,\n    gridResolution: 360,\n    gridOffset: [-180, -180]\n  });\n\n  if (normalize) {\n    for (const part of parts) {\n      shiftLongitudesIntoRange(part, size);\n    }\n  }\n\n  return parts;\n}\nexport function cutPolygonByMercatorBounds(positions, holeIndices = null, options) {\n  const {\n    size = 2,\n    normalize = true,\n    edgeTypes = false\n  } = options || {};\n  holeIndices = holeIndices || [];\n  const newPositions = [];\n  const newHoleIndices = [];\n  let srcStartIndex = 0;\n  let targetIndex = 0;\n\n  for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {\n    const srcEndIndex = holeIndices[ringIndex] || positions.length;\n    const targetStartIndex = targetIndex;\n    const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);\n\n    for (let i = splitIndex; i < srcEndIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n\n    for (let i = srcStartIndex; i < splitIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n\n    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);\n    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options === null || options === void 0 ? void 0 : options.maxLatitude);\n    srcStartIndex = srcEndIndex;\n    newHoleIndices[ringIndex] = targetIndex;\n  }\n\n  newHoleIndices.pop();\n  const parts = cutPolygonByGrid(newPositions, newHoleIndices, {\n    size,\n    gridResolution: 360,\n    gridOffset: [-180, -180],\n    edgeTypes\n  });\n\n  if (normalize) {\n    for (const part of parts) {\n      shiftLongitudesIntoRange(part.positions, size);\n    }\n  }\n\n  return parts;\n}\n\nfunction findSplitIndex(positions, size, startIndex, endIndex) {\n  let maxLat = -1;\n  let pointIndex = -1;\n\n  for (let i = startIndex + 1; i < endIndex; i += size) {\n    const lat = Math.abs(positions[i]);\n\n    if (lat > maxLat) {\n      maxLat = lat;\n      pointIndex = i - 1;\n    }\n  }\n\n  return pointIndex;\n}\n\nfunction insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {\n  const firstLng = positions[startIndex];\n  const lastLng = positions[endIndex - size];\n\n  if (Math.abs(firstLng - lastLng) > 180) {\n    const p = getPointAtIndex(positions, 0, size, startIndex);\n    p[0] += Math.round((lastLng - firstLng) / 360) * 360;\n    push(positions, p);\n    p[1] = Math.sign(p[1]) * maxLatitude;\n    push(positions, p);\n    p[0] = firstLng;\n    push(positions, p);\n  }\n}\n\nfunction wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {\n  let prevLng = positions[0];\n  let lng;\n\n  for (let i = startIndex; i < endIndex; i += size) {\n    lng = positions[i];\n    const delta = lng - prevLng;\n\n    if (delta > 180 || delta < -180) {\n      lng -= Math.round(delta / 360) * 360;\n    }\n\n    positions[i] = prevLng = lng;\n  }\n}\n\nfunction shiftLongitudesIntoRange(positions, size) {\n  let refLng;\n  const pointCount = positions.length / size;\n\n  for (let i = 0; i < pointCount; i++) {\n    refLng = positions[i * size];\n\n    if ((refLng + 180) % 360 !== 0) {\n      break;\n    }\n  }\n\n  const delta = -Math.round(refLng / 360) * 360;\n\n  if (delta === 0) {\n    return;\n  }\n\n  for (let i = 0; i < pointCount; i++) {\n    positions[i * size] += delta;\n  }\n}\n//# sourceMappingURL=cut-by-mercator-bounds.js.map","import { cutPolylineByGrid, cutPolylineByMercatorBounds } from '@math.gl/polygon';\nexport function normalizePath(path, size, gridResolution, wrapLongitude) {\n  let flatPath;\n\n  if (Array.isArray(path[0])) {\n    const length = path.length * size;\n    flatPath = new Array(length);\n\n    for (let i = 0; i < path.length; i++) {\n      for (let j = 0; j < size; j++) {\n        flatPath[i * size + j] = path[i][j] || 0;\n      }\n    }\n  } else {\n    flatPath = path;\n  }\n\n  if (gridResolution) {\n    return cutPolylineByGrid(flatPath, {\n      size,\n      gridResolution\n    });\n  }\n\n  if (wrapLongitude) {\n    return cutPolylineByMercatorBounds(flatPath, {\n      size\n    });\n  }\n\n  return flatPath;\n}\n//# sourceMappingURL=path.js.map","import { Tesselator } from '@deck.gl/core';\nimport { normalizePath } from './path';\nconst START_CAP = 1;\nconst END_CAP = 2;\nconst INVALID = 4;\nexport default class PathTesselator extends Tesselator {\n  constructor(opts) {\n    super({ ...opts,\n      attributes: {\n        positions: {\n          size: 3,\n          padding: 18,\n          initialize: true,\n          type: opts.fp64 ? Float64Array : Float32Array\n        },\n        segmentTypes: {\n          size: 1,\n          type: Uint8ClampedArray\n        }\n      }\n    });\n  }\n\n  get(attributeName) {\n    return this.attributes[attributeName];\n  }\n\n  getGeometryFromBuffer(buffer) {\n    if (this.normalize) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n\n    return null;\n  }\n\n  normalizeGeometry(path) {\n    if (this.normalize) {\n      return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);\n    }\n\n    return path;\n  }\n\n  getGeometrySize(path) {\n    if (isCut(path)) {\n      let size = 0;\n\n      for (const subPath of path) {\n        size += this.getGeometrySize(subPath);\n      }\n\n      return size;\n    }\n\n    const numPoints = this.getPathLength(path);\n\n    if (numPoints < 2) {\n      return 0;\n    }\n\n    if (this.isClosed(path)) {\n      return numPoints < 3 ? 0 : numPoints + 2;\n    }\n\n    return numPoints;\n  }\n\n  updateGeometryAttributes(path, context) {\n    if (context.geometrySize === 0) {\n      return;\n    }\n\n    if (path && isCut(path)) {\n      for (const subPath of path) {\n        const geometrySize = this.getGeometrySize(subPath);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPath, context);\n        context.vertexStart += geometrySize;\n      }\n    } else {\n      this._updateSegmentTypes(path, context);\n\n      this._updatePositions(path, context);\n    }\n  }\n\n  _updateSegmentTypes(path, context) {\n    const segmentTypes = this.attributes.segmentTypes;\n    const isPathClosed = path ? this.isClosed(path) : false;\n    const {\n      vertexStart,\n      geometrySize\n    } = context;\n    segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);\n\n    if (isPathClosed) {\n      segmentTypes[vertexStart] = INVALID;\n      segmentTypes[vertexStart + geometrySize - 2] = INVALID;\n    } else {\n      segmentTypes[vertexStart] += START_CAP;\n      segmentTypes[vertexStart + geometrySize - 2] += END_CAP;\n    }\n\n    segmentTypes[vertexStart + geometrySize - 1] = INVALID;\n  }\n\n  _updatePositions(path, context) {\n    const {\n      positions\n    } = this.attributes;\n\n    if (!positions || !path) {\n      return;\n    }\n\n    const {\n      vertexStart,\n      geometrySize\n    } = context;\n    const p = new Array(3);\n\n    for (let i = vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {\n      this.getPointOnPath(path, ptIndex, p);\n      positions[i * 3] = p[0];\n      positions[i * 3 + 1] = p[1];\n      positions[i * 3 + 2] = p[2];\n    }\n  }\n\n  getPathLength(path) {\n    return path.length / this.positionSize;\n  }\n\n  getPointOnPath(path, index, target = []) {\n    const {\n      positionSize\n    } = this;\n\n    if (index * positionSize >= path.length) {\n      index += 1 - path.length / positionSize;\n    }\n\n    const i = index * positionSize;\n    target[0] = path[i];\n    target[1] = path[i + 1];\n    target[2] = positionSize === 3 && path[i + 2] || 0;\n    return target;\n  }\n\n  isClosed(path) {\n    if (!this.normalize) {\n      return Boolean(this.opts.loop);\n    }\n\n    const {\n      positionSize\n    } = this;\n    const lastPointIndex = path.length - positionSize;\n    return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);\n  }\n\n}\n\nfunction isCut(path) {\n  return Array.isArray(path[0]);\n}\n//# sourceMappingURL=path-tesselator.js.map","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Layer, project32, picking, UNIT } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/core';\nimport PathTesselator from './path-tesselator';\nimport vs from './path-layer-vertex.glsl';\nimport fs from './path-layer-fragment.glsl';\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  widthUnits: 'meters',\n  widthScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  widthMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  widthMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  jointRounded: false,\n  capRounded: false,\n  miterLimit: {\n    type: 'number',\n    min: 0,\n    value: 4\n  },\n  billboard: false,\n  _pathType: null,\n  getPath: {\n    type: 'accessor',\n    value: object => object.path\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getWidth: {\n    type: 'accessor',\n    value: 1\n  },\n  rounded: {\n    deprecatedFor: ['jointRounded', 'capRounded']\n  }\n};\nconst ATTRIBUTE_TRANSITION = {\n  enter: (value, chunk) => {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\nexport default class PathLayer extends Layer {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", void 0);\n  }\n\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, picking]\n    });\n  }\n\n  get wrapLongitude() {\n    return false;\n  }\n\n  initializeState() {\n    const noAlloc = true;\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      positions: {\n        size: 3,\n        vertexOffset: 1,\n        type: 5130,\n        fp64: this.use64bitPositions(),\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getPath',\n        update: this.calculatePositions,\n        noAlloc,\n        shaderAttributes: {\n          instanceLeftPositions: {\n            vertexOffset: 0\n          },\n          instanceStartPositions: {\n            vertexOffset: 1\n          },\n          instanceEndPositions: {\n            vertexOffset: 2\n          },\n          instanceRightPositions: {\n            vertexOffset: 3\n          }\n        }\n      },\n      instanceTypes: {\n        size: 1,\n        type: 5121,\n        update: this.calculateSegmentTypes,\n        noAlloc\n      },\n      instanceStrokeWidths: {\n        size: 1,\n        accessor: 'getWidth',\n        transition: ATTRIBUTE_TRANSITION,\n        defaultValue: 1\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: 5121,\n        normalized: true,\n        accessor: 'getColor',\n        transition: ATTRIBUTE_TRANSITION,\n        defaultValue: DEFAULT_COLOR\n      },\n      instancePickingColors: {\n        size: 3,\n        type: 5121,\n        accessor: (object, {\n          index,\n          target: value\n        }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)\n      }\n    });\n    this.setState({\n      pathTesselator: new PathTesselator({\n        fp64: this.use64bitPositions()\n      })\n    });\n  }\n\n  updateState(params) {\n    super.updateState(params);\n    const {\n      props,\n      changeFlags\n    } = params;\n    const attributeManager = this.getAttributeManager();\n    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);\n\n    if (geometryChanged) {\n      const {\n        pathTesselator\n      } = this.state;\n      const buffers = props.data.attributes || {};\n      pathTesselator.updateGeometry({\n        data: props.data,\n        geometryBuffer: buffers.getPath,\n        buffers,\n        normalize: !props._pathType,\n        loop: props._pathType === 'loop',\n        getGeometry: props.getPath,\n        positionFormat: props.positionFormat,\n        wrapLongitude: props.wrapLongitude,\n        resolution: this.context.viewport.resolution,\n        dataChanged: changeFlags.dataChanged\n      });\n      this.setState({\n        numInstances: pathTesselator.instanceCount,\n        startIndices: pathTesselator.vertexStarts\n      });\n\n      if (!changeFlags.dataChanged) {\n        attributeManager.invalidateAll();\n      }\n    }\n\n    if (changeFlags.extensionsChanged) {\n      var _this$state$model;\n\n      const {\n        gl\n      } = this.context;\n      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();\n      this.state.model = this._getModel(gl);\n      attributeManager.invalidateAll();\n    }\n  }\n\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    const {\n      index\n    } = info;\n    const {\n      data\n    } = this.props;\n\n    if (data[0] && data[0].__source) {\n      info.object = data.find(d => d.__source.index === index);\n    }\n\n    return info;\n  }\n\n  disablePickingIndex(objectIndex) {\n    const {\n      data\n    } = this.props;\n\n    if (data[0] && data[0].__source) {\n      for (let i = 0; i < data.length; i++) {\n        if (data[i].__source.index === objectIndex) {\n          this._disablePickingIndex(i);\n        }\n      }\n    } else {\n      this._disablePickingIndex(objectIndex);\n    }\n  }\n\n  draw({\n    uniforms\n  }) {\n    const {\n      jointRounded,\n      capRounded,\n      billboard,\n      miterLimit,\n      widthUnits,\n      widthScale,\n      widthMinPixels,\n      widthMaxPixels\n    } = this.props;\n    this.state.model.setUniforms(uniforms).setUniforms({\n      jointType: Number(jointRounded),\n      capType: Number(capRounded),\n      billboard,\n      widthUnits: UNIT[widthUnits],\n      widthScale,\n      miterLimit,\n      widthMinPixels,\n      widthMaxPixels\n    }).draw();\n  }\n\n  _getModel(gl) {\n    const SEGMENT_INDICES = [0, 1, 2, 1, 4, 2, 1, 3, 4, 3, 5, 4];\n    const SEGMENT_POSITIONS = [0, 0, 0, -1, 0, 1, 1, -1, 1, 1, 1, 0];\n    return new Model(gl, { ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: 4,\n        attributes: {\n          indices: new Uint16Array(SEGMENT_INDICES),\n          positions: {\n            value: new Float32Array(SEGMENT_POSITIONS),\n            size: 2\n          }\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  calculatePositions(attribute) {\n    const {\n      pathTesselator\n    } = this.state;\n    attribute.startIndices = pathTesselator.vertexStarts;\n    attribute.value = pathTesselator.get('positions');\n  }\n\n  calculateSegmentTypes(attribute) {\n    const {\n      pathTesselator\n    } = this.state;\n    attribute.startIndices = pathTesselator.vertexStarts;\n    attribute.value = pathTesselator.get('segmentTypes');\n  }\n\n}\n\n_defineProperty(PathLayer, \"defaultProps\", defaultProps);\n\n_defineProperty(PathLayer, \"layerName\", 'PathLayer');\n//# sourceMappingURL=path-layer.js.map","export default \"#define SHADER_NAME path-layer-vertex-shader\\n\\nattribute vec2 positions;\\n\\nattribute float instanceTypes;\\nattribute vec3 instanceStartPositions;\\nattribute vec3 instanceEndPositions;\\nattribute vec3 instanceLeftPositions;\\nattribute vec3 instanceRightPositions;\\nattribute vec3 instanceLeftPositions64Low;\\nattribute vec3 instanceStartPositions64Low;\\nattribute vec3 instanceEndPositions64Low;\\nattribute vec3 instanceRightPositions64Low;\\nattribute float instanceStrokeWidths;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\n\\nuniform float widthScale;\\nuniform float widthMinPixels;\\nuniform float widthMaxPixels;\\nuniform float jointType;\\nuniform float capType;\\nuniform float miterLimit;\\nuniform bool billboard;\\nuniform int widthUnits;\\n\\nuniform float opacity;\\n\\nvarying vec4 vColor;\\nvarying vec2 vCornerOffset;\\nvarying float vMiterLength;\\nvarying vec2 vPathPosition;\\nvarying float vPathLength;\\nvarying float vJointType;\\n\\nconst float EPSILON = 0.001;\\nconst vec3 ZERO_OFFSET = vec3(0.0);\\n\\nfloat flipIfTrue(bool flag) {\\n  return -(float(flag) * 2. - 1.);\\n}\\n\\n// calculate line join positions\\nvec3 lineJoin(\\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\\n  vec2 width\\n) {\\n  bool isEnd = positions.x > 0.0;\\n  // side of the segment - -1: left, 0: center, 1: right\\n  float sideOfPath = positions.y;\\n  float isJoint = float(sideOfPath == 0.0);\\n\\n  vec3 deltaA3 = (currPoint - prevPoint);\\n  vec3 deltaB3 = (nextPoint - currPoint);\\n\\n  mat3 rotationMatrix;\\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\\n  if (needsRotation) {\\n    deltaA3 = deltaA3 * rotationMatrix;\\n    deltaB3 = deltaB3 * rotationMatrix;\\n  }\\n  vec2 deltaA = deltaA3.xy / width;\\n  vec2 deltaB = deltaB3.xy / width;\\n\\n  float lenA = length(deltaA);\\n  float lenB = length(deltaB);\\n\\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\\n\\n  vec2 perpA = vec2(-dirA.y, dirA.x);\\n  vec2 perpB = vec2(-dirB.y, dirB.x);\\n\\n  // tangent of the corner\\n  vec2 tangent = dirA + dirB;\\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\\n  // direction of the corner\\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\\n  // direction of the segment\\n  vec2 dir = isEnd ? dirA : dirB;\\n  // direction of the extrusion\\n  vec2 perp = isEnd ? perpA : perpB;\\n  // length of the segment\\n  float L = isEnd ? lenA : lenB;\\n\\n  // A = angle of the corner\\n  float sinHalfA = abs(dot(miterVec, perp));\\n  float cosHalfA = abs(dot(dirA, miterVec));\\n\\n  // -1: right, 1: left\\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\\n\\n  // relative position to the corner:\\n  // -1: inside (smaller side of the angle)\\n  // 0: center\\n  // 1: outside (bigger side of the angle)\\n  float cornerPosition = sideOfPath * turnDirection;\\n\\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\\n  // trim if inside corner extends further than the line segment\\n  miterSize = mix(\\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\\n    miterSize,\\n    step(0.0, cornerPosition)\\n  );\\n\\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\\n    * (sideOfPath + isJoint * turnDirection);\\n\\n  // special treatment for start cap and end cap\\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\\n  bool isCap = isStartCap || isEndCap;\\n\\n  // extend out a triangle to envelope the round cap\\n  if (isCap) {\\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\\n    vJointType = capType;\\n  } else {\\n    vJointType = jointType;\\n  }\\n\\n  // Generate variables for fragment shader\\n  vPathLength = L;\\n  vCornerOffset = offsetVec;\\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\\n  vMiterLength = isCap ? isJoint : vMiterLength;\\n\\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\\n  vPathPosition = vec2(\\n    dot(offsetFromStartOfPath, perp),\\n    dot(offsetFromStartOfPath, dir)\\n  );\\n  geometry.uv = vPathPosition;\\n\\n  float isValid = step(instanceTypes, 3.5);\\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\\n\\n  if (needsRotation) {\\n    offset = rotationMatrix * offset;\\n  }\\n  return currPoint + offset;\\n}\\n\\n// In clipspace extrusion, if a line extends behind the camera, clip it to avoid visual artifacts\\nvoid clipLine(inout vec4 position, vec4 refPosition) {\\n  if (position.w < EPSILON) {\\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\\n    position = refPosition + (position - refPosition) * r;\\n  }\\n}\\n\\nvoid main() {\\n  geometry.pickingColor = instancePickingColors;\\n\\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\\n\\n  float isEnd = positions.x;\\n\\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\\n\\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\\n\\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\\n\\n  geometry.worldPosition = currPosition;\\n  vec2 widthPixels = vec2(clamp(\\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\\n    widthMinPixels, widthMaxPixels) / 2.0);\\n  vec3 width;\\n\\n  if (billboard) {\\n    // Extrude in clipspace\\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\\n\\n    clipLine(prevPositionScreen, currPositionScreen);\\n    clipLine(nextPositionScreen, currPositionScreen);\\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\\n\\n    width = vec3(widthPixels, 0.0);\\n    DECKGL_FILTER_SIZE(width, geometry);\\n\\n    vec3 pos = lineJoin(\\n      prevPositionScreen.xyz / prevPositionScreen.w,\\n      currPositionScreen.xyz / currPositionScreen.w,\\n      nextPositionScreen.xyz / nextPositionScreen.w,\\n      project_pixel_size_to_clipspace(width.xy)\\n    );\\n\\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\\n  } else {\\n    // Extrude in commonspace\\n    prevPosition = project_position(prevPosition, prevPosition64Low);\\n    currPosition = project_position(currPosition, currPosition64Low);\\n    nextPosition = project_position(nextPosition, nextPosition64Low);\\n\\n    width = vec3(project_pixel_size(widthPixels), 0.0);\\n    DECKGL_FILTER_SIZE(width, geometry);\\n\\n    vec4 pos = vec4(\\n      lineJoin(prevPosition, currPosition, nextPosition, width.xy),\\n      1.0);\\n    geometry.position = pos;\\n    gl_Position = project_common_position_to_clipspace(pos);\\n  }\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n  DECKGL_FILTER_COLOR(vColor, geometry);\\n}\\n\";\n//# sourceMappingURL=path-layer-vertex.glsl.js.map","export default \"#define SHADER_NAME path-layer-fragment-shader\\n\\nprecision highp float;\\n\\nuniform float miterLimit;\\n\\nvarying vec4 vColor;\\nvarying vec2 vCornerOffset;\\nvarying float vMiterLength;\\n/*\\n * vPathPosition represents the relative coordinates of the current fragment on the path segment.\\n * vPathPosition.x - position along the width of the path, between [-1, 1]. 0 is the center line.\\n * vPathPosition.y - position along the length of the path, between [0, L / width].\\n */\\nvarying vec2 vPathPosition;\\nvarying float vPathLength;\\nvarying float vJointType;\\n\\nvoid main(void) {\\n  geometry.uv = vPathPosition;\\n\\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\\n    // if joint is rounded, test distance from the corner\\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\\n      discard;\\n    }\\n    // trim miter\\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\\n      discard;\\n    }\\n  }\\n  gl_FragColor = vColor;\\n\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\";\n//# sourceMappingURL=path-layer-fragment.glsl.js.map"],"names":["Tesselator","constructor","opts","_defineProperty","this","attributes","typedArrayManager","defaultTypedArrayManager","_attributeDefs","updateGeometry","Object","assign","data","buffers","getGeometry","geometryBuffer","positionFormat","dataChanged","normalize","positionSize","size","assert","startIndices","getGeometryFromBuffer","positions","Array","isArray","dataRange","_rebuildGeometry","updatePartialGeometry","startRow","endRow","value","ArrayBuffer","isView","getAccessorFromBuffer","offset","stride","_allocate","instanceCount","copy2","name","release","def","copy","allocate","_forEachGeometry","visitor","iterable","objectInfo","createIterable","object","index","indexStarts","vertexStarts","Infinity","normalizedData","geometry","dataIndex","normalizedGeometry","normalizeGeometry","getGeometrySize","length","Buffer2","byteStride","accessor","byteLength","buffer","bufferValue","elementStride","BYTES_PER_ELEMENT","Boolean","context","vertexStart","indexStart","vertexEnd","geometrySize","geometryIndex","updateGeometryAttributes","vertexCount","push","target","source","startIndex","isDuplicate","i","getPointAtIndex","out","startI","intersect","a","b","edge","bbox","t","snap","bitCode","p","code","cutPolylineByGrid","options","broken","gridResolution","gridOffset","endIndex","numPoints","part","result","codeB","cell","getGridCell","scratchPoint","codeAlt","moveToNeighborCell","concatInPlace","arr1","arr2","cutPolygonByGrid","holeIndices","edgeTypes","queue","pos","types","fill","holes","shift","getBoundingBox","parts","bisectPolygon","polygonLow","polygonHigh","polygon","resultLow","resultHigh","typesLow","typesHigh","side","type","prev","prevSide","Math","sign","prevType","lowPointCount","highPointCount","left","floor","bottom","minX","maxX","minY","maxY","x","y","cutPolygonByMercatorBounds","newPositions","newHoleIndices","srcStartIndex","targetIndex","ringIndex","srcEndIndex","targetStartIndex","splitIndex","findSplitIndex","wrapLongitudesForShortestPath","insertPoleVertices","maxLatitude","pop","shiftLongitudesIntoRange","maxLat","pointIndex","lat","abs","firstLng","lastLng","round","lng","prevLng","delta","refLng","pointCount","normalizePath","path","wrapLongitude","flatPath","j","slice","cutPolylineByMercatorBounds","PathTesselator","super","__spreadProps","padding","initialize","fp64","Float64Array","Float32Array","segmentTypes","Uint8ClampedArray","get","attributeName","resolution","isCut","subPath","getPathLength","isClosed","_updateSegmentTypes","_updatePositions","isPathClosed","ptIndex","getPointOnPath","loop","lastPointIndex","DEFAULT_COLOR","defaultProps","widthUnits","widthScale","min","widthMinPixels","widthMaxPixels","Number","MAX_SAFE_INTEGER","jointRounded","capRounded","miterLimit","billboard","_pathType","getPath","getColor","getWidth","rounded","deprecatedFor","ATTRIBUTE_TRANSITION","enter","chunk","subarray","PathLayer","Layer","args","getShaders","vs","fs","modules","project32","picking","initializeState","getAttributeManager","addInstanced","vertexOffset","use64bitPositions","transition","update","calculatePositions","noAlloc","shaderAttributes","instanceLeftPositions","instanceStartPositions","instanceEndPositions","instanceRightPositions","instanceTypes","calculateSegmentTypes","instanceStrokeWidths","defaultValue","instanceColors","props","colorFormat","normalized","instancePickingColors","encodePickingColor","__source","setState","pathTesselator","updateState","params","changeFlags","attributeManager","updateTriggersChanged","all","state","viewport","numInstances","invalidateAll","extensionsChanged","_this$state$model","gl","model","delete","_getModel","getPickingInfo","info","find","d","disablePickingIndex","objectIndex","_disablePickingIndex","draw","uniforms","setUniforms","jointType","capType","UNIT","Model","__spreadValues","id","Geometry","drawMode","indices","Uint16Array","isInstanced","attribute"],"mappings":"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"}