var e=Object.defineProperty,t=Object.defineProperties,n=Object.getOwnPropertyDescriptors,i=Object.getOwnPropertySymbols,r=Object.prototype.hasOwnProperty,a=Object.prototype.propertyIsEnumerable,l=(t,n,i)=>n in t?e(t,n,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[n]=i,f=(e,t)=>{for(var n in t||(t={}))r.call(t,n)&&l(e,n,t[n]);if(i)for(var n of i(t))a.call(t,n)&&l(e,n,t[n]);return e},o=(e,i)=>t(e,n(i));import{Z as s,T as d,$ as u,M as _,a0 as c,a1 as m,_ as T}from"./layer.b20bd88e.js";import{L as v}from"./layer-extension.27ef9a68.js";const A="\nuniform DATAFILTER_TYPE filter_min;\nuniform DATAFILTER_TYPE filter_softMin;\nuniform DATAFILTER_TYPE filter_softMax;\nuniform DATAFILTER_TYPE filter_max;\nuniform bool filter_useSoftMargin;\nuniform bool filter_enabled;\nuniform bool filter_transformSize;\n\n#ifdef NON_INSTANCED_MODEL\n  #define DATAFILTER_ATTRIB filterValues\n  #define DATAFILTER_ATTRIB_64LOW filterValues64Low\n#else\n  #define DATAFILTER_ATTRIB instanceFilterValues\n  #define DATAFILTER_ATTRIB_64LOW instanceFilterValues64Low\n#endif\n\nattribute DATAFILTER_TYPE DATAFILTER_ATTRIB;\n#ifdef DATAFILTER_DOUBLE\n  attribute DATAFILTER_TYPE DATAFILTER_ATTRIB_64LOW;\n\n  uniform DATAFILTER_TYPE filter_min64High;\n  uniform DATAFILTER_TYPE filter_max64High;\n#endif\n\nvarying float dataFilter_value;\n\nfloat dataFilter_reduceValue(float value) {\n  return value;\n}\nfloat dataFilter_reduceValue(vec2 value) {\n  return min(value.x, value.y);\n}\nfloat dataFilter_reduceValue(vec3 value) {\n  return min(min(value.x, value.y), value.z);\n}\nfloat dataFilter_reduceValue(vec4 value) {\n  return min(min(value.x, value.y), min(value.z, value.w));\n}\nvoid dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax) {\n  if (filter_enabled) {\n    if (filter_useSoftMargin) {\n      dataFilter_value = dataFilter_reduceValue(\n        smoothstep(filter_min, filter_softMin, valueFromMin) *\n        (1.0 - smoothstep(filter_softMax, filter_max, valueFromMax))\n      );\n    } else {\n      dataFilter_value = dataFilter_reduceValue(\n        step(filter_min, valueFromMin) * step(valueFromMax, filter_max)\n      );\n    }\n  } else {\n    dataFilter_value = 1.0;\n  }\n}\n",F="\nuniform bool filter_transformColor;\nvarying float dataFilter_value;\n";function p(e){if(!e||!("extensions"in e))return{};const{filterRange:t=[-1,1],filterEnabled:n=!0,filterTransformSize:i=!0,filterTransformColor:r=!0}=e,a=e.filterSoftRange||t;return o(f({},Number.isFinite(t[0])?{filter_min:t[0],filter_softMin:a[0],filter_softMax:a[1],filter_max:t[1]}:{filter_min:t.map((e=>e[0])),filter_softMin:a.map((e=>e[0])),filter_softMax:a.map((e=>e[1])),filter_max:t.map((e=>e[1]))}),{filter_enabled:n,filter_useSoftMargin:Boolean(e.filterSoftRange),filter_transformSize:n&&i,filter_transformColor:n&&r})}const E={"vs:#main-start":"\n    #ifdef DATAFILTER_DOUBLE\n      dataFilter_setValue(\n        DATAFILTER_ATTRIB - filter_min64High + DATAFILTER_ATTRIB_64LOW,\n        DATAFILTER_ATTRIB - filter_max64High + DATAFILTER_ATTRIB_64LOW\n      );\n    #else\n      dataFilter_setValue(DATAFILTER_ATTRIB, DATAFILTER_ATTRIB);\n    #endif\n  ","vs:#main-end":"\n    if (dataFilter_value == 0.0) {\n      gl_Position = vec4(0.);\n    }\n  ","vs:DECKGL_FILTER_SIZE":"\n    if (filter_transformSize) {\n      size = size * dataFilter_value;\n    }\n  ","fs:DECKGL_FILTER_COLOR":"\n    if (dataFilter_value == 0.0) discard;\n    if (filter_transformColor) {\n      color.a *= dataFilter_value;\n    }\n  "},g={name:"data-filter",vs:A,fs:F,inject:E,getUniforms:p},I={name:"data-filter-fp64",vs:A,fs:F,inject:E,getUniforms:function(e){if(!e||!("extensions"in e))return{};const t=p(e);if(Number.isFinite(t.filter_min)){const e=Math.fround(t.filter_min);t.filter_min-=e,t.filter_softMin-=e,t.filter_min64High=e;const n=Math.fround(t.filter_max);t.filter_max-=n,t.filter_softMax-=n,t.filter_max64High=n}else{const e=t.filter_min.map(Math.fround);t.filter_min=t.filter_min.map(((t,n)=>t-e[n])),t.filter_softMin=t.filter_softMin.map(((t,n)=>t-e[n])),t.filter_min64High=e;const n=t.filter_max.map(Math.fround);t.filter_max=t.filter_max.map(((e,t)=>e-n[t])),t.filter_softMax=t.filter_softMax.map(((e,t)=>e-n[t])),t.filter_max64High=n}return t}};const h={blend:!0,blendFunc:[1,1,1,1],blendEquation:[32774,32774],depthTest:!1},x={1:"float",2:"vec2",3:"vec3",4:"vec4"};class R extends v{constructor({filterSize:e=1,fp64:t=!1,countItems:n=!1}={}){if(!x[e])throw new Error("filterSize out of range");super({filterSize:e,fp64:t,countItems:n})}getShaders(e){const{filterSize:t,fp64:n}=e.opts;return{modules:[n?I:g],defines:{DATAFILTER_TYPE:x[t],DATAFILTER_DOUBLE:Boolean(n)}}}initializeState(e,t){const n=this.getAttributeManager();n&&n.add({filterValues:{size:t.opts.filterSize,type:t.opts.fp64?5130:5126,accessor:"getFilterValue",shaderAttributes:{filterValues:{divisor:0},instanceFilterValues:{divisor:1}}}});const{gl:i}=this.context;if(n&&t.opts.countItems){const e=function(e){return Boolean(e.getExtension("EXT_float_blend")&&(e.getExtension("EXT_color_buffer_float")||e.getExtension("WEBGL_color_buffer_float")))}(i);n.add({filterIndices:{size:e?1:2,vertexOffset:1,type:5121,normalized:!0,accessor:(t,{index:n})=>{const i=t&&t.__source?t.__source.index:n;return e?(i+1)%255:[(i+1)%255,Math.floor(i/255)%255]},shaderAttributes:{filterPrevIndices:{vertexOffset:0},filterIndices:{vertexOffset:1}}}});const r=function(e,t){return new s(e,t?{width:1,height:1,attachments:{36064:new d(e,{format:u(e)?34836:6408,type:5126,mipmaps:!1})}}:{width:256,height:64,depth:!1})}(i,e),a=function(e,t,n){return t.defines.NON_INSTANCED_MODEL=1,n&&(t.defines.FLOAT_TARGET=1),new _(e,f({id:"data-filter-aggregation-model",vertexCount:1,isInstanced:!1,drawMode:0,vs:"#define SHADER_NAME data-filter-vertex-shader\n\n#ifdef FLOAT_TARGET\n  attribute float filterIndices;\n  attribute float filterPrevIndices;\n#else\n  attribute vec2 filterIndices;\n  attribute vec2 filterPrevIndices;\n#endif\n\nvarying vec4 vColor;\nconst float component = 1.0 / 255.0;\n\nvoid main() {\n  #ifdef FLOAT_TARGET\n    dataFilter_value *= float(filterIndices != filterPrevIndices);\n    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n    vColor = vec4(0.0, 0.0, 0.0, 1.0);\n  #else\n    // Float texture is not supported: pack result into 4 channels x 256 px x 64px\n    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);\n    float col = filterIndices.x;\n    float row = filterIndices.y * 4.0;\n    float channel = floor(row);\n    row = fract(row);\n    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));\n    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);\n  #endif\n  gl_PointSize = 1.0;\n}\n",fs:"#define SHADER_NAME data-filter-fragment-shader\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main() {\n  if (dataFilter_value < 0.5) {\n    discard;\n  }\n  gl_FragColor = vColor;\n}\n"},t))}(i,t.getShaders.call(this,t),e);this.setState({filterFBO:r,filterModel:a})}}updateState({props:e,oldProps:t}){if(this.state.filterModel){const n=this.getAttributeManager().attributes.filterValues.needsUpdate()||e.filterEnabled!==t.filterEnabled||e.filterRange!==t.filterRange||e.filterSoftRange!==t.filterSoftRange;n&&this.setState({filterNeedsUpdate:n})}}draw(e,t){const{filterFBO:n,filterModel:i,filterNeedsUpdate:r}=this.state,{onFilteredItemsChange:a}=this.props;if(r&&a&&i){const{attributes:{filterValues:t,filterIndices:r}}=this.getAttributeManager();i.setVertexCount(this.getNumInstances());const{gl:l}=this.context;c(l,{framebuffer:n,color:[0,0,0,0]}),i.updateModuleSettings(e.moduleParameters).setAttributes(f(f({},t.getShaderAttributes()),r&&r.getShaderAttributes())).draw({framebuffer:n,parameters:o(f({},h),{viewport:[0,0,n.width,n.height]})});const s=m(n);let d=0;for(let e=0;e<s.length;e++)d+=s[e];a({id:this.id,count:d}),this.state.filterNeedsUpdate=!1}}finalizeState(){const{filterFBO:e,filterModel:t}=this.state;e&&(e.color.delete(),e.delete(),t.delete())}}T(R,"defaultProps",{getFilterValue:{type:"accessor",value:0},onFilteredItemsChange:{type:"function",value:null,compare:!1},filterEnabled:!0,filterRange:[-1,1],filterSoftRange:null,filterTransformSize:!0,filterTransformColor:!0}),T(R,"extensionName","DataFilterExtension");export{R as D};
//# sourceMappingURL=data-filter.bf997cc2.js.map
