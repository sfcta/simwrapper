{"version":3,"file":"text-layer.f1b6c0de.js","sources":["../../node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js","../../node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-manager.js","../../node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js","../../node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-vertex.glsl.js","../../node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-fragment.glsl.js","../../node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js","../../node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-vertex.glsl.js","../../node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-fragment.glsl.js","../../node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer.js","../../node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js","../../node_modules/@mapbox/tiny-sdf/index.js","../../node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js","../../node_modules/@deck.gl/layers/dist/esm/text-layer/lru-cache.js","../../node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js","../../node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer.js","../../node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer-vertex.glsl.js","../../node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer-fragment.glsl.js","../../node_modules/@deck.gl/layers/dist/esm/text-layer/text-layer.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport Layer from './layer';\nimport debug from '../debug';\nimport { flatten } from '../utils/flatten';\nconst TRACE_RENDER_LAYERS = 'compositeLayer.renderLayers';\nexport default class CompositeLayer extends Layer {\n  get isComposite() {\n    return true;\n  }\n\n  get isLoaded() {\n    return super.isLoaded && this.getSubLayers().every(layer => layer.isLoaded);\n  }\n\n  getSubLayers() {\n    return this.internalState && this.internalState.subLayers || [];\n  }\n\n  initializeState(context) {}\n\n  setState(updateObject) {\n    super.setState(updateObject);\n    this.setNeedsUpdate();\n  }\n\n  getPickingInfo({\n    info\n  }) {\n    const {\n      object\n    } = info;\n    const isDataWrapped = object && object.__source && object.__source.parent && object.__source.parent.id === this.id;\n\n    if (!isDataWrapped) {\n      return info;\n    }\n\n    info.object = object.__source.object;\n    info.index = object.__source.index;\n    return info;\n  }\n\n  filterSubLayer(context) {\n    return true;\n  }\n\n  shouldRenderSubLayer(subLayerId, data) {\n    return data && data.length;\n  }\n\n  getSubLayerClass(subLayerId, DefaultLayerClass) {\n    const {\n      _subLayerProps: overridingProps\n    } = this.props;\n    return overridingProps && overridingProps[subLayerId] && overridingProps[subLayerId].type || DefaultLayerClass;\n  }\n\n  getSubLayerRow(row, sourceObject, sourceObjectIndex) {\n    row.__source = {\n      parent: this,\n      object: sourceObject,\n      index: sourceObjectIndex\n    };\n    return row;\n  }\n\n  getSubLayerAccessor(accessor) {\n    if (typeof accessor === 'function') {\n      const objectInfo = {\n        index: -1,\n        data: this.props.data,\n        target: []\n      };\n      return (x, i) => {\n        if (x && x.__source) {\n          objectInfo.index = x.__source.index;\n          return accessor(x.__source.object, objectInfo);\n        }\n\n        return accessor(x, i);\n      };\n    }\n\n    return accessor;\n  }\n\n  getSubLayerProps(sublayerProps = {}) {\n    var _this$props$updateTri;\n\n    const {\n      opacity,\n      pickable,\n      visible,\n      parameters,\n      getPolygonOffset,\n      highlightedObjectIndex,\n      autoHighlight,\n      highlightColor,\n      coordinateSystem,\n      coordinateOrigin,\n      wrapLongitude,\n      positionFormat,\n      modelMatrix,\n      extensions,\n      fetch,\n      operation,\n      _subLayerProps: overridingProps\n    } = this.props;\n    const newProps = {\n      id: '',\n      updateTriggers: {},\n      opacity,\n      pickable,\n      visible,\n      parameters,\n      getPolygonOffset,\n      highlightedObjectIndex,\n      autoHighlight,\n      highlightColor,\n      coordinateSystem,\n      coordinateOrigin,\n      wrapLongitude,\n      positionFormat,\n      modelMatrix,\n      extensions,\n      fetch,\n      operation\n    };\n    const overridingSublayerProps = overridingProps && sublayerProps.id && overridingProps[sublayerProps.id];\n    const overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;\n    const sublayerId = sublayerProps.id || 'sublayer';\n\n    if (overridingSublayerProps) {\n      const propTypes = this.constructor._propTypes;\n      const subLayerPropTypes = sublayerProps.type ? sublayerProps.type._propTypes : {};\n\n      for (const key in overridingSublayerProps) {\n        const propType = subLayerPropTypes[key] || propTypes[key];\n\n        if (propType && propType.type === 'accessor') {\n          overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);\n        }\n      }\n    }\n\n    Object.assign(newProps, sublayerProps, overridingSublayerProps);\n    newProps.id = \"\".concat(this.props.id, \"-\").concat(sublayerId);\n    newProps.updateTriggers = {\n      all: (_this$props$updateTri = this.props.updateTriggers) === null || _this$props$updateTri === void 0 ? void 0 : _this$props$updateTri.all,\n      ...sublayerProps.updateTriggers,\n      ...overridingSublayerTriggers\n    };\n\n    for (const extension of extensions) {\n      const passThroughProps = extension.getSubLayerProps.call(this, extension);\n\n      if (passThroughProps) {\n        Object.assign(newProps, passThroughProps, {\n          updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)\n        });\n      }\n    }\n\n    return newProps;\n  }\n\n  _updateAutoHighlight(info) {\n    for (const layer of this.getSubLayers()) {\n      layer.updateAutoHighlight(info);\n    }\n  }\n\n  _getAttributeManager() {\n    return null;\n  }\n\n  _postUpdate(updateParams, forceUpdate) {\n    let subLayers = this.internalState.subLayers;\n    const shouldUpdate = !subLayers || this.needsUpdate();\n\n    if (shouldUpdate) {\n      const subLayersList = this.renderLayers();\n      subLayers = flatten(subLayersList, Boolean);\n      this.internalState.subLayers = subLayers;\n    }\n\n    debug(TRACE_RENDER_LAYERS, this, shouldUpdate, subLayers);\n\n    for (const layer of subLayers) {\n      layer.parent = this;\n    }\n  }\n\n}\n\n_defineProperty(CompositeLayer, \"layerName\", 'CompositeLayer');\n//# sourceMappingURL=composite-layer.js.map","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Texture2D, copyToTexture } from '@luma.gl/core';\nimport { ImageLoader } from '@loaders.gl/images';\nimport { load } from '@loaders.gl/core';\nimport { createIterable } from '@deck.gl/core';\nconst DEFAULT_CANVAS_WIDTH = 1024;\nconst DEFAULT_BUFFER = 4;\n\nconst noop = () => {};\n\nconst DEFAULT_TEXTURE_PARAMETERS = {\n  [10241]: 9987,\n  [10240]: 9729,\n  [10242]: 33071,\n  [10243]: 33071\n};\n\nfunction nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\n\nfunction resizeImage(ctx, imageData, width, height) {\n  if (width === imageData.width && height === imageData.height) {\n    return imageData;\n  }\n\n  ctx.canvas.height = height;\n  ctx.canvas.width = width;\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);\n  return ctx.canvas;\n}\n\nfunction getIconId(icon) {\n  return icon && (icon.id || icon.url);\n}\n\nfunction resizeTexture(texture, width, height, parameters) {\n  const oldWidth = texture.width;\n  const oldHeight = texture.height;\n  const newTexture = new Texture2D(texture.gl, {\n    width,\n    height,\n    parameters\n  });\n  copyToTexture(texture, newTexture, {\n    targetY: 0,\n    width: oldWidth,\n    height: oldHeight\n  });\n  texture.delete();\n  return newTexture;\n}\n\nfunction buildRowMapping(mapping, columns, yOffset) {\n  for (let i = 0; i < columns.length; i++) {\n    const {\n      icon,\n      xOffset\n    } = columns[i];\n    const id = getIconId(icon);\n    mapping[id] = { ...icon,\n      x: xOffset,\n      y: yOffset\n    };\n  }\n}\n\nexport function buildMapping({\n  icons,\n  buffer,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0,\n  rowHeight = 0,\n  canvasWidth\n}) {\n  let columns = [];\n\n  for (let i = 0; i < icons.length; i++) {\n    const icon = icons[i];\n    const id = getIconId(icon);\n\n    if (!mapping[id]) {\n      const {\n        height,\n        width\n      } = icon;\n\n      if (xOffset + width + buffer > canvasWidth) {\n        buildRowMapping(mapping, columns, yOffset);\n        xOffset = 0;\n        yOffset = rowHeight + yOffset + buffer;\n        rowHeight = 0;\n        columns = [];\n      }\n\n      columns.push({\n        icon,\n        xOffset\n      });\n      xOffset = xOffset + width + buffer;\n      rowHeight = Math.max(rowHeight, height);\n    }\n  }\n\n  if (columns.length > 0) {\n    buildRowMapping(mapping, columns, yOffset);\n  }\n\n  return {\n    mapping,\n    rowHeight,\n    xOffset,\n    yOffset,\n    canvasWidth,\n    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)\n  };\n}\nexport function getDiffIcons(data, getIcon, cachedIcons) {\n  if (!data || !getIcon) {\n    return null;\n  }\n\n  cachedIcons = cachedIcons || {};\n  const icons = {};\n  const {\n    iterable,\n    objectInfo\n  } = createIterable(data);\n\n  for (const object of iterable) {\n    objectInfo.index++;\n    const icon = getIcon(object, objectInfo);\n    const id = getIconId(icon);\n\n    if (!icon) {\n      throw new Error('Icon is missing.');\n    }\n\n    if (!icon.url) {\n      throw new Error('Icon url is missing.');\n    }\n\n    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {\n      icons[id] = { ...icon,\n        source: object,\n        sourceIndex: objectInfo.index\n      };\n    }\n  }\n\n  return icons;\n}\nexport default class IconManager {\n  constructor(gl, {\n    onUpdate = noop,\n    onError = noop\n  }) {\n    _defineProperty(this, \"gl\", void 0);\n\n    _defineProperty(this, \"onUpdate\", void 0);\n\n    _defineProperty(this, \"onError\", void 0);\n\n    _defineProperty(this, \"_loadOptions\", null);\n\n    _defineProperty(this, \"_texture\", null);\n\n    _defineProperty(this, \"_externalTexture\", null);\n\n    _defineProperty(this, \"_mapping\", {});\n\n    _defineProperty(this, \"_textureParameters\", null);\n\n    _defineProperty(this, \"_pendingCount\", 0);\n\n    _defineProperty(this, \"_autoPacking\", false);\n\n    _defineProperty(this, \"_xOffset\", 0);\n\n    _defineProperty(this, \"_yOffset\", 0);\n\n    _defineProperty(this, \"_rowHeight\", 0);\n\n    _defineProperty(this, \"_buffer\", DEFAULT_BUFFER);\n\n    _defineProperty(this, \"_canvasWidth\", DEFAULT_CANVAS_WIDTH);\n\n    _defineProperty(this, \"_canvasHeight\", 0);\n\n    _defineProperty(this, \"_canvas\", null);\n\n    this.gl = gl;\n    this.onUpdate = onUpdate;\n    this.onError = onError;\n  }\n\n  finalize() {\n    var _this$_texture;\n\n    (_this$_texture = this._texture) === null || _this$_texture === void 0 ? void 0 : _this$_texture.delete();\n  }\n\n  getTexture() {\n    return this._texture || this._externalTexture;\n  }\n\n  getIconMapping(icon) {\n    const id = this._autoPacking ? getIconId(icon) : icon;\n    return this._mapping[id] || {};\n  }\n\n  setProps({\n    loadOptions,\n    autoPacking,\n    iconAtlas,\n    iconMapping,\n    textureParameters\n  }) {\n    if (loadOptions) {\n      this._loadOptions = loadOptions;\n    }\n\n    if (autoPacking !== undefined) {\n      this._autoPacking = autoPacking;\n    }\n\n    if (iconMapping) {\n      this._mapping = iconMapping;\n    }\n\n    if (iconAtlas) {\n      var _this$_texture2;\n\n      (_this$_texture2 = this._texture) === null || _this$_texture2 === void 0 ? void 0 : _this$_texture2.delete();\n      this._texture = null;\n      this._externalTexture = iconAtlas;\n    }\n\n    if (textureParameters) {\n      this._textureParameters = textureParameters;\n    }\n  }\n\n  get isLoaded() {\n    return this._pendingCount === 0;\n  }\n\n  packIcons(data, getIcon) {\n    if (!this._autoPacking || typeof document === 'undefined') {\n      return;\n    }\n\n    const icons = Object.values(getDiffIcons(data, getIcon, this._mapping) || {});\n\n    if (icons.length > 0) {\n      const {\n        mapping,\n        xOffset,\n        yOffset,\n        rowHeight,\n        canvasHeight\n      } = buildMapping({\n        icons,\n        buffer: this._buffer,\n        canvasWidth: this._canvasWidth,\n        mapping: this._mapping,\n        rowHeight: this._rowHeight,\n        xOffset: this._xOffset,\n        yOffset: this._yOffset\n      });\n      this._rowHeight = rowHeight;\n      this._mapping = mapping;\n      this._xOffset = xOffset;\n      this._yOffset = yOffset;\n      this._canvasHeight = canvasHeight;\n\n      if (!this._texture) {\n        this._texture = new Texture2D(this.gl, {\n          width: this._canvasWidth,\n          height: this._canvasHeight,\n          parameters: this._textureParameters || DEFAULT_TEXTURE_PARAMETERS\n        });\n      }\n\n      if (this._texture.height !== this._canvasHeight) {\n        this._texture = resizeTexture(this._texture, this._canvasWidth, this._canvasHeight, this._textureParameters || DEFAULT_TEXTURE_PARAMETERS);\n      }\n\n      this.onUpdate();\n      this._canvas = this._canvas || document.createElement('canvas');\n\n      this._loadIcons(icons);\n    }\n  }\n\n  _loadIcons(icons) {\n    const ctx = this._canvas.getContext('2d');\n\n    for (const icon of icons) {\n      this._pendingCount++;\n      load(icon.url, ImageLoader, this._loadOptions).then(imageData => {\n        const id = getIconId(icon);\n        const {\n          x,\n          y,\n          width,\n          height\n        } = this._mapping[id];\n        const data = resizeImage(ctx, imageData, width, height);\n\n        this._texture.setSubImageData({\n          data,\n          x,\n          y,\n          width,\n          height\n        });\n\n        this._texture.generateMipmap();\n\n        this.onUpdate();\n      }).catch(error => {\n        this.onError({\n          url: icon.url,\n          source: icon.source,\n          sourceIndex: icon.sourceIndex,\n          loadOptions: this._loadOptions,\n          error\n        });\n      }).finally(() => {\n        this._pendingCount--;\n      });\n    }\n  }\n\n}\n//# sourceMappingURL=icon-manager.js.map","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Layer, project32, picking, log, UNIT } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/core';\nimport vs from './icon-layer-vertex.glsl';\nimport fs from './icon-layer-fragment.glsl';\nimport IconManager from './icon-manager';\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  iconAtlas: {\n    type: 'image',\n    value: null,\n    async: true\n  },\n  iconMapping: {\n    type: 'object',\n    value: {},\n    async: true\n  },\n  sizeScale: {\n    type: 'number',\n    value: 1,\n    min: 0\n  },\n  billboard: true,\n  sizeUnits: 'pixels',\n  sizeMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  sizeMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  alphaCutoff: {\n    type: 'number',\n    value: 0.05,\n    min: 0,\n    max: 1\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getIcon: {\n    type: 'accessor',\n    value: x => x.icon\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getSize: {\n    type: 'accessor',\n    value: 1\n  },\n  getAngle: {\n    type: 'accessor',\n    value: 0\n  },\n  getPixelOffset: {\n    type: 'accessor',\n    value: [0, 0]\n  },\n  onIconError: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  }\n};\nexport default class IconLayer extends Layer {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", void 0);\n  }\n\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, picking]\n    });\n  }\n\n  initializeState() {\n    this.state = {\n      iconManager: new IconManager(this.context.gl, {\n        onUpdate: this._onUpdate.bind(this),\n        onError: this._onError.bind(this)\n      })\n    };\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: 5130,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceSizes: {\n        size: 1,\n        transition: true,\n        accessor: 'getSize',\n        defaultValue: 1\n      },\n      instanceOffsets: {\n        size: 2,\n        accessor: 'getIcon',\n        transform: this.getInstanceOffset\n      },\n      instanceIconFrames: {\n        size: 4,\n        accessor: 'getIcon',\n        transform: this.getInstanceIconFrame\n      },\n      instanceColorModes: {\n        size: 1,\n        type: 5121,\n        accessor: 'getIcon',\n        transform: this.getInstanceColorMode\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: 5121,\n        normalized: true,\n        transition: true,\n        accessor: 'getColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceAngles: {\n        size: 1,\n        transition: true,\n        accessor: 'getAngle'\n      },\n      instancePixelOffset: {\n        size: 2,\n        transition: true,\n        accessor: 'getPixelOffset'\n      }\n    });\n  }\n\n  updateState(params) {\n    super.updateState(params);\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = params;\n    const attributeManager = this.getAttributeManager();\n    const {\n      iconAtlas,\n      iconMapping,\n      data,\n      getIcon,\n      textureParameters\n    } = props;\n    const {\n      iconManager\n    } = this.state;\n    const prePacked = iconAtlas || this.internalState.isAsyncPropLoading('iconAtlas');\n    iconManager.setProps({\n      loadOptions: props.loadOptions,\n      autoPacking: !prePacked,\n      iconAtlas,\n      iconMapping: prePacked ? iconMapping : null,\n      textureParameters\n    });\n\n    if (prePacked) {\n      if (oldProps.iconMapping !== props.iconMapping) {\n        attributeManager.invalidate('getIcon');\n      }\n    } else if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {\n      iconManager.packIcons(data, getIcon);\n    }\n\n    if (changeFlags.extensionsChanged) {\n      var _this$state$model;\n\n      const {\n        gl\n      } = this.context;\n      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();\n      this.state.model = this._getModel(gl);\n      attributeManager.invalidateAll();\n    }\n  }\n\n  get isLoaded() {\n    return super.isLoaded && this.state.iconManager.isLoaded;\n  }\n\n  finalizeState(context) {\n    super.finalizeState(context);\n    this.state.iconManager.finalize();\n  }\n\n  draw({\n    uniforms\n  }) {\n    const {\n      sizeScale,\n      sizeMinPixels,\n      sizeMaxPixels,\n      sizeUnits,\n      billboard,\n      alphaCutoff\n    } = this.props;\n    const {\n      iconManager\n    } = this.state;\n    const iconsTexture = iconManager.getTexture();\n\n    if (iconsTexture) {\n      this.state.model.setUniforms(uniforms).setUniforms({\n        iconsTexture,\n        iconsTextureDim: [iconsTexture.width, iconsTexture.height],\n        sizeUnits: UNIT[sizeUnits],\n        sizeScale,\n        sizeMinPixels,\n        sizeMaxPixels,\n        billboard,\n        alphaCutoff\n      }).draw();\n    }\n  }\n\n  _getModel(gl) {\n    const positions = [-1, -1, -1, 1, 1, 1, 1, -1];\n    return new Model(gl, { ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: 6,\n        attributes: {\n          positions: {\n            size: 2,\n            value: new Float32Array(positions)\n          }\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  _onUpdate() {\n    this.setNeedsRedraw();\n  }\n\n  _onError(evt) {\n    var _this$getCurrentLayer;\n\n    const onIconError = (_this$getCurrentLayer = this.getCurrentLayer()) === null || _this$getCurrentLayer === void 0 ? void 0 : _this$getCurrentLayer.props.onIconError;\n\n    if (onIconError) {\n      onIconError(evt);\n    } else {\n      log.error(evt.error.message)();\n    }\n  }\n\n  getInstanceOffset(icon) {\n    const {\n      width,\n      height,\n      anchorX = width / 2,\n      anchorY = height / 2\n    } = this.state.iconManager.getIconMapping(icon);\n    return [width / 2 - anchorX, height / 2 - anchorY];\n  }\n\n  getInstanceColorMode(icon) {\n    const mapping = this.state.iconManager.getIconMapping(icon);\n    return mapping.mask ? 1 : 0;\n  }\n\n  getInstanceIconFrame(icon) {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.state.iconManager.getIconMapping(icon);\n    return [x, y, width, height];\n  }\n\n}\n\n_defineProperty(IconLayer, \"defaultProps\", defaultProps);\n\n_defineProperty(IconLayer, \"layerName\", 'IconLayer');\n//# sourceMappingURL=icon-layer.js.map","export default \"#define SHADER_NAME icon-layer-vertex-shader\\n\\nattribute vec2 positions;\\n\\nattribute vec3 instancePositions;\\nattribute vec3 instancePositions64Low;\\nattribute float instanceSizes;\\nattribute float instanceAngles;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\nattribute vec4 instanceIconFrames;\\nattribute float instanceColorModes;\\nattribute vec2 instanceOffsets;\\nattribute vec2 instancePixelOffset;\\n\\nuniform float sizeScale;\\nuniform vec2 iconsTextureDim;\\nuniform float sizeMinPixels;\\nuniform float sizeMaxPixels;\\nuniform bool billboard;\\nuniform int sizeUnits;\\n\\nvarying float vColorMode;\\nvarying vec4 vColor;\\nvarying vec2 vTextureCoords;\\nvarying vec2 uv;\\n\\nvec2 rotate_by_angle(vec2 vertex, float angle) {\\n  float angle_radian = angle * PI / 180.0;\\n  float cos_angle = cos(angle_radian);\\n  float sin_angle = sin(angle_radian);\\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\\n  return rotationMatrix * vertex;\\n}\\n\\nvoid main(void) {\\n  geometry.worldPosition = instancePositions;\\n  geometry.uv = positions;\\n  geometry.pickingColor = instancePickingColors;\\n  uv = positions;\\n\\n  vec2 iconSize = instanceIconFrames.zw;\\n  // convert size in meters to pixels, then scaled and clamp\\n \\n  // project meters to pixels and clamp to limits \\n  float sizePixels = clamp(\\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits), \\n    sizeMinPixels, sizeMaxPixels\\n  );\\n\\n  // scale icon height to match instanceSize\\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\\n\\n  // scale and rotate vertex in \\\"pixel\\\" value and convert back to fraction in clipspace\\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\\n  pixelOffset += instancePixelOffset;\\n  pixelOffset.y *= -1.0;\\n\\n  if (billboard)  {\\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\\n    vec3 offset = vec3(pixelOffset, 0.0);\\n    DECKGL_FILTER_SIZE(offset, geometry);\\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\\n\\n  } else {\\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\\n    DECKGL_FILTER_SIZE(offset_common, geometry);\\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \\n  }\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n\\n  vTextureCoords = mix(\\n    instanceIconFrames.xy,\\n    instanceIconFrames.xy + iconSize,\\n    (positions.xy + 1.0) / 2.0\\n  ) / iconsTextureDim;\\n\\n  vColor = instanceColors;\\n  DECKGL_FILTER_COLOR(vColor, geometry);\\n\\n  vColorMode = instanceColorModes;\\n}\\n\";\n//# sourceMappingURL=icon-layer-vertex.glsl.js.map","export default \"#define SHADER_NAME icon-layer-fragment-shader\\n\\nprecision highp float;\\n\\nuniform float opacity;\\nuniform sampler2D iconsTexture;\\nuniform float alphaCutoff;\\n\\nvarying float vColorMode;\\nvarying vec4 vColor;\\nvarying vec2 vTextureCoords;\\nvarying vec2 uv;\\n\\nvoid main(void) {\\n  geometry.uv = uv;\\n\\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\\n\\n  // if colorMode == 0, use pixel color from the texture\\n  // if colorMode == 1 or rendering picking buffer, use texture as transparency mask\\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\\n  // Take the global opacity and the alpha from vColor into account for the alpha component\\n  float a = texColor.a * opacity * vColor.a;\\n\\n  if (a < alphaCutoff) {\\n    discard;\\n  }\\n\\n  gl_FragColor = vec4(color, a);\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\";\n//# sourceMappingURL=icon-layer-fragment.glsl.js.map","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Layer, project32, picking, UNIT } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/core';\nimport vs from './scatterplot-layer-vertex.glsl';\nimport fs from './scatterplot-layer-fragment.glsl';\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  radiusUnits: 'meters',\n  radiusScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  radiusMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  radiusMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  lineWidthUnits: 'meters',\n  lineWidthScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  lineWidthMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  lineWidthMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  stroked: false,\n  filled: true,\n  billboard: false,\n  antialiasing: true,\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getRadius: {\n    type: 'accessor',\n    value: 1\n  },\n  getFillColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getLineColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getLineWidth: {\n    type: 'accessor',\n    value: 1\n  },\n  strokeWidth: {\n    deprecatedFor: 'getLineWidth'\n  },\n  outline: {\n    deprecatedFor: 'stroked'\n  },\n  getColor: {\n    deprecatedFor: ['getFillColor', 'getLineColor']\n  }\n};\nexport default class ScatterplotLayer extends Layer {\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, picking]\n    });\n  }\n\n  initializeState() {\n    this.getAttributeManager().addInstanced({\n      instancePositions: {\n        size: 3,\n        type: 5130,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceRadius: {\n        size: 1,\n        transition: true,\n        accessor: 'getRadius',\n        defaultValue: 1\n      },\n      instanceFillColors: {\n        size: this.props.colorFormat.length,\n        transition: true,\n        normalized: true,\n        type: 5121,\n        accessor: 'getFillColor',\n        defaultValue: [0, 0, 0, 255]\n      },\n      instanceLineColors: {\n        size: this.props.colorFormat.length,\n        transition: true,\n        normalized: true,\n        type: 5121,\n        accessor: 'getLineColor',\n        defaultValue: [0, 0, 0, 255]\n      },\n      instanceLineWidths: {\n        size: 1,\n        transition: true,\n        accessor: 'getLineWidth',\n        defaultValue: 1\n      }\n    });\n  }\n\n  updateState(params) {\n    super.updateState(params);\n\n    if (params.changeFlags.extensionsChanged) {\n      var _this$state$model;\n\n      const {\n        gl\n      } = this.context;\n      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();\n      this.state.model = this._getModel(gl);\n      this.getAttributeManager().invalidateAll();\n    }\n  }\n\n  draw({\n    uniforms\n  }) {\n    const {\n      radiusUnits,\n      radiusScale,\n      radiusMinPixels,\n      radiusMaxPixels,\n      stroked,\n      filled,\n      billboard,\n      antialiasing,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels\n    } = this.props;\n    this.state.model.setUniforms(uniforms).setUniforms({\n      stroked: stroked ? 1 : 0,\n      filled,\n      billboard,\n      antialiasing,\n      radiusUnits: UNIT[radiusUnits],\n      radiusScale,\n      radiusMinPixels,\n      radiusMaxPixels,\n      lineWidthUnits: UNIT[lineWidthUnits],\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels\n    }).draw();\n  }\n\n  _getModel(gl) {\n    const positions = [-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0];\n    return new Model(gl, { ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: 6,\n        vertexCount: 4,\n        attributes: {\n          positions: {\n            size: 3,\n            value: new Float32Array(positions)\n          }\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n}\n\n_defineProperty(ScatterplotLayer, \"defaultProps\", defaultProps);\n\n_defineProperty(ScatterplotLayer, \"layerName\", 'ScatterplotLayer');\n//# sourceMappingURL=scatterplot-layer.js.map","export default \"#define SHADER_NAME scatterplot-layer-vertex-shader\\n\\nattribute vec3 positions;\\n\\nattribute vec3 instancePositions;\\nattribute vec3 instancePositions64Low;\\nattribute float instanceRadius;\\nattribute float instanceLineWidths;\\nattribute vec4 instanceFillColors;\\nattribute vec4 instanceLineColors;\\nattribute vec3 instancePickingColors;\\n\\nuniform float opacity;\\nuniform float radiusScale;\\nuniform float radiusMinPixels;\\nuniform float radiusMaxPixels;\\nuniform float lineWidthScale;\\nuniform float lineWidthMinPixels;\\nuniform float lineWidthMaxPixels;\\nuniform float stroked;\\nuniform bool filled;\\nuniform bool antialiasing;\\nuniform bool billboard;\\nuniform int radiusUnits;\\nuniform int lineWidthUnits;\\n\\nvarying vec4 vFillColor;\\nvarying vec4 vLineColor;\\nvarying vec2 unitPosition;\\nvarying float innerUnitRadius;\\nvarying float outerRadiusPixels;\\n\\n\\nvoid main(void) {\\n  geometry.worldPosition = instancePositions;\\n\\n  // Multiply out radius and clamp to limits\\n  outerRadiusPixels = clamp(\\n    project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),\\n    radiusMinPixels, radiusMaxPixels\\n  );\\n  \\n  // Multiply out line width and clamp to limits\\n  float lineWidthPixels = clamp(\\n    project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),\\n    lineWidthMinPixels, lineWidthMaxPixels\\n  );\\n\\n  // outer radius needs to offset by half stroke width\\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\\n\\n  // Expand geometry to accomodate edge smoothing\\n  float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\\n\\n  // position on the containing square in [-1, 1] space\\n  unitPosition = edgePadding * positions.xy;\\n  geometry.uv = unitPosition;\\n  geometry.pickingColor = instancePickingColors;\\n\\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\\n  \\n  if (billboard) {\\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\\n    vec3 offset = edgePadding * positions * outerRadiusPixels;\\n    DECKGL_FILTER_SIZE(offset, geometry);\\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\\n  } else {\\n    vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\\n    DECKGL_FILTER_SIZE(offset, geometry);\\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\\n  }\\n\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n\\n  // Apply opacity to instance color, or return instance picking color\\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\\n}\\n\";\n//# sourceMappingURL=scatterplot-layer-vertex.glsl.js.map","export default \"#define SHADER_NAME scatterplot-layer-fragment-shader\\n\\nprecision highp float;\\n\\nuniform bool filled;\\nuniform float stroked;\\nuniform bool antialiasing;\\n\\nvarying vec4 vFillColor;\\nvarying vec4 vLineColor;\\nvarying vec2 unitPosition;\\nvarying float innerUnitRadius;\\nvarying float outerRadiusPixels;\\n\\nvoid main(void) {\\n  geometry.uv = unitPosition;\\n\\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\\n  float inCircle = antialiasing ? \\n    smoothedge(distToCenter, outerRadiusPixels) : \\n    step(distToCenter, outerRadiusPixels);\\n\\n  if (inCircle == 0.0) {\\n    discard;\\n  }\\n\\n  if (stroked > 0.5) {\\n    float isLine = antialiasing ? \\n      smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\\n      step(innerUnitRadius * outerRadiusPixels, distToCenter);\\n\\n    if (filled) {\\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\\n    } else {\\n      if (isLine == 0.0) {\\n        discard;\\n      }\\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\\n    }\\n  } else if (filled) {\\n    gl_FragColor = vFillColor;\\n  } else {\\n    discard;\\n  }\\n\\n  gl_FragColor.a *= inCircle;\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\";\n//# sourceMappingURL=scatterplot-layer-fragment.glsl.js.map","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { log } from '@deck.gl/core';\nimport IconLayer from '../../icon-layer/icon-layer';\nimport fs from './multi-icon-layer-fragment.glsl';\nconst DEFAULT_BUFFER = 192.0 / 256;\nconst EMPTY_ARRAY = [];\nconst defaultProps = {\n  getIconOffsets: {\n    type: 'accessor',\n    value: x => x.offsets\n  },\n  alphaCutoff: 0.001,\n  smoothing: 0.1,\n  outlineWidth: 0,\n  outlineColor: {\n    type: 'color',\n    value: [0, 0, 0, 255]\n  }\n};\nexport default class MultiIconLayer extends IconLayer {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", void 0);\n  }\n\n  getShaders() {\n    return { ...super.getShaders(),\n      fs\n    };\n  }\n\n  initializeState() {\n    super.initializeState();\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instanceOffsets: {\n        size: 2,\n        accessor: 'getIconOffsets'\n      },\n      instancePickingColors: {\n        type: 5121,\n        size: 3,\n        accessor: (object, {\n          index,\n          target: value\n        }) => this.encodePickingColor(index, value)\n      }\n    });\n  }\n\n  updateState(params) {\n    super.updateState(params);\n    const {\n      props,\n      oldProps\n    } = params;\n    let {\n      outlineColor\n    } = props;\n\n    if (outlineColor !== oldProps.outlineColor) {\n      outlineColor = outlineColor.map(x => x / 255);\n      outlineColor[3] = Number.isFinite(outlineColor[3]) ? outlineColor[3] : 1;\n      this.setState({\n        outlineColor\n      });\n    }\n\n    if (!props.sdf && props.outlineWidth) {\n      log.warn(\"\".concat(this.id, \": fontSettings.sdf is required to render outline\"))();\n    }\n  }\n\n  draw(params) {\n    const {\n      sdf,\n      smoothing,\n      outlineWidth\n    } = this.props;\n    const {\n      outlineColor\n    } = this.state;\n    params.uniforms = { ...params.uniforms,\n      buffer: DEFAULT_BUFFER,\n      outlineBuffer: outlineWidth ? Math.max(smoothing, DEFAULT_BUFFER * (1 - outlineWidth)) : -1,\n      gamma: smoothing,\n      sdf: Boolean(sdf),\n      outlineColor\n    };\n    super.draw(params);\n  }\n\n  getInstanceOffset(icons) {\n    return icons ? Array.from(icons).flatMap(icon => super.getInstanceOffset(icon)) : EMPTY_ARRAY;\n  }\n\n  getInstanceColorMode(icons) {\n    return 1;\n  }\n\n  getInstanceIconFrame(icons) {\n    return icons ? Array.from(icons).flatMap(icon => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY;\n  }\n\n}\n\n_defineProperty(MultiIconLayer, \"defaultProps\", defaultProps);\n\n_defineProperty(MultiIconLayer, \"layerName\", 'MultiIconLayer');\n//# sourceMappingURL=multi-icon-layer.js.map","export default \"#define SHADER_NAME multi-icon-layer-fragment-shader\\n\\nprecision highp float;\\n\\nuniform float opacity;\\nuniform sampler2D iconsTexture;\\nuniform float gamma;\\nuniform bool sdf;\\nuniform float alphaCutoff;\\nuniform float buffer;\\nuniform float outlineBuffer;\\nuniform vec4 outlineColor;\\n\\nvarying vec4 vColor;\\nvarying vec2 vTextureCoords;\\nvarying vec2 uv;\\n\\nvoid main(void) {\\n  geometry.uv = uv;\\n\\n  if (!picking_uActive) {\\n    float alpha = texture2D(iconsTexture, vTextureCoords).a;\\n    vec4 color = vColor;\\n\\n    // if enable sdf (signed distance fields)\\n    if (sdf) {\\n      float distance = alpha;\\n      alpha = smoothstep(buffer - gamma, buffer + gamma, distance);\\n\\n      if (outlineBuffer > 0.0) {\\n        float inFill = alpha;\\n        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);\\n        color = mix(outlineColor, vColor, inFill);\\n        alpha = inBorder;\\n      }\\n    }\\n\\n    // Take the global opacity and the alpha from color into account for the alpha component\\n    float a = alpha * color.a;\\n    \\n    if (a < alphaCutoff) {\\n      discard;\\n    }\\n\\n    gl_FragColor = vec4(color.rgb, a * opacity);\\n  }\\n\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\";\n//# sourceMappingURL=multi-icon-layer-fragment.glsl.js.map","'use strict';\n\nmodule.exports = TinySDF;\nmodule.exports.default = TinySDF;\n\nvar INF = 1e20;\n\nfunction TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight) {\n    this.fontSize = fontSize || 24;\n    this.buffer = buffer === undefined ? 3 : buffer;\n    this.cutoff = cutoff || 0.25;\n    this.fontFamily = fontFamily || 'sans-serif';\n    this.fontWeight = fontWeight || 'normal';\n    this.radius = radius || 8;\n\n    // For backwards compatibility, we honor the implicit contract that the\n    // size of the returned bitmap will be fontSize + buffer * 2\n    var size = this.size = this.fontSize + this.buffer * 2;\n    // Glyphs may be slightly larger than their fontSize. The canvas already\n    // has buffer space, but create extra buffer space in the output grid for the\n    // \"halo\" to extend into (if metric extraction is enabled)\n    var gridSize = size + this.buffer * 2;\n\n    this.canvas = document.createElement('canvas');\n    this.canvas.width = this.canvas.height = size;\n\n    this.ctx = this.canvas.getContext('2d');\n    this.ctx.font = this.fontWeight + ' ' + this.fontSize + 'px ' + this.fontFamily;\n\n    this.ctx.textAlign = 'left'; // Necessary so that RTL text doesn't have different alignment\n    this.ctx.fillStyle = 'black';\n\n    // temporary arrays for the distance transform\n    this.gridOuter = new Float64Array(gridSize * gridSize);\n    this.gridInner = new Float64Array(gridSize * gridSize);\n    this.f = new Float64Array(gridSize);\n    this.z = new Float64Array(gridSize + 1);\n    this.v = new Uint16Array(gridSize);\n\n    this.useMetrics = this.ctx.measureText('A').actualBoundingBoxLeft !== undefined;\n\n    // hack around https://bugzilla.mozilla.org/show_bug.cgi?id=737852\n    this.middle = Math.round((size / 2) * (navigator.userAgent.indexOf('Gecko/') >= 0 ? 1.2 : 1));\n}\n\nfunction prepareGrids(imgData, width, height, glyphWidth, glyphHeight, gridOuter, gridInner) {\n    // Initialize grids outside the glyph range to alpha 0\n    gridOuter.fill(INF, 0, width * height);\n    gridInner.fill(0, 0, width * height);\n\n    var offset = (width - glyphWidth) / 2; // This is zero if we're not extracting metrics\n\n    for (var y = 0; y < glyphHeight; y++) {\n        for (var x = 0; x < glyphWidth; x++) {\n            var j = (y + offset) * width + x + offset;\n            var a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255; // alpha value\n            if (a === 1) {\n                gridOuter[j] = 0;\n                gridInner[j] = INF;\n            } else if (a === 0) {\n                gridOuter[j] = INF;\n                gridInner[j] = 0;\n            } else {\n                var b = Math.max(0, 0.5 - a);\n                var c = Math.max(0, a - 0.5);\n                gridOuter[j] = b * b;\n                gridInner[j] = c * c;\n            }\n        }\n    }\n}\n\nfunction extractAlpha(alphaChannel, width, height, gridOuter, gridInner, radius, cutoff) {\n    for (var i = 0; i < width * height; i++) {\n        var d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);\n        alphaChannel[i] = Math.round(255 - 255 * (d / radius + cutoff));\n    }\n}\n\nTinySDF.prototype._draw = function (char, getMetrics) {\n    var textMetrics = this.ctx.measureText(char);\n    // Older browsers only expose the glyph width\n    // This is enough for basic layout with all glyphs using the same fixed size\n    var advance = textMetrics.width;\n\n    var doubleBuffer = 2 * this.buffer;\n    var width, glyphWidth, height, glyphHeight, top;\n\n    var imgTop, imgLeft, baselinePosition;\n    // If the browser supports bounding box metrics, we can generate a smaller\n    // SDF. This is a significant performance win.\n    if (getMetrics && this.useMetrics) {\n        // The integer/pixel part of the top alignment is encoded in metrics.top\n        // The remainder is implicitly encoded in the rasterization\n        top = Math.floor(textMetrics.actualBoundingBoxAscent);\n        baselinePosition = this.buffer + Math.ceil(textMetrics.actualBoundingBoxAscent);\n        imgTop = this.buffer;\n        imgLeft = this.buffer;\n\n        // If the glyph overflows the canvas size, it will be clipped at the\n        // bottom/right\n        glyphWidth = Math.min(this.size,\n            Math.ceil(textMetrics.actualBoundingBoxRight - textMetrics.actualBoundingBoxLeft));\n        glyphHeight = Math.min(this.size - imgTop,\n            Math.ceil(textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent));\n\n        width = glyphWidth + doubleBuffer;\n        height = glyphHeight + doubleBuffer;\n        this.ctx.textBaseline = 'alphabetic';\n    } else {\n        width = glyphWidth = this.size;\n        height = glyphHeight = this.size;\n        // 19 points is an approximation of the \"cap height\" ascent from alphabetic\n        // baseline (even though actual drawing is from middle baseline, we can\n        // use the approximation because every glyph fills the em box)\n        top = 19 * this.fontSize / 24;\n        imgTop = imgLeft = 0;\n        baselinePosition = this.middle;\n        this.ctx.textBaseline = 'middle';\n    }\n\n    var imgData;\n    if (glyphWidth && glyphHeight) {\n        this.ctx.clearRect(imgLeft, imgTop, glyphWidth, glyphHeight);\n        this.ctx.fillText(char, this.buffer, baselinePosition);\n        imgData = this.ctx.getImageData(imgLeft, imgTop, glyphWidth, glyphHeight);\n    }\n\n    var alphaChannel = new Uint8ClampedArray(width * height);\n\n    prepareGrids(imgData, width, height, glyphWidth, glyphHeight, this.gridOuter, this.gridInner);\n\n    edt(this.gridOuter, width, height, this.f, this.v, this.z);\n    edt(this.gridInner, width, height, this.f, this.v, this.z);\n\n    extractAlpha(alphaChannel, width, height, this.gridOuter, this.gridInner, this.radius, this.cutoff);\n\n    return {\n        data: alphaChannel,\n        metrics: {\n            width: glyphWidth,\n            height: glyphHeight,\n            sdfWidth: width,\n            sdfHeight: height,\n            top: top,\n            left: 0,\n            advance: advance\n        }\n    };\n};\n\nTinySDF.prototype.draw = function (char) {\n    return this._draw(char, false).data;\n};\n\nTinySDF.prototype.drawWithMetrics = function (char) {\n    return this._draw(char, true);\n};\n\n// 2D Euclidean squared distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/papers/dt-final.pdf\nfunction edt(data, width, height, f, v, z) {\n    for (var x = 0; x < width; x++) edt1d(data, x, width, height, f, v, z);\n    for (var y = 0; y < height; y++) edt1d(data, y * width, 1, width, f, v, z);\n}\n\n// 1D squared distance transform\nfunction edt1d(grid, offset, stride, length, f, v, z) {\n    var q, k, s, r;\n    v[0] = 0;\n    z[0] = -INF;\n    z[1] = INF;\n\n    for (q = 0; q < length; q++) f[q] = grid[offset + q * stride];\n\n    for (q = 1, k = 0, s = 0; q < length; q++) {\n        do {\n            r = v[k];\n            s = (f[q] - f[r] + q * q - r * r) / (q - r) / 2;\n        } while (s <= z[k] && --k > -1);\n\n        k++;\n        v[k] = q;\n        z[k] = s;\n        z[k + 1] = INF;\n    }\n\n    for (q = 0, k = 0; q < length; q++) {\n        while (z[k + 1] < q) k++;\n        r = v[k];\n        grid[offset + q * stride] = f[r] + (q - r) * (q - r);\n    }\n}\n","import { log } from '@deck.gl/core';\nconst MISSING_CHAR_WIDTH = 32;\nconst SINGLE_LINE = [];\nexport function nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\nexport function buildMapping({\n  characterSet,\n  getFontWidth,\n  fontHeight,\n  buffer,\n  maxCanvasWidth,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0\n}) {\n  let row = 0;\n  let x = xOffset;\n\n  for (const char of characterSet) {\n    if (!mapping[char]) {\n      const width = getFontWidth(char);\n\n      if (x + width + buffer * 2 > maxCanvasWidth) {\n        x = 0;\n        row++;\n      }\n\n      mapping[char] = {\n        x: x + buffer,\n        y: yOffset + row * (fontHeight + buffer * 2) + buffer,\n        width,\n        height: fontHeight\n      };\n      x += width + buffer * 2;\n    }\n  }\n\n  const rowHeight = fontHeight + buffer * 2;\n  return {\n    mapping,\n    xOffset: x,\n    yOffset: yOffset + row * rowHeight,\n    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)\n  };\n}\n\nfunction getTextWidth(text, startIndex, endIndex, mapping) {\n  let width = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    var _mapping$character;\n\n    const character = text[i];\n    width += ((_mapping$character = mapping[character]) === null || _mapping$character === void 0 ? void 0 : _mapping$character.width) || 0;\n  }\n\n  return width;\n}\n\nfunction breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {\n  let rowStartCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    const textWidth = getTextWidth(text, i, i + 1, iconMapping);\n\n    if (rowOffsetLeft + textWidth > maxWidth) {\n      if (rowStartCharIndex < i) {\n        target.push(i);\n      }\n\n      rowStartCharIndex = i;\n      rowOffsetLeft = 0;\n    }\n\n    rowOffsetLeft += textWidth;\n  }\n\n  return rowOffsetLeft;\n}\n\nfunction breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {\n  let rowStartCharIndex = startIndex;\n  let groupStartCharIndex = startIndex;\n  let groupEndCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    if (text[i] === ' ') {\n      groupEndCharIndex = i + 1;\n    } else if (text[i + 1] === ' ' || i + 1 === endIndex) {\n      groupEndCharIndex = i + 1;\n    }\n\n    if (groupEndCharIndex > groupStartCharIndex) {\n      let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);\n\n      if (rowOffsetLeft + groupWidth > maxWidth) {\n        if (rowStartCharIndex < groupStartCharIndex) {\n          target.push(groupStartCharIndex);\n          rowStartCharIndex = groupStartCharIndex;\n          rowOffsetLeft = 0;\n        }\n\n        if (groupWidth > maxWidth) {\n          groupWidth = breakAll(text, groupStartCharIndex, groupEndCharIndex, maxWidth, iconMapping, target);\n          rowStartCharIndex = target[target.length - 1];\n        }\n      }\n\n      groupStartCharIndex = groupEndCharIndex;\n      rowOffsetLeft += groupWidth;\n    }\n  }\n\n  return rowOffsetLeft;\n}\n\nexport function autoWrapping(text, wordBreak, maxWidth, iconMapping, startIndex = 0, endIndex) {\n  if (endIndex === undefined) {\n    endIndex = text.length;\n  }\n\n  const result = [];\n\n  if (wordBreak === 'break-all') {\n    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  } else {\n    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  }\n\n  return result;\n}\n\nfunction transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {\n  let x = 0;\n  let rowHeight = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    const character = line[i];\n    const frame = iconMapping[character];\n\n    if (frame) {\n      if (!rowHeight) {\n        rowHeight = frame.height;\n      }\n\n      leftOffsets[i] = x + frame.width / 2;\n      x += frame.width;\n    } else {\n      log.warn(\"Missing character: \".concat(character, \" (\").concat(character.codePointAt(0), \")\"))();\n      leftOffsets[i] = x;\n      x += MISSING_CHAR_WIDTH;\n    }\n  }\n\n  rowSize[0] = x;\n  rowSize[1] = rowHeight;\n}\n\nexport function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {\n  const characters = Array.from(paragraph);\n  const numCharacters = characters.length;\n  const x = new Array(numCharacters);\n  const y = new Array(numCharacters);\n  const rowWidth = new Array(numCharacters);\n  const autoWrappingEnabled = (wordBreak === 'break-word' || wordBreak === 'break-all') && isFinite(maxWidth) && maxWidth > 0;\n  const size = [0, 0];\n  const rowSize = [0, 0];\n  let rowOffsetTop = 0;\n  let lineStartIndex = 0;\n  let lineEndIndex = 0;\n\n  for (let i = 0; i <= numCharacters; i++) {\n    const char = characters[i];\n\n    if (char === '\\n' || i === numCharacters) {\n      lineEndIndex = i;\n    }\n\n    if (lineEndIndex > lineStartIndex) {\n      const rows = autoWrappingEnabled ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;\n\n      for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {\n        const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];\n        const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;\n        transformRow(characters, rowStart, rowEnd, iconMapping, x, rowSize);\n\n        for (let j = rowStart; j < rowEnd; j++) {\n          y[j] = rowOffsetTop + rowSize[1] / 2;\n          rowWidth[j] = rowSize[0];\n        }\n\n        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;\n        size[0] = Math.max(size[0], rowSize[0]);\n      }\n\n      lineStartIndex = lineEndIndex;\n    }\n\n    if (char === '\\n') {\n      x[lineStartIndex] = 0;\n      y[lineStartIndex] = 0;\n      rowWidth[lineStartIndex] = 0;\n      lineStartIndex++;\n    }\n  }\n\n  size[1] = rowOffsetTop;\n  return {\n    x,\n    y,\n    rowWidth,\n    size\n  };\n}\nexport function getTextFromBuffer({\n  value,\n  length,\n  stride,\n  offset,\n  startIndices,\n  characterSet\n}) {\n  const bytesPerElement = value.BYTES_PER_ELEMENT;\n  const elementStride = stride ? stride / bytesPerElement : 1;\n  const elementOffset = offset ? offset / bytesPerElement : 0;\n  const characterCount = startIndices[length] || Math.ceil((value.length - elementOffset) / elementStride);\n  const autoCharacterSet = characterSet && new Set();\n  const texts = new Array(length);\n  let codes = value;\n\n  if (elementStride > 1 || elementOffset > 0) {\n    const ArrayType = value.constructor;\n    codes = new ArrayType(characterCount);\n\n    for (let i = 0; i < characterCount; i++) {\n      codes[i] = value[i * elementStride + elementOffset];\n    }\n  }\n\n  for (let index = 0; index < length; index++) {\n    const startIndex = startIndices[index];\n    const endIndex = startIndices[index + 1] || characterCount;\n    const codesAtIndex = codes.subarray(startIndex, endIndex);\n    texts[index] = String.fromCodePoint.apply(null, codesAtIndex);\n\n    if (autoCharacterSet) {\n      codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);\n    }\n  }\n\n  if (autoCharacterSet) {\n    for (const charCode of autoCharacterSet) {\n      characterSet.add(String.fromCodePoint(charCode));\n    }\n  }\n\n  return {\n    texts,\n    characterCount\n  };\n}\n//# sourceMappingURL=utils.js.map","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nexport default class LRUCache {\n  constructor(limit = 5) {\n    _defineProperty(this, \"limit\", void 0);\n\n    _defineProperty(this, \"_cache\", {});\n\n    _defineProperty(this, \"_order\", []);\n\n    this.limit = limit;\n  }\n\n  get(key) {\n    const value = this._cache[key];\n\n    if (value) {\n      this._deleteOrder(key);\n\n      this._appendOrder(key);\n    }\n\n    return value;\n  }\n\n  set(key, value) {\n    if (!this._cache[key]) {\n      if (Object.keys(this._cache).length === this.limit) {\n        this.delete(this._order[0]);\n      }\n\n      this._cache[key] = value;\n\n      this._appendOrder(key);\n    } else {\n      this.delete(key);\n      this._cache[key] = value;\n\n      this._appendOrder(key);\n    }\n  }\n\n  delete(key) {\n    const value = this._cache[key];\n\n    if (value) {\n      delete this._cache[key];\n\n      this._deleteOrder(key);\n    }\n  }\n\n  _deleteOrder(key) {\n    const index = this._order.indexOf(key);\n\n    if (index >= 0) {\n      this._order.splice(index, 1);\n    }\n  }\n\n  _appendOrder(key) {\n    this._order.push(key);\n  }\n\n}\n//# sourceMappingURL=lru-cache.js.map","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport TinySDF from '@mapbox/tiny-sdf';\nimport { log } from '@deck.gl/core';\nimport { buildMapping } from './utils';\nimport LRUCache from './lru-cache';\n\nfunction getDefaultCharacterSet() {\n  const charSet = [];\n\n  for (let i = 32; i < 128; i++) {\n    charSet.push(String.fromCharCode(i));\n  }\n\n  return charSet;\n}\n\nexport const DEFAULT_FONT_SETTINGS = {\n  fontFamily: 'Monaco, monospace',\n  fontWeight: 'normal',\n  characterSet: getDefaultCharacterSet(),\n  fontSize: 64,\n  buffer: 4,\n  sdf: false,\n  cutoff: 0.25,\n  radius: 12,\n  smoothing: 0.1\n};\nconst MAX_CANVAS_WIDTH = 1024;\nconst BASELINE_SCALE = 0.9;\nconst HEIGHT_SCALE = 1.2;\nconst CACHE_LIMIT = 3;\nlet cache = new LRUCache(CACHE_LIMIT);\n\nfunction getNewChars(cacheKey, characterSet) {\n  let newCharSet;\n\n  if (typeof characterSet === 'string') {\n    newCharSet = new Set(Array.from(characterSet));\n  } else {\n    newCharSet = new Set(characterSet);\n  }\n\n  const cachedFontAtlas = cache.get(cacheKey);\n\n  if (!cachedFontAtlas) {\n    return newCharSet;\n  }\n\n  for (const char in cachedFontAtlas.mapping) {\n    if (newCharSet.has(char)) {\n      newCharSet.delete(char);\n    }\n  }\n\n  return newCharSet;\n}\n\nfunction populateAlphaChannel(alphaChannel, imageData) {\n  for (let i = 0; i < alphaChannel.length; i++) {\n    imageData.data[4 * i + 3] = alphaChannel[i];\n  }\n}\n\nfunction setTextStyle(ctx, fontFamily, fontSize, fontWeight) {\n  ctx.font = \"\".concat(fontWeight, \" \").concat(fontSize, \"px \").concat(fontFamily);\n  ctx.fillStyle = '#000';\n  ctx.textBaseline = 'alphabetic';\n  ctx.textAlign = 'left';\n}\n\nexport function setFontAtlasCacheLimit(limit) {\n  log.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, 'Invalid cache limit');\n  cache = new LRUCache(limit);\n}\nexport default class FontAtlasManager {\n  constructor() {\n    _defineProperty(this, \"props\", { ...DEFAULT_FONT_SETTINGS\n    });\n\n    _defineProperty(this, \"_key\", void 0);\n\n    _defineProperty(this, \"_atlas\", void 0);\n  }\n\n  get texture() {\n    return this._atlas;\n  }\n\n  get mapping() {\n    return this._atlas && this._atlas.mapping;\n  }\n\n  get scale() {\n    return HEIGHT_SCALE;\n  }\n\n  setProps(props = {}) {\n    Object.assign(this.props, props);\n    const oldKey = this._key;\n    this._key = this._getKey();\n    const charSet = getNewChars(this._key, this.props.characterSet);\n    const cachedFontAtlas = cache.get(this._key);\n\n    if (cachedFontAtlas && charSet.size === 0) {\n      if (this._key !== oldKey) {\n        this._atlas = cachedFontAtlas;\n      }\n\n      return;\n    }\n\n    const fontAtlas = this._generateFontAtlas(this._key, charSet, cachedFontAtlas);\n\n    this._atlas = fontAtlas;\n    cache.set(this._key, fontAtlas);\n  }\n\n  _generateFontAtlas(key, characterSet, cachedFontAtlas) {\n    const {\n      fontFamily,\n      fontWeight,\n      fontSize,\n      buffer,\n      sdf,\n      radius,\n      cutoff\n    } = this.props;\n    let canvas = cachedFontAtlas && cachedFontAtlas.data;\n\n    if (!canvas) {\n      canvas = document.createElement('canvas');\n      canvas.width = MAX_CANVAS_WIDTH;\n    }\n\n    const ctx = canvas.getContext('2d');\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n    const {\n      mapping,\n      canvasHeight,\n      xOffset,\n      yOffset\n    } = buildMapping({\n      getFontWidth: char => ctx.measureText(char).width,\n      fontHeight: fontSize * HEIGHT_SCALE,\n      buffer,\n      characterSet,\n      maxCanvasWidth: MAX_CANVAS_WIDTH,\n      ...(cachedFontAtlas && {\n        mapping: cachedFontAtlas.mapping,\n        xOffset: cachedFontAtlas.xOffset,\n        yOffset: cachedFontAtlas.yOffset\n      })\n    });\n\n    if (canvas.height !== canvasHeight) {\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      canvas.height = canvasHeight;\n      ctx.putImageData(imageData, 0, 0);\n    }\n\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n    if (sdf) {\n      const tinySDF = new TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight);\n      const imageData = ctx.getImageData(0, 0, tinySDF.size, tinySDF.size);\n\n      for (const char of characterSet) {\n        populateAlphaChannel(tinySDF.draw(char), imageData);\n        ctx.putImageData(imageData, mapping[char].x - buffer, mapping[char].y + buffer);\n      }\n    } else {\n      for (const char of characterSet) {\n        ctx.fillText(char, mapping[char].x, mapping[char].y + fontSize * BASELINE_SCALE);\n      }\n    }\n\n    return {\n      xOffset,\n      yOffset,\n      mapping,\n      data: canvas,\n      width: canvas.width,\n      height: canvas.height\n    };\n  }\n\n  _getKey() {\n    const {\n      fontFamily,\n      fontWeight,\n      fontSize,\n      buffer,\n      sdf,\n      radius,\n      cutoff\n    } = this.props;\n\n    if (sdf) {\n      return \"\".concat(fontFamily, \" \").concat(fontWeight, \" \").concat(fontSize, \" \").concat(buffer, \" \").concat(radius, \" \").concat(cutoff);\n    }\n\n    return \"\".concat(fontFamily, \" \").concat(fontWeight, \" \").concat(fontSize, \" \").concat(buffer);\n  }\n\n}\n//# sourceMappingURL=font-atlas-manager.js.map","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Layer, project32, picking, UNIT } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/core';\nimport vs from './text-background-layer-vertex.glsl';\nimport fs from './text-background-layer-fragment.glsl';\nconst defaultProps = {\n  billboard: true,\n  sizeScale: 1,\n  sizeUnits: 'pixels',\n  sizeMinPixels: 0,\n  sizeMaxPixels: Number.MAX_SAFE_INTEGER,\n  padding: {\n    type: 'array',\n    value: [0, 0, 0, 0]\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getSize: {\n    type: 'accessor',\n    value: 1\n  },\n  getAngle: {\n    type: 'accessor',\n    value: 0\n  },\n  getPixelOffset: {\n    type: 'accessor',\n    value: [0, 0]\n  },\n  getBoundingRect: {\n    type: 'accessor',\n    value: [0, 0, 0, 0]\n  },\n  getFillColor: {\n    type: 'accessor',\n    value: [0, 0, 0, 255]\n  },\n  getLineColor: {\n    type: 'accessor',\n    value: [0, 0, 0, 255]\n  },\n  getLineWidth: {\n    type: 'accessor',\n    value: 1\n  }\n};\nexport default class TextBackgroundLayer extends Layer {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", void 0);\n  }\n\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, picking]\n    });\n  }\n\n  initializeState() {\n    this.getAttributeManager().addInstanced({\n      instancePositions: {\n        size: 3,\n        type: 5130,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceSizes: {\n        size: 1,\n        transition: true,\n        accessor: 'getSize',\n        defaultValue: 1\n      },\n      instanceAngles: {\n        size: 1,\n        transition: true,\n        accessor: 'getAngle'\n      },\n      instanceRects: {\n        size: 4,\n        accessor: 'getBoundingRect'\n      },\n      instancePixelOffsets: {\n        size: 2,\n        transition: true,\n        accessor: 'getPixelOffset'\n      },\n      instanceFillColors: {\n        size: 4,\n        transition: true,\n        normalized: true,\n        type: 5121,\n        accessor: 'getFillColor',\n        defaultValue: [0, 0, 0, 255]\n      },\n      instanceLineColors: {\n        size: 4,\n        transition: true,\n        normalized: true,\n        type: 5121,\n        accessor: 'getLineColor',\n        defaultValue: [0, 0, 0, 255]\n      },\n      instanceLineWidths: {\n        size: 1,\n        transition: true,\n        accessor: 'getLineWidth',\n        defaultValue: 1\n      }\n    });\n  }\n\n  updateState(params) {\n    super.updateState(params);\n    const {\n      changeFlags\n    } = params;\n\n    if (changeFlags.extensionsChanged) {\n      var _this$state$model;\n\n      const {\n        gl\n      } = this.context;\n      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();\n      this.state.model = this._getModel(gl);\n      this.getAttributeManager().invalidateAll();\n    }\n  }\n\n  draw({\n    uniforms\n  }) {\n    const {\n      billboard,\n      sizeScale,\n      sizeUnits,\n      sizeMinPixels,\n      sizeMaxPixels,\n      getLineWidth\n    } = this.props;\n    let {\n      padding\n    } = this.props;\n\n    if (padding.length < 4) {\n      padding = [padding[0], padding[1], padding[0], padding[1]];\n    }\n\n    this.state.model.setUniforms(uniforms).setUniforms({\n      billboard,\n      stroked: Boolean(getLineWidth),\n      padding,\n      sizeUnits: UNIT[sizeUnits],\n      sizeScale,\n      sizeMinPixels,\n      sizeMaxPixels\n    }).draw();\n  }\n\n  _getModel(gl) {\n    const positions = [0, 0, 1, 0, 1, 1, 0, 1];\n    return new Model(gl, { ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: 6,\n        vertexCount: 4,\n        attributes: {\n          positions: {\n            size: 2,\n            value: new Float32Array(positions)\n          }\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n}\n\n_defineProperty(TextBackgroundLayer, \"defaultProps\", defaultProps);\n\n_defineProperty(TextBackgroundLayer, \"layerName\", 'TextBackgroundLayer');\n//# sourceMappingURL=text-background-layer.js.map","export default \"#define SHADER_NAME text-background-layer-vertex-shader\\n\\nattribute vec2 positions;\\n\\nattribute vec3 instancePositions;\\nattribute vec3 instancePositions64Low;\\nattribute vec4 instanceRects;\\nattribute float instanceSizes;\\nattribute float instanceAngles;\\nattribute vec2 instancePixelOffsets;\\nattribute float instanceLineWidths;\\nattribute vec4 instanceFillColors;\\nattribute vec4 instanceLineColors;\\nattribute vec3 instancePickingColors;\\n\\nuniform bool billboard;\\nuniform float opacity;\\nuniform float sizeScale;\\nuniform float sizeMinPixels;\\nuniform float sizeMaxPixels;\\nuniform vec4 padding;\\nuniform int sizeUnits;\\n\\nvarying vec4 vFillColor;\\nvarying vec4 vLineColor;\\nvarying float vLineWidth;\\nvarying vec2 uv;\\nvarying vec2 dimensions;\\n\\nvec2 rotate_by_angle(vec2 vertex, float angle) {\\n  float angle_radian = radians(angle);\\n  float cos_angle = cos(angle_radian);\\n  float sin_angle = sin(angle_radian);\\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\\n  return rotationMatrix * vertex;\\n}\\n\\nvoid main(void) {\\n  geometry.worldPosition = instancePositions;\\n  geometry.uv = positions;\\n  geometry.pickingColor = instancePickingColors;\\n  uv = positions;\\n  vLineWidth = instanceLineWidths;\\n\\n  // convert size in meters to pixels, then scaled and clamp\\n\\n  // project meters to pixels and clamp to limits\\n  float sizePixels = clamp(\\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),\\n    sizeMinPixels, sizeMaxPixels\\n  );\\n\\n  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;\\n\\n  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);\\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\\n  pixelOffset += instancePixelOffsets;\\n  pixelOffset.y *= -1.0;\\n\\n  if (billboard)  {\\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\\n    vec3 offset = vec3(pixelOffset, 0.0);\\n    DECKGL_FILTER_SIZE(offset, geometry);\\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\\n  } else {\\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\\n    DECKGL_FILTER_SIZE(offset_common, geometry);\\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\\n  }\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n\\n  // Apply opacity to instance color, or return instance picking color\\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\\n}\\n\";\n//# sourceMappingURL=text-background-layer-vertex.glsl.js.map","export default \"#define SHADER_NAME text-background-layer-fragment-shader\\n\\nprecision highp float;\\n\\nuniform bool stroked;\\n\\nvarying vec4 vFillColor;\\nvarying vec4 vLineColor;\\nvarying float vLineWidth;\\nvarying vec2 uv;\\nvarying vec2 dimensions;\\n\\nvoid main(void) {\\n  geometry.uv = uv;\\n\\n  vec2 pixelPosition = uv * dimensions;\\n  if (stroked) {\\n    float distToEdge = min(\\n      min(pixelPosition.x, dimensions.x - pixelPosition.x),\\n      min(pixelPosition.y, dimensions.y - pixelPosition.y)\\n    );\\n    float isBorder = smoothedge(distToEdge, vLineWidth);\\n    gl_FragColor = mix(vFillColor, vLineColor, isBorder);\\n  } else {\\n    gl_FragColor = vFillColor;\\n  }\\n\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\";\n//# sourceMappingURL=text-background-layer-fragment.glsl.js.map","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { CompositeLayer, createIterable } from '@deck.gl/core';\nimport MultiIconLayer from './multi-icon-layer/multi-icon-layer';\nimport FontAtlasManager, { DEFAULT_FONT_SETTINGS, setFontAtlasCacheLimit } from './font-atlas-manager';\nimport { transformParagraph, getTextFromBuffer } from './utils';\nimport TextBackgroundLayer from './text-background-layer/text-background-layer';\nconst TEXT_ANCHOR = {\n  start: 1,\n  middle: 0,\n  end: -1\n};\nconst ALIGNMENT_BASELINE = {\n  top: 1,\n  center: 0,\n  bottom: -1\n};\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst DEFAULT_LINE_HEIGHT = 1.0;\nconst defaultProps = {\n  billboard: true,\n  sizeScale: 1,\n  sizeUnits: 'pixels',\n  sizeMinPixels: 0,\n  sizeMaxPixels: Number.MAX_SAFE_INTEGER,\n  background: false,\n  getBackgroundColor: {\n    type: 'accessor',\n    value: [255, 255, 255, 255]\n  },\n  getBorderColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getBorderWidth: {\n    type: 'accessor',\n    value: 0\n  },\n  backgroundPadding: {\n    type: 'array',\n    value: [0, 0, 0, 0]\n  },\n  characterSet: {\n    type: 'object',\n    value: DEFAULT_FONT_SETTINGS.characterSet\n  },\n  fontFamily: DEFAULT_FONT_SETTINGS.fontFamily,\n  fontWeight: DEFAULT_FONT_SETTINGS.fontWeight,\n  lineHeight: DEFAULT_LINE_HEIGHT,\n  outlineWidth: {\n    type: 'number',\n    value: 0,\n    min: 0\n  },\n  outlineColor: {\n    type: 'color',\n    value: DEFAULT_COLOR\n  },\n  fontSettings: {},\n  wordBreak: 'break-word',\n  maxWidth: {\n    type: 'number',\n    value: -1\n  },\n  getText: {\n    type: 'accessor',\n    value: x => x.text\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getSize: {\n    type: 'accessor',\n    value: 32\n  },\n  getAngle: {\n    type: 'accessor',\n    value: 0\n  },\n  getTextAnchor: {\n    type: 'accessor',\n    value: 'middle'\n  },\n  getAlignmentBaseline: {\n    type: 'accessor',\n    value: 'center'\n  },\n  getPixelOffset: {\n    type: 'accessor',\n    value: [0, 0]\n  },\n  backgroundColor: {\n    deprecatedFor: ['background', 'getBackgroundColor']\n  }\n};\nexport default class TextLayer extends CompositeLayer {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", void 0);\n\n    _defineProperty(this, \"getBoundingRect\", (object, objectInfo) => {\n      const iconMapping = this.state.fontAtlasManager.mapping;\n      const getText = this.state.getText;\n      const {\n        wordBreak,\n        maxWidth,\n        lineHeight,\n        getTextAnchor,\n        getAlignmentBaseline\n      } = this.props;\n      const paragraph = getText(object, objectInfo) || '';\n      const {\n        size: [width, height]\n      } = transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping);\n      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor];\n      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === 'function' ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];\n      return [(anchorX - 1) * width / 2, (anchorY - 1) * height / 2, width, height];\n    });\n\n    _defineProperty(this, \"getIconOffsets\", (object, objectInfo) => {\n      const iconMapping = this.state.fontAtlasManager.mapping;\n      const getText = this.state.getText;\n      const {\n        wordBreak,\n        maxWidth,\n        lineHeight,\n        getTextAnchor,\n        getAlignmentBaseline\n      } = this.props;\n      const paragraph = getText(object, objectInfo) || '';\n      const {\n        x,\n        y,\n        rowWidth,\n        size: [width, height]\n      } = transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping);\n      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor];\n      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === 'function' ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];\n      const numCharacters = x.length;\n      const offsets = new Array(numCharacters * 2);\n      let index = 0;\n\n      for (let i = 0; i < numCharacters; i++) {\n        const rowOffset = (1 - anchorX) * (width - rowWidth[i]) / 2;\n        offsets[index++] = (anchorX - 1) * width / 2 + rowOffset + x[i];\n        offsets[index++] = (anchorY - 1) * height / 2 + y[i];\n      }\n\n      return offsets;\n    });\n  }\n\n  initializeState() {\n    this.state = {\n      styleVersion: 0,\n      fontAtlasManager: new FontAtlasManager()\n    };\n  }\n\n  updateState(params) {\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = params;\n    const textChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText);\n\n    if (textChanged) {\n      this._updateText();\n    }\n\n    const fontChanged = this._updateFontAtlas();\n\n    const styleChanged = fontChanged || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth;\n\n    if (styleChanged) {\n      this.setState({\n        styleVersion: this.state.styleVersion + 1\n      });\n    }\n  }\n\n  getPickingInfo({\n    info\n  }) {\n    info.object = info.index >= 0 ? this.props.data[info.index] : null;\n    return info;\n  }\n\n  _updateFontAtlas() {\n    const {\n      fontSettings,\n      fontFamily,\n      fontWeight\n    } = this.props;\n    const {\n      fontAtlasManager,\n      characterSet\n    } = this.state;\n    const fontProps = { ...fontSettings,\n      characterSet,\n      fontFamily,\n      fontWeight\n    };\n\n    if (!fontAtlasManager.mapping) {\n      fontAtlasManager.setProps(fontProps);\n      return true;\n    }\n\n    for (const key in fontProps) {\n      if (fontProps[key] !== fontAtlasManager.props[key]) {\n        fontAtlasManager.setProps(fontProps);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _updateText() {\n    var _attributes;\n\n    const {\n      data,\n      characterSet\n    } = this.props;\n    const textBuffer = (_attributes = data.attributes) === null || _attributes === void 0 ? void 0 : _attributes.getText;\n    let {\n      getText\n    } = this.props;\n    let startIndices = data.startIndices;\n    let numInstances;\n    const autoCharacterSet = characterSet === 'auto' && new Set();\n\n    if (textBuffer && startIndices) {\n      const {\n        texts,\n        characterCount\n      } = getTextFromBuffer({ ...(ArrayBuffer.isView(textBuffer) ? {\n          value: textBuffer\n        } : textBuffer),\n        length: data.length,\n        startIndices,\n        characterSet: autoCharacterSet\n      });\n      numInstances = characterCount;\n\n      getText = (_, {\n        index\n      }) => texts[index];\n    } else {\n      const {\n        iterable,\n        objectInfo\n      } = createIterable(data);\n      startIndices = [0];\n      numInstances = 0;\n\n      for (const object of iterable) {\n        objectInfo.index++;\n        const text = Array.from(getText(object, objectInfo) || '');\n\n        if (autoCharacterSet) {\n          text.forEach(autoCharacterSet.add, autoCharacterSet);\n        }\n\n        numInstances += text.length;\n        startIndices.push(numInstances);\n      }\n    }\n\n    this.setState({\n      getText,\n      startIndices,\n      numInstances,\n      characterSet: autoCharacterSet || characterSet\n    });\n  }\n\n  renderLayers() {\n    const {\n      startIndices,\n      numInstances,\n      getText,\n      fontAtlasManager: {\n        scale,\n        texture,\n        mapping\n      },\n      styleVersion\n    } = this.state;\n    const {\n      data,\n      _dataDiff,\n      getPosition,\n      getColor,\n      getSize,\n      getAngle,\n      getPixelOffset,\n      getBackgroundColor,\n      getBorderColor,\n      getBorderWidth,\n      backgroundPadding,\n      background,\n      billboard,\n      fontSettings,\n      outlineWidth,\n      outlineColor,\n      sizeScale,\n      sizeUnits,\n      sizeMinPixels,\n      sizeMaxPixels,\n      transitions,\n      updateTriggers\n    } = this.props;\n    const CharactersLayerClass = this.getSubLayerClass('characters', MultiIconLayer);\n    const BackgroundLayerClass = this.getSubLayerClass('background', TextBackgroundLayer);\n    return [background && new BackgroundLayerClass({\n      getFillColor: getBackgroundColor,\n      getLineColor: getBorderColor,\n      getLineWidth: getBorderWidth,\n      padding: backgroundPadding,\n      getPosition,\n      getSize,\n      getAngle,\n      getPixelOffset,\n      billboard,\n      sizeScale: sizeScale / this.state.fontAtlasManager.props.fontSize,\n      sizeUnits,\n      sizeMinPixels,\n      sizeMaxPixels,\n      transitions: transitions && {\n        getPosition: transitions.getPosition,\n        getAngle: transitions.getAngle,\n        getSize: transitions.getSize,\n        getFillColor: transitions.getBackgroundColor,\n        getLineColor: transitions.getBorderColor,\n        getLineWidth: transitions.getBorderWidth,\n        getPixelOffset: transitions.getPixelOffset\n      }\n    }, this.getSubLayerProps({\n      id: 'background',\n      updateTriggers: {\n        getPosition: updateTriggers.getPosition,\n        getAngle: updateTriggers.getAngle,\n        getSize: updateTriggers.getSize,\n        getFillColor: updateTriggers.getBackgroundColor,\n        getLineColor: updateTriggers.getBorderColor,\n        getLineWidth: updateTriggers.getBorderWidth,\n        getPixelOffset: updateTriggers.getPixelOffset,\n        getBoundingRect: {\n          getText: updateTriggers.getText,\n          getTextAnchor: updateTriggers.getTextAnchor,\n          getAlignmentBaseline: updateTriggers.getAlignmentBaseline,\n          styleVersion\n        }\n      }\n    }), {\n      data: data.attributes && data.attributes.background ? {\n        length: data.length,\n        attributes: data.attributes.background\n      } : data,\n      _dataDiff,\n      autoHighlight: false,\n      getBoundingRect: this.getBoundingRect\n    }), new CharactersLayerClass({\n      sdf: fontSettings.sdf,\n      smoothing: Number.isFinite(fontSettings.smoothing) ? fontSettings.smoothing : DEFAULT_FONT_SETTINGS.smoothing,\n      outlineWidth,\n      outlineColor,\n      iconAtlas: texture,\n      iconMapping: mapping,\n      getPosition,\n      getColor,\n      getSize,\n      getAngle,\n      getPixelOffset,\n      billboard,\n      sizeScale: sizeScale * scale,\n      sizeUnits,\n      sizeMinPixels: sizeMinPixels * scale,\n      sizeMaxPixels: sizeMaxPixels * scale,\n      transitions: transitions && {\n        getPosition: transitions.getPosition,\n        getAngle: transitions.getAngle,\n        getColor: transitions.getColor,\n        getSize: transitions.getSize,\n        getPixelOffset: transitions.getPixelOffset\n      }\n    }, this.getSubLayerProps({\n      id: 'characters',\n      updateTriggers: {\n        getIcon: updateTriggers.getText,\n        getPosition: updateTriggers.getPosition,\n        getAngle: updateTriggers.getAngle,\n        getColor: updateTriggers.getColor,\n        getSize: updateTriggers.getSize,\n        getPixelOffset: updateTriggers.getPixelOffset,\n        getIconOffsets: {\n          getText: updateTriggers.getText,\n          getTextAnchor: updateTriggers.getTextAnchor,\n          getAlignmentBaseline: updateTriggers.getAlignmentBaseline,\n          styleVersion\n        }\n      }\n    }), {\n      data,\n      _dataDiff,\n      startIndices,\n      numInstances,\n      getIconOffsets: this.getIconOffsets,\n      getIcon: getText\n    })];\n  }\n\n  static set fontAtlasCacheLimit(limit) {\n    setFontAtlasCacheLimit(limit);\n  }\n\n}\n\n_defineProperty(TextLayer, \"defaultProps\", defaultProps);\n\n_defineProperty(TextLayer, \"layerName\", 'TextLayer');\n//# sourceMappingURL=text-layer.js.map"],"names":["CompositeLayer","Layer","isComposite","isLoaded","super","this","getSubLayers","every","layer","internalState","subLayers","initializeState","context","setState","updateObject","setNeedsUpdate","getPickingInfo","info","object","__source","parent","id","index","filterSubLayer","shouldRenderSubLayer","subLayerId","data","length","getSubLayerClass","DefaultLayerClass","_subLayerProps","overridingProps","props","type","getSubLayerRow","row","sourceObject","sourceObjectIndex","getSubLayerAccessor","accessor","objectInfo","target","x","i","getSubLayerProps","sublayerProps","_this$props$updateTri","opacity","pickable","visible","parameters","getPolygonOffset","highlightedObjectIndex","autoHighlight","highlightColor","coordinateSystem","coordinateOrigin","wrapLongitude","positionFormat","modelMatrix","extensions","fetch","operation","newProps","updateTriggers","overridingSublayerProps","overridingSublayerTriggers","sublayerId","propTypes","constructor","_propTypes","subLayerPropTypes","key","propType","Object","assign","concat","__spreadValues","all","extension","passThroughProps","call","_updateAutoHighlight","updateAutoHighlight","_getAttributeManager","_postUpdate","updateParams","forceUpdate","shouldUpdate","needsUpdate","subLayersList","renderLayers","flatten","Boolean","debug","_defineProperty","noop","DEFAULT_TEXTURE_PARAMETERS","resizeImage","ctx","imageData","width","height","canvas","clearRect","drawImage","getIconId","icon","url","buildRowMapping","mapping","columns","yOffset","xOffset","__spreadProps","y","IconManager","gl","onUpdate","onError","finalize","_this$_texture","_texture","delete","getTexture","_externalTexture","getIconMapping","_autoPacking","_mapping","setProps","loadOptions","autoPacking","iconAtlas","iconMapping","textureParameters","_this$_texture2","_loadOptions","_textureParameters","_pendingCount","packIcons","getIcon","document","icons","values","cachedIcons","iterable","createIterable","Error","source","sourceIndex","getDiffIcons","rowHeight","canvasHeight","buffer","canvasWidth","push","Math","max","number","pow","ceil","log2","buildMapping","_buffer","_canvasWidth","_rowHeight","_xOffset","_yOffset","_canvasHeight","Texture2D","texture","oldWidth","oldHeight","newTexture","copyToTexture","targetY","resizeTexture","_canvas","createElement","_loadIcons","getContext","load","ImageLoader","then","setSubImageData","generateMipmap","catch","error","finally","DEFAULT_COLOR","defaultProps","value","async","sizeScale","min","billboard","sizeUnits","sizeMinPixels","sizeMaxPixels","Number","MAX_SAFE_INTEGER","alphaCutoff","getPosition","position","getColor","getSize","getAngle","getPixelOffset","onIconError","compare","optional","IconLayer","args","getShaders","vs","fs","modules","project32","picking","state","iconManager","_onUpdate","bind","_onError","getAttributeManager","addInstanced","instancePositions","size","fp64","use64bitPositions","transition","instanceSizes","defaultValue","instanceOffsets","transform","getInstanceOffset","instanceIconFrames","getInstanceIconFrame","instanceColorModes","getInstanceColorMode","instanceColors","colorFormat","normalized","instanceAngles","instancePixelOffset","updateState","params","oldProps","changeFlags","attributeManager","prePacked","isAsyncPropLoading","invalidate","dataChanged","updateTriggersChanged","extensionsChanged","_this$state$model","model","_getModel","invalidateAll","finalizeState","draw","uniforms","iconsTexture","setUniforms","iconsTextureDim","UNIT","Model","geometry","Geometry","drawMode","attributes","positions","Float32Array","isInstanced","setNeedsRedraw","evt","_this$getCurrentLayer","getCurrentLayer","log","message","anchorX","anchorY","mask","radiusUnits","radiusScale","radiusMinPixels","radiusMaxPixels","lineWidthUnits","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","stroked","filled","antialiasing","getRadius","getFillColor","getLineColor","getLineWidth","strokeWidth","deprecatedFor","outline","ScatterplotLayer","instanceRadius","instanceFillColors","instanceLineColors","instanceLineWidths","vertexCount","EMPTY_ARRAY","MultiIconLayer","instancePickingColors","encodePickingColor","outlineColor","map","isFinite","sdf","outlineWidth","warn","smoothing","outlineBuffer","gamma","Array","from","flatMap","getIconOffsets","offsets","tinySdfModule","exports","TinySDF","tinySdf","default","INF","fontSize","radius","cutoff","fontFamily","fontWeight","gridSize","font","textAlign","fillStyle","gridOuter","Float64Array","gridInner","f","z","v","Uint16Array","useMetrics","measureText","actualBoundingBoxLeft","middle","round","userAgent","indexOf","edt","edt1d","grid","offset","stride","q","k","s","r","prototype","_draw","char","getMetrics","glyphWidth","glyphHeight","top","imgTop","imgLeft","baselinePosition","imgData","textMetrics","advance","doubleBuffer","floor","actualBoundingBoxAscent","actualBoundingBoxRight","actualBoundingBoxDescent","textBaseline","fillText","getImageData","alphaChannel","Uint8ClampedArray","fill","j","a","b","c","prepareGrids","d","sqrt","extractAlpha","metrics","sdfWidth","sdfHeight","left","drawWithMetrics","SINGLE_LINE","getTextWidth","text","startIndex","endIndex","_mapping$character","breakAll","maxWidth","rowStartCharIndex","rowOffsetLeft","textWidth","autoWrapping","wordBreak","result","groupStartCharIndex","groupEndCharIndex","groupWidth","breakWord","transformRow","line","leftOffsets","rowSize","character","frame","codePointAt","transformParagraph","paragraph","lineHeight","characters","numCharacters","rowWidth","autoWrappingEnabled","rowOffsetTop","lineStartIndex","lineEndIndex","rows","rowIndex","rowStart","rowEnd","LRUCache","limit","get","_cache","_deleteOrder","_appendOrder","set","keys","_order","splice","DEFAULT_FONT_SETTINGS","characterSet","charSet","String","fromCharCode","getDefaultCharacterSet","cache","populateAlphaChannel","setTextStyle","FontAtlasManager","_atlas","scale","oldKey","_key","_getKey","cacheKey","newCharSet","Set","cachedFontAtlas","has","getNewChars","fontAtlas","_generateFontAtlas","getFontWidth","fontHeight","maxCanvasWidth","putImageData","tinySDF","padding","getBoundingRect","TextBackgroundLayer","instanceRects","instancePixelOffsets","TEXT_ANCHOR","start","end","ALIGNMENT_BASELINE","center","bottom","background","getBackgroundColor","getBorderColor","getBorderWidth","backgroundPadding","fontSettings","getText","getTextAnchor","getAlignmentBaseline","backgroundColor","TextLayer","fontAtlasManager","rowOffset","styleVersion","_updateText","_updateFontAtlas","fontProps","_attributes","textBuffer","numInstances","startIndices","autoCharacterSet","texts","characterCount","bytesPerElement","BYTES_PER_ELEMENT","elementStride","elementOffset","codes","ArrayType","codesAtIndex","subarray","fromCodePoint","apply","forEach","add","charCode","getTextFromBuffer","ArrayBuffer","isView","_","_dataDiff","transitions","CharactersLayerClass","BackgroundLayerClass","fontAtlasCacheLimit","assert","setFontAtlasCacheLimit"],"mappings":"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"}