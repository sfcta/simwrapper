var e=Object.defineProperty,t=Object.defineProperties,i=Object.getOwnPropertyDescriptors,n=Object.getOwnPropertySymbols,s=Object.prototype.hasOwnProperty,o=Object.prototype.propertyIsEnumerable,a=(t,i,n)=>i in t?e(t,i,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[i]=n,r=(e,t)=>{for(var i in t||(t={}))s.call(t,i)&&a(e,i,t[i]);if(n)for(var i of n(t))o.call(t,i)&&a(e,i,t[i]);return e},l=(e,n)=>t(e,i(n));import{a as c,a2 as g,a3 as d,_ as u,T as f,P as h,Q as p,S as m,W as x,b as v,c as y,U as _,M as b,G as P,l as C}from"./layer.b20bd88e.js";class S extends c{get isComposite(){return!0}get isLoaded(){return super.isLoaded&&this.getSubLayers().every((e=>e.isLoaded))}getSubLayers(){return this.internalState&&this.internalState.subLayers||[]}initializeState(e){}setState(e){super.setState(e),this.setNeedsUpdate()}getPickingInfo({info:e}){const{object:t}=e;return t&&t.__source&&t.__source.parent&&t.__source.parent.id===this.id?(e.object=t.__source.object,e.index=t.__source.index,e):e}filterSubLayer(e){return!0}shouldRenderSubLayer(e,t){return t&&t.length}getSubLayerClass(e,t){const{_subLayerProps:i}=this.props;return i&&i[e]&&i[e].type||t}getSubLayerRow(e,t,i){return e.__source={parent:this,object:t,index:i},e}getSubLayerAccessor(e){if("function"==typeof e){const t={index:-1,data:this.props.data,target:[]};return(i,n)=>i&&i.__source?(t.index=i.__source.index,e(i.__source.object,t)):e(i,n)}return e}getSubLayerProps(e={}){var t;const{opacity:i,pickable:n,visible:s,parameters:o,getPolygonOffset:a,highlightedObjectIndex:l,autoHighlight:c,highlightColor:g,coordinateSystem:d,coordinateOrigin:u,wrapLongitude:f,positionFormat:h,modelMatrix:p,extensions:m,fetch:x,operation:v,_subLayerProps:y}=this.props,_={id:"",updateTriggers:{},opacity:i,pickable:n,visible:s,parameters:o,getPolygonOffset:a,highlightedObjectIndex:l,autoHighlight:c,highlightColor:g,coordinateSystem:d,coordinateOrigin:u,wrapLongitude:f,positionFormat:h,modelMatrix:p,extensions:m,fetch:x,operation:v},b=y&&e.id&&y[e.id],P=b&&b.updateTriggers,C=e.id||"sublayer";if(b){const t=this.constructor._propTypes,i=e.type?e.type._propTypes:{};for(const e in b){const n=i[e]||t[e];n&&"accessor"===n.type&&(b[e]=this.getSubLayerAccessor(b[e]))}}Object.assign(_,e,b),_.id="".concat(this.props.id,"-").concat(C),_.updateTriggers=r(r({all:null===(t=this.props.updateTriggers)||void 0===t?void 0:t.all},e.updateTriggers),P);for(const r of m){const e=r.getSubLayerProps.call(this,r);e&&Object.assign(_,e,{updateTriggers:Object.assign(_.updateTriggers,e.updateTriggers)})}return _}_updateAutoHighlight(e){for(const t of this.getSubLayers())t.updateAutoHighlight(e)}_getAttributeManager(){return null}_postUpdate(e,t){let i=this.internalState.subLayers;const n=!i||this.needsUpdate();if(n){const e=this.renderLayers();i=g(e,Boolean),this.internalState.subLayers=i}d("compositeLayer.renderLayers",this,n,i);for(const s of i)s.parent=this}}u(S,"layerName","CompositeLayer");const z=()=>{},M={10241:9987,10240:9729,10242:33071,10243:33071};function L(e,t,i,n){return i===t.width&&n===t.height?t:(e.canvas.height=n,e.canvas.width=i,e.clearRect(0,0,e.canvas.width,e.canvas.height),e.drawImage(t,0,0,t.width,t.height,0,0,i,n),e.canvas)}function O(e){return e&&(e.id||e.url)}function w(e,t,i){for(let n=0;n<t.length;n++){const{icon:s,xOffset:o}=t[n];e[O(s)]=l(r({},s),{x:o,y:i})}}class A{constructor(e,{onUpdate:t=z,onError:i=z}){u(this,"gl",void 0),u(this,"onUpdate",void 0),u(this,"onError",void 0),u(this,"_loadOptions",null),u(this,"_texture",null),u(this,"_externalTexture",null),u(this,"_mapping",{}),u(this,"_textureParameters",null),u(this,"_pendingCount",0),u(this,"_autoPacking",!1),u(this,"_xOffset",0),u(this,"_yOffset",0),u(this,"_rowHeight",0),u(this,"_buffer",4),u(this,"_canvasWidth",1024),u(this,"_canvasHeight",0),u(this,"_canvas",null),this.gl=e,this.onUpdate=t,this.onError=i}finalize(){var e;null===(e=this._texture)||void 0===e||e.delete()}getTexture(){return this._texture||this._externalTexture}getIconMapping(e){const t=this._autoPacking?O(e):e;return this._mapping[t]||{}}setProps({loadOptions:e,autoPacking:t,iconAtlas:i,iconMapping:n,textureParameters:s}){var o;(e&&(this._loadOptions=e),void 0!==t&&(this._autoPacking=t),n&&(this._mapping=n),i)&&(null===(o=this._texture)||void 0===o||o.delete(),this._texture=null,this._externalTexture=i);s&&(this._textureParameters=s)}get isLoaded(){return 0===this._pendingCount}packIcons(e,t){if(!this._autoPacking||"undefined"==typeof document)return;const i=Object.values(function(e,t,i){if(!e||!t)return null;i=i||{};const n={},{iterable:s,objectInfo:o}=x(e);for(const a of s){o.index++;const e=t(a,o),s=O(e);if(!e)throw new Error("Icon is missing.");if(!e.url)throw new Error("Icon url is missing.");n[s]||i[s]&&e.url===i[s].url||(n[s]=l(r({},e),{source:a,sourceIndex:o.index}))}return n}(e,t,this._mapping)||{});if(i.length>0){const{mapping:e,xOffset:t,yOffset:n,rowHeight:s,canvasHeight:o}=function({icons:e,buffer:t,mapping:i={},xOffset:n=0,yOffset:s=0,rowHeight:o=0,canvasWidth:a}){let r=[];for(let c=0;c<e.length;c++){const l=e[c];if(!i[O(l)]){const{height:e,width:c}=l;n+c+t>a&&(w(i,r,s),n=0,s=o+s+t,o=0,r=[]),r.push({icon:l,xOffset:n}),n=n+c+t,o=Math.max(o,e)}}return r.length>0&&w(i,r,s),{mapping:i,rowHeight:o,xOffset:n,yOffset:s,canvasWidth:a,canvasHeight:(l=o+s+t,Math.pow(2,Math.ceil(Math.log2(l))))};var l}({icons:i,buffer:this._buffer,canvasWidth:this._canvasWidth,mapping:this._mapping,rowHeight:this._rowHeight,xOffset:this._xOffset,yOffset:this._yOffset});this._rowHeight=s,this._mapping=e,this._xOffset=t,this._yOffset=n,this._canvasHeight=o,this._texture||(this._texture=new f(this.gl,{width:this._canvasWidth,height:this._canvasHeight,parameters:this._textureParameters||M})),this._texture.height!==this._canvasHeight&&(this._texture=function(e,t,i,n){const s=e.width,o=e.height,a=new f(e.gl,{width:t,height:i,parameters:n});return m(e,a,{targetY:0,width:s,height:o}),e.delete(),a}(this._texture,this._canvasWidth,this._canvasHeight,this._textureParameters||M)),this.onUpdate(),this._canvas=this._canvas||document.createElement("canvas"),this._loadIcons(i)}}_loadIcons(e){const t=this._canvas.getContext("2d");for(const i of e)this._pendingCount++,h(i.url,p,this._loadOptions).then((e=>{const n=O(i),{x:s,y:o,width:a,height:r}=this._mapping[n],l=L(t,e,a,r);this._texture.setSubImageData({data:l,x:s,y:o,width:a,height:r}),this._texture.generateMipmap(),this.onUpdate()})).catch((e=>{this.onError({url:i.url,source:i.source,sourceIndex:i.sourceIndex,loadOptions:this._loadOptions,error:e})})).finally((()=>{this._pendingCount--}))}}const I=[0,0,0,255],F={iconAtlas:{type:"image",value:null,async:!0},iconMapping:{type:"object",value:{},async:!0},sizeScale:{type:"number",value:1,min:0},billboard:!0,sizeUnits:"pixels",sizeMinPixels:{type:"number",min:0,value:0},sizeMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},alphaCutoff:{type:"number",value:.05,min:0,max:1},getPosition:{type:"accessor",value:e=>e.position},getIcon:{type:"accessor",value:e=>e.icon},getColor:{type:"accessor",value:I},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},onIconError:{type:"function",value:null,compare:!1,optional:!0}};class T extends c{constructor(...e){super(...e),u(this,"state",void 0)}getShaders(){return super.getShaders({vs:'#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\nuniform int sizeUnits;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n\n  vec2 iconSize = instanceIconFrames.zw;\n  // convert size in meters to pixels, then scaled and clamp\n \n  // project meters to pixels and clamp to limits \n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits), \n    sizeMinPixels, sizeMaxPixels\n  );\n\n  // scale icon height to match instanceSize\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n\n  // scale and rotate vertex in "pixel" value and convert back to fraction in clipspace\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset += instancePixelOffset;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  vColorMode = instanceColorModes;\n}\n',fs:"#define SHADER_NAME icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float alphaCutoff;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n\n  // if colorMode == 0, use pixel color from the texture\n  // if colorMode == 1 or rendering picking buffer, use texture as transparency mask\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\n  // Take the global opacity and the alpha from vColor into account for the alpha component\n  float a = texColor.a * opacity * vColor.a;\n\n  if (a < alphaCutoff) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, a);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[v,y]})}initializeState(){this.state={iconManager:new A(this.context.gl,{onUpdate:this._onUpdate.bind(this),onError:this._onError.bind(this)})};this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceOffsets:{size:2,accessor:"getIcon",transform:this.getInstanceOffset},instanceIconFrames:{size:4,accessor:"getIcon",transform:this.getInstanceIconFrame},instanceColorModes:{size:1,type:5121,accessor:"getIcon",transform:this.getInstanceColorMode},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getColor",defaultValue:I},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instancePixelOffset:{size:2,transition:!0,accessor:"getPixelOffset"}})}updateState(e){super.updateState(e);const{props:t,oldProps:i,changeFlags:n}=e,s=this.getAttributeManager(),{iconAtlas:o,iconMapping:a,data:r,getIcon:l,textureParameters:c}=t,{iconManager:g}=this.state,d=o||this.internalState.isAsyncPropLoading("iconAtlas");if(g.setProps({loadOptions:t.loadOptions,autoPacking:!d,iconAtlas:o,iconMapping:d?a:null,textureParameters:c}),d?i.iconMapping!==t.iconMapping&&s.invalidate("getIcon"):(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getIcon))&&g.packIcons(r,l),n.extensionsChanged){var u;const{gl:e}=this.context;null===(u=this.state.model)||void 0===u||u.delete(),this.state.model=this._getModel(e),s.invalidateAll()}}get isLoaded(){return super.isLoaded&&this.state.iconManager.isLoaded}finalizeState(e){super.finalizeState(e),this.state.iconManager.finalize()}draw({uniforms:e}){const{sizeScale:t,sizeMinPixels:i,sizeMaxPixels:n,sizeUnits:s,billboard:o,alphaCutoff:a}=this.props,{iconManager:r}=this.state,l=r.getTexture();l&&this.state.model.setUniforms(e).setUniforms({iconsTexture:l,iconsTextureDim:[l.width,l.height],sizeUnits:_[s],sizeScale:t,sizeMinPixels:i,sizeMaxPixels:n,billboard:o,alphaCutoff:a}).draw()}_getModel(e){return new b(e,l(r({},this.getShaders()),{id:this.props.id,geometry:new P({drawMode:6,attributes:{positions:{size:2,value:new Float32Array([-1,-1,-1,1,1,1,1,-1])}}}),isInstanced:!0}))}_onUpdate(){this.setNeedsRedraw()}_onError(e){var t;const i=null===(t=this.getCurrentLayer())||void 0===t?void 0:t.props.onIconError;i?i(e):C.error(e.error.message)()}getInstanceOffset(e){const{width:t,height:i,anchorX:n=t/2,anchorY:s=i/2}=this.state.iconManager.getIconMapping(e);return[t/2-n,i/2-s]}getInstanceColorMode(e){return this.state.iconManager.getIconMapping(e).mask?1:0}getInstanceIconFrame(e){const{x:t,y:i,width:n,height:s}=this.state.iconManager.getIconMapping(e);return[t,i,n,s]}}u(T,"defaultProps",F),u(T,"layerName","IconLayer");const E=[0,0,0,255],k={radiusUnits:"meters",radiusScale:{type:"number",min:0,value:1},radiusMinPixels:{type:"number",min:0,value:0},radiusMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},lineWidthUnits:"meters",lineWidthScale:{type:"number",min:0,value:1},lineWidthMinPixels:{type:"number",min:0,value:0},lineWidthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},stroked:!1,filled:!0,billboard:!1,antialiasing:!0,getPosition:{type:"accessor",value:e=>e.position},getRadius:{type:"accessor",value:1},getFillColor:{type:"accessor",value:E},getLineColor:{type:"accessor",value:E},getLineWidth:{type:"accessor",value:1},strokeWidth:{deprecatedFor:"getLineWidth"},outline:{deprecatedFor:"stroked"},getColor:{deprecatedFor:["getFillColor","getLineColor"]}};class W extends c{getShaders(){return super.getShaders({vs:"#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\nuniform bool antialiasing;\nuniform bool billboard;\nuniform int radiusUnits;\nuniform int lineWidthUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n\n  // Multiply out radius and clamp to limits\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),\n    radiusMinPixels, radiusMaxPixels\n  );\n  \n  // Multiply out line width and clamp to limits\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n\n  // outer radius needs to offset by half stroke width\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n\n  // Expand geometry to accomodate edge smoothing\n  float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\n\n  // position on the containing square in [-1, 1] space\n  unitPosition = edgePadding * positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  if (billboard) {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = edgePadding * positions * outerRadiusPixels;\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n  }\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  // Apply opacity to instance color, or return instance picking color\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\nuniform float stroked;\nuniform bool antialiasing;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\n  float inCircle = antialiasing ? \n    smoothedge(distToCenter, outerRadiusPixels) : \n    step(distToCenter, outerRadiusPixels);\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  if (stroked > 0.5) {\n    float isLine = antialiasing ? \n      smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\n      step(innerUnitRadius * outerRadiusPixels, distToCenter);\n\n    if (filled) {\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n    }\n  } else if (filled) {\n    gl_FragColor = vFillColor;\n  } else {\n    discard;\n  }\n\n  gl_FragColor.a *= inCircle;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[v,y]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceRadius:{size:1,transition:!0,accessor:"getRadius",defaultValue:1},instanceFillColors:{size:this.props.colorFormat.length,transition:!0,normalized:!0,type:5121,accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:this.props.colorFormat.length,transition:!0,normalized:!0,type:5121,accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(e){if(super.updateState(e),e.changeFlags.extensionsChanged){var t;const{gl:e}=this.context;null===(t=this.state.model)||void 0===t||t.delete(),this.state.model=this._getModel(e),this.getAttributeManager().invalidateAll()}}draw({uniforms:e}){const{radiusUnits:t,radiusScale:i,radiusMinPixels:n,radiusMaxPixels:s,stroked:o,filled:a,billboard:r,antialiasing:l,lineWidthUnits:c,lineWidthScale:g,lineWidthMinPixels:d,lineWidthMaxPixels:u}=this.props;this.state.model.setUniforms(e).setUniforms({stroked:o?1:0,filled:a,billboard:r,antialiasing:l,radiusUnits:_[t],radiusScale:i,radiusMinPixels:n,radiusMaxPixels:s,lineWidthUnits:_[c],lineWidthScale:g,lineWidthMinPixels:d,lineWidthMaxPixels:u}).draw()}_getModel(e){return new b(e,l(r({},this.getShaders()),{id:this.props.id,geometry:new P({drawMode:6,vertexCount:4,attributes:{positions:{size:3,value:new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,1,0])}}}),isInstanced:!0}))}}u(W,"defaultProps",k),u(W,"layerName","ScatterplotLayer");const R=[];class B extends T{constructor(...e){super(...e),u(this,"state",void 0)}getShaders(){return l(r({},super.getShaders()),{fs:"#define SHADER_NAME multi-icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float gamma;\nuniform bool sdf;\nuniform float alphaCutoff;\nuniform float buffer;\nuniform float outlineBuffer;\nuniform vec4 outlineColor;\n\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  if (!picking_uActive) {\n    float alpha = texture2D(iconsTexture, vTextureCoords).a;\n    vec4 color = vColor;\n\n    // if enable sdf (signed distance fields)\n    if (sdf) {\n      float distance = alpha;\n      alpha = smoothstep(buffer - gamma, buffer + gamma, distance);\n\n      if (outlineBuffer > 0.0) {\n        float inFill = alpha;\n        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);\n        color = mix(outlineColor, vColor, inFill);\n        alpha = inBorder;\n      }\n    }\n\n    // Take the global opacity and the alpha from color into account for the alpha component\n    float a = alpha * color.a;\n    \n    if (a < alphaCutoff) {\n      discard;\n    }\n\n    gl_FragColor = vec4(color.rgb, a * opacity);\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n"})}initializeState(){super.initializeState();this.getAttributeManager().addInstanced({instanceOffsets:{size:2,accessor:"getIconOffsets"},instancePickingColors:{type:5121,size:3,accessor:(e,{index:t,target:i})=>this.encodePickingColor(t,i)}})}updateState(e){super.updateState(e);const{props:t,oldProps:i}=e;let{outlineColor:n}=t;n!==i.outlineColor&&(n=n.map((e=>e/255)),n[3]=Number.isFinite(n[3])?n[3]:1,this.setState({outlineColor:n})),!t.sdf&&t.outlineWidth&&C.warn("".concat(this.id,": fontSettings.sdf is required to render outline"))()}draw(e){const{sdf:t,smoothing:i,outlineWidth:n}=this.props,{outlineColor:s}=this.state;e.uniforms=l(r({},e.uniforms),{buffer:.75,outlineBuffer:n?Math.max(i,.75*(1-n)):-1,gamma:i,sdf:Boolean(t),outlineColor:s}),super.draw(e)}getInstanceOffset(e){return e?Array.from(e).flatMap((e=>super.getInstanceOffset(e))):R}getInstanceColorMode(e){return 1}getInstanceIconFrame(e){return e?Array.from(e).flatMap((e=>super.getInstanceIconFrame(e))):R}}u(B,"defaultProps",{getIconOffsets:{type:"accessor",value:e=>e.offsets},alphaCutoff:.001,smoothing:.1,outlineWidth:0,outlineColor:{type:"color",value:[0,0,0,255]}}),u(B,"layerName","MultiIconLayer");var U={exports:{}};U.exports=j,U.exports.default=j;var D=1e20;function j(e,t,i,n,s,o){this.fontSize=e||24,this.buffer=void 0===t?3:t,this.cutoff=n||.25,this.fontFamily=s||"sans-serif",this.fontWeight=o||"normal",this.radius=i||8;var a=this.size=this.fontSize+2*this.buffer,r=a+2*this.buffer;this.canvas=document.createElement("canvas"),this.canvas.width=this.canvas.height=a,this.ctx=this.canvas.getContext("2d"),this.ctx.font=this.fontWeight+" "+this.fontSize+"px "+this.fontFamily,this.ctx.textAlign="left",this.ctx.fillStyle="black",this.gridOuter=new Float64Array(r*r),this.gridInner=new Float64Array(r*r),this.f=new Float64Array(r),this.z=new Float64Array(r+1),this.v=new Uint16Array(r),this.useMetrics=void 0!==this.ctx.measureText("A").actualBoundingBoxLeft,this.middle=Math.round(a/2*(navigator.userAgent.indexOf("Gecko/")>=0?1.2:1))}function H(e,t,i,n,s,o){for(var a=0;a<t;a++)N(e,a,t,i,n,s,o);for(var r=0;r<i;r++)N(e,r*t,1,t,n,s,o)}function N(e,t,i,n,s,o,a){var r,l,c,g;for(o[0]=0,a[0]=-D,a[1]=D,r=0;r<n;r++)s[r]=e[t+r*i];for(r=1,l=0,c=0;r<n;r++){do{g=o[l],c=(s[r]-s[g]+r*r-g*g)/(r-g)/2}while(c<=a[l]&&--l>-1);o[++l]=r,a[l]=c,a[l+1]=D}for(r=0,l=0;r<n;r++){for(;a[l+1]<r;)l++;g=o[l],e[t+r*i]=s[g]+(r-g)*(r-g)}}j.prototype._draw=function(e,t){var i,n,s,o,a,r,l,c,g,d=this.ctx.measureText(e),u=d.width,f=2*this.buffer;t&&this.useMetrics?(a=Math.floor(d.actualBoundingBoxAscent),c=this.buffer+Math.ceil(d.actualBoundingBoxAscent),r=this.buffer,l=this.buffer,i=(n=Math.min(this.size,Math.ceil(d.actualBoundingBoxRight-d.actualBoundingBoxLeft)))+f,s=(o=Math.min(this.size-r,Math.ceil(d.actualBoundingBoxAscent+d.actualBoundingBoxDescent)))+f,this.ctx.textBaseline="alphabetic"):(i=n=this.size,s=o=this.size,a=19*this.fontSize/24,r=l=0,c=this.middle,this.ctx.textBaseline="middle"),n&&o&&(this.ctx.clearRect(l,r,n,o),this.ctx.fillText(e,this.buffer,c),g=this.ctx.getImageData(l,r,n,o));var h=new Uint8ClampedArray(i*s);return function(e,t,i,n,s,o,a){o.fill(D,0,t*i),a.fill(0,0,t*i);for(var r=(t-n)/2,l=0;l<s;l++)for(var c=0;c<n;c++){var g=(l+r)*t+c+r,d=e.data[4*(l*n+c)+3]/255;if(1===d)o[g]=0,a[g]=D;else if(0===d)o[g]=D,a[g]=0;else{var u=Math.max(0,.5-d),f=Math.max(0,d-.5);o[g]=u*u,a[g]=f*f}}}(g,i,s,n,o,this.gridOuter,this.gridInner),H(this.gridOuter,i,s,this.f,this.v,this.z),H(this.gridInner,i,s,this.f,this.v,this.z),function(e,t,i,n,s,o,a){for(var r=0;r<t*i;r++){var l=Math.sqrt(n[r])-Math.sqrt(s[r]);e[r]=Math.round(255-255*(l/o+a))}}(h,i,s,this.gridOuter,this.gridInner,this.radius,this.cutoff),{data:h,metrics:{width:n,height:o,sdfWidth:i,sdfHeight:s,top:a,left:0,advance:u}}},j.prototype.draw=function(e){return this._draw(e,!1).data},j.prototype.drawWithMetrics=function(e){return this._draw(e,!0)};var G=U.exports;const K=[];function V(e,t,i,n){let s=0;for(let a=t;a<i;a++){var o;s+=(null===(o=n[e[a]])||void 0===o?void 0:o.width)||0}return s}function X(e,t,i,n,s,o){let a=t,r=0;for(let l=t;l<i;l++){const t=V(e,l,l+1,s);r+t>n&&(a<l&&o.push(l),a=l,r=0),r+=t}return r}function Z(e,t,i,n,s=0,o){void 0===o&&(o=e.length);const a=[];return"break-all"===t?X(e,s,o,i,n,a):function(e,t,i,n,s,o){let a=t,r=t,l=t,c=0;for(let g=t;g<i;g++)if(" "===e[g]?l=g+1:" "!==e[g+1]&&g+1!==i||(l=g+1),l>r){let t=V(e,r,l,s);c+t>n&&(a<r&&(o.push(r),a=r,c=0),t>n&&(t=X(e,r,l,n,s,o),a=o[o.length-1])),r=l,c+=t}}(e,s,o,i,n,a),a}function q(e,t,i,n,s,o){let a=0,r=0;for(let l=t;l<i;l++){const t=e[l],i=n[t];i?(r||(r=i.height),s[l]=a+i.width/2,a+=i.width):(C.warn("Missing character: ".concat(t," (").concat(t.codePointAt(0),")"))(),s[l]=a,a+=32)}o[0]=a,o[1]=r}function Y(e,t,i,n,s){const o=Array.from(e),a=o.length,r=new Array(a),l=new Array(a),c=new Array(a),g=("break-word"===i||"break-all"===i)&&isFinite(n)&&n>0,d=[0,0],u=[0,0];let f=0,h=0,p=0;for(let m=0;m<=a;m++){const e=o[m];if("\n"!==e&&m!==a||(p=m),p>h){const e=g?Z(o,i,n,s,h,p):K;for(let i=0;i<=e.length;i++){const n=0===i?h:e[i-1],a=i<e.length?e[i]:p;q(o,n,a,s,r,u);for(let e=n;e<a;e++)l[e]=f+u[1]/2,c[e]=u[0];f+=u[1]*t,d[0]=Math.max(d[0],u[0])}h=p}"\n"===e&&(r[h]=0,l[h]=0,c[h]=0,h++)}return d[1]=f,{x:r,y:l,rowWidth:c,size:d}}class Q{constructor(e=5){u(this,"limit",void 0),u(this,"_cache",{}),u(this,"_order",[]),this.limit=e}get(e){const t=this._cache[e];return t&&(this._deleteOrder(e),this._appendOrder(e)),t}set(e,t){this._cache[e]?(this.delete(e),this._cache[e]=t,this._appendOrder(e)):(Object.keys(this._cache).length===this.limit&&this.delete(this._order[0]),this._cache[e]=t,this._appendOrder(e))}delete(e){this._cache[e]&&(delete this._cache[e],this._deleteOrder(e))}_deleteOrder(e){const t=this._order.indexOf(e);t>=0&&this._order.splice(t,1)}_appendOrder(e){this._order.push(e)}}const J={fontFamily:"Monaco, monospace",fontWeight:"normal",characterSet:function(){const e=[];for(let t=32;t<128;t++)e.push(String.fromCharCode(t));return e}(),fontSize:64,buffer:4,sdf:!1,cutoff:.25,radius:12,smoothing:.1};let $=new Q(3);function ee(e,t){for(let i=0;i<e.length;i++)t.data[4*i+3]=e[i]}function te(e,t,i,n){e.font="".concat(n," ").concat(i,"px ").concat(t),e.fillStyle="#000",e.textBaseline="alphabetic",e.textAlign="left"}class ie{constructor(){u(this,"props",r({},J)),u(this,"_key",void 0),u(this,"_atlas",void 0)}get texture(){return this._atlas}get mapping(){return this._atlas&&this._atlas.mapping}get scale(){return 1.2}setProps(e={}){Object.assign(this.props,e);const t=this._key;this._key=this._getKey();const i=function(e,t){let i;i="string"==typeof t?new Set(Array.from(t)):new Set(t);const n=$.get(e);if(!n)return i;for(const s in n.mapping)i.has(s)&&i.delete(s);return i}(this._key,this.props.characterSet),n=$.get(this._key);if(n&&0===i.size)return void(this._key!==t&&(this._atlas=n));const s=this._generateFontAtlas(this._key,i,n);this._atlas=s,$.set(this._key,s)}_generateFontAtlas(e,t,i){const{fontFamily:n,fontWeight:s,fontSize:o,buffer:a,sdf:l,radius:c,cutoff:g}=this.props;let d=i&&i.data;d||(d=document.createElement("canvas"),d.width=1024);const u=d.getContext("2d");te(u,n,o,s);const{mapping:f,canvasHeight:h,xOffset:p,yOffset:m}=function({characterSet:e,getFontWidth:t,fontHeight:i,buffer:n,maxCanvasWidth:s,mapping:o={},xOffset:a=0,yOffset:r=0}){let l=0,c=a;for(const u of e)if(!o[u]){const e=t(u);c+e+2*n>s&&(c=0,l++),o[u]={x:c+n,y:r+l*(i+2*n)+n,width:e,height:i},c+=e+2*n}const g=i+2*n;return{mapping:o,xOffset:c,yOffset:r+l*g,canvasHeight:(d=r+(l+1)*g,Math.pow(2,Math.ceil(Math.log2(d))))};var d}(r({getFontWidth:e=>u.measureText(e).width,fontHeight:1.2*o,buffer:a,characterSet:t,maxCanvasWidth:1024},i&&{mapping:i.mapping,xOffset:i.xOffset,yOffset:i.yOffset}));if(d.height!==h){const e=u.getImageData(0,0,d.width,d.height);d.height=h,u.putImageData(e,0,0)}if(te(u,n,o,s),l){const e=new G(o,a,c,g,n,s),i=u.getImageData(0,0,e.size,e.size);for(const n of t)ee(e.draw(n),i),u.putImageData(i,f[n].x-a,f[n].y+a)}else for(const r of t)u.fillText(r,f[r].x,f[r].y+.9*o);return{xOffset:p,yOffset:m,mapping:f,data:d,width:d.width,height:d.height}}_getKey(){const{fontFamily:e,fontWeight:t,fontSize:i,buffer:n,sdf:s,radius:o,cutoff:a}=this.props;return s?"".concat(e," ").concat(t," ").concat(i," ").concat(n," ").concat(o," ").concat(a):"".concat(e," ").concat(t," ").concat(i," ").concat(n)}}const ne={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,padding:{type:"array",value:[0,0,0,0]},getPosition:{type:"accessor",value:e=>e.position},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},getBoundingRect:{type:"accessor",value:[0,0,0,0]},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:[0,0,0,255]},getLineWidth:{type:"accessor",value:1}};class se extends c{constructor(...e){super(...e),u(this,"state",void 0)}getShaders(){return super.getShaders({vs:"#define SHADER_NAME text-background-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec4 instanceRects;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec2 instancePixelOffsets;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform bool billboard;\nuniform float opacity;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform vec4 padding;\nuniform int sizeUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = radians(angle);\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n  vLineWidth = instanceLineWidths;\n\n  // convert size in meters to pixels, then scaled and clamp\n\n  // project meters to pixels and clamp to limits\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),\n    sizeMinPixels, sizeMaxPixels\n  );\n\n  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;\n\n  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\n  pixelOffset += instancePixelOffsets;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  // Apply opacity to instance color, or return instance picking color\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#define SHADER_NAME text-background-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool stroked;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec2 pixelPosition = uv * dimensions;\n  if (stroked) {\n    float distToEdge = min(\n      min(pixelPosition.x, dimensions.x - pixelPosition.x),\n      min(pixelPosition.y, dimensions.y - pixelPosition.y)\n    );\n    float isBorder = smoothedge(distToEdge, vLineWidth);\n    gl_FragColor = mix(vFillColor, vLineColor, isBorder);\n  } else {\n    gl_FragColor = vFillColor;\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[v,y]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instanceRects:{size:4,accessor:"getBoundingRect"},instancePixelOffsets:{size:2,transition:!0,accessor:"getPixelOffset"},instanceFillColors:{size:4,transition:!0,normalized:!0,type:5121,accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:4,transition:!0,normalized:!0,type:5121,accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(e){super.updateState(e);const{changeFlags:t}=e;if(t.extensionsChanged){var i;const{gl:e}=this.context;null===(i=this.state.model)||void 0===i||i.delete(),this.state.model=this._getModel(e),this.getAttributeManager().invalidateAll()}}draw({uniforms:e}){const{billboard:t,sizeScale:i,sizeUnits:n,sizeMinPixels:s,sizeMaxPixels:o,getLineWidth:a}=this.props;let{padding:r}=this.props;r.length<4&&(r=[r[0],r[1],r[0],r[1]]),this.state.model.setUniforms(e).setUniforms({billboard:t,stroked:Boolean(a),padding:r,sizeUnits:_[n],sizeScale:i,sizeMinPixels:s,sizeMaxPixels:o}).draw()}_getModel(e){return new b(e,l(r({},this.getShaders()),{id:this.props.id,geometry:new P({drawMode:6,vertexCount:4,attributes:{positions:{size:2,value:new Float32Array([0,0,1,0,1,1,0,1])}}}),isInstanced:!0}))}}u(se,"defaultProps",ne),u(se,"layerName","TextBackgroundLayer");const oe={start:1,middle:0,end:-1},ae={top:1,center:0,bottom:-1},re=[0,0,0,255],le={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,background:!1,getBackgroundColor:{type:"accessor",value:[255,255,255,255]},getBorderColor:{type:"accessor",value:re},getBorderWidth:{type:"accessor",value:0},backgroundPadding:{type:"array",value:[0,0,0,0]},characterSet:{type:"object",value:J.characterSet},fontFamily:J.fontFamily,fontWeight:J.fontWeight,lineHeight:1,outlineWidth:{type:"number",value:0,min:0},outlineColor:{type:"color",value:re},fontSettings:{},wordBreak:"break-word",maxWidth:{type:"number",value:-1},getText:{type:"accessor",value:e=>e.text},getPosition:{type:"accessor",value:e=>e.position},getColor:{type:"accessor",value:re},getSize:{type:"accessor",value:32},getAngle:{type:"accessor",value:0},getTextAnchor:{type:"accessor",value:"middle"},getAlignmentBaseline:{type:"accessor",value:"center"},getPixelOffset:{type:"accessor",value:[0,0]},backgroundColor:{deprecatedFor:["background","getBackgroundColor"]}};class ce extends S{constructor(...e){super(...e),u(this,"state",void 0),u(this,"getBoundingRect",((e,t)=>{const i=this.state.fontAtlasManager.mapping,n=this.state.getText,{wordBreak:s,maxWidth:o,lineHeight:a,getTextAnchor:r,getAlignmentBaseline:l}=this.props,c=n(e,t)||"",{size:[g,d]}=Y(c,a,s,o,i);return[(oe["function"==typeof r?r(e,t):r]-1)*g/2,(ae["function"==typeof l?l(e,t):l]-1)*d/2,g,d]})),u(this,"getIconOffsets",((e,t)=>{const i=this.state.fontAtlasManager.mapping,n=this.state.getText,{wordBreak:s,maxWidth:o,lineHeight:a,getTextAnchor:r,getAlignmentBaseline:l}=this.props,c=n(e,t)||"",{x:g,y:d,rowWidth:u,size:[f,h]}=Y(c,a,s,o,i),p=oe["function"==typeof r?r(e,t):r],m=ae["function"==typeof l?l(e,t):l],x=g.length,v=new Array(2*x);let y=0;for(let _=0;_<x;_++){const e=(1-p)*(f-u[_])/2;v[y++]=(p-1)*f/2+e+g[_],v[y++]=(m-1)*h/2+d[_]}return v}))}initializeState(){this.state={styleVersion:0,fontAtlasManager:new ie}}updateState(e){const{props:t,oldProps:i,changeFlags:n}=e;(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getText))&&this._updateText();(this._updateFontAtlas()||t.lineHeight!==i.lineHeight||t.wordBreak!==i.wordBreak||t.maxWidth!==i.maxWidth)&&this.setState({styleVersion:this.state.styleVersion+1})}getPickingInfo({info:e}){return e.object=e.index>=0?this.props.data[e.index]:null,e}_updateFontAtlas(){const{fontSettings:e,fontFamily:t,fontWeight:i}=this.props,{fontAtlasManager:n,characterSet:s}=this.state,o=l(r({},e),{characterSet:s,fontFamily:t,fontWeight:i});if(!n.mapping)return n.setProps(o),!0;for(const a in o)if(o[a]!==n.props[a])return n.setProps(o),!0;return!1}_updateText(){var e;const{data:t,characterSet:i}=this.props,n=null===(e=t.attributes)||void 0===e?void 0:e.getText;let s,{getText:o}=this.props,a=t.startIndices;const c="auto"===i&&new Set;if(n&&a){const{texts:e,characterCount:i}=function({value:e,length:t,stride:i,offset:n,startIndices:s,characterSet:o}){const a=e.BYTES_PER_ELEMENT,r=i?i/a:1,l=n?n/a:0,c=s[t]||Math.ceil((e.length-l)/r),g=o&&new Set,d=new Array(t);let u=e;if(r>1||l>0){u=new(0,e.constructor)(c);for(let t=0;t<c;t++)u[t]=e[t*r+l]}for(let f=0;f<t;f++){const e=s[f],t=s[f+1]||c,i=u.subarray(e,t);d[f]=String.fromCodePoint.apply(null,i),g&&i.forEach(g.add,g)}if(g)for(const f of g)o.add(String.fromCodePoint(f));return{texts:d,characterCount:c}}(l(r({},ArrayBuffer.isView(n)?{value:n}:n),{length:t.length,startIndices:a,characterSet:c}));s=i,o=(t,{index:i})=>e[i]}else{const{iterable:e,objectInfo:i}=x(t);a=[0],s=0;for(const t of e){i.index++;const e=Array.from(o(t,i)||"");c&&e.forEach(c.add,c),s+=e.length,a.push(s)}}this.setState({getText:o,startIndices:a,numInstances:s,characterSet:c||i})}renderLayers(){const{startIndices:e,numInstances:t,getText:i,fontAtlasManager:{scale:n,texture:s,mapping:o},styleVersion:a}=this.state,{data:r,_dataDiff:l,getPosition:c,getColor:g,getSize:d,getAngle:u,getPixelOffset:f,getBackgroundColor:h,getBorderColor:p,getBorderWidth:m,backgroundPadding:x,background:v,billboard:y,fontSettings:_,outlineWidth:b,outlineColor:P,sizeScale:C,sizeUnits:S,sizeMinPixels:z,sizeMaxPixels:M,transitions:L,updateTriggers:O}=this.props,w=this.getSubLayerClass("characters",B),A=this.getSubLayerClass("background",se);return[v&&new A({getFillColor:h,getLineColor:p,getLineWidth:m,padding:x,getPosition:c,getSize:d,getAngle:u,getPixelOffset:f,billboard:y,sizeScale:C/this.state.fontAtlasManager.props.fontSize,sizeUnits:S,sizeMinPixels:z,sizeMaxPixels:M,transitions:L&&{getPosition:L.getPosition,getAngle:L.getAngle,getSize:L.getSize,getFillColor:L.getBackgroundColor,getLineColor:L.getBorderColor,getLineWidth:L.getBorderWidth,getPixelOffset:L.getPixelOffset}},this.getSubLayerProps({id:"background",updateTriggers:{getPosition:O.getPosition,getAngle:O.getAngle,getSize:O.getSize,getFillColor:O.getBackgroundColor,getLineColor:O.getBorderColor,getLineWidth:O.getBorderWidth,getPixelOffset:O.getPixelOffset,getBoundingRect:{getText:O.getText,getTextAnchor:O.getTextAnchor,getAlignmentBaseline:O.getAlignmentBaseline,styleVersion:a}}}),{data:r.attributes&&r.attributes.background?{length:r.length,attributes:r.attributes.background}:r,_dataDiff:l,autoHighlight:!1,getBoundingRect:this.getBoundingRect}),new w({sdf:_.sdf,smoothing:Number.isFinite(_.smoothing)?_.smoothing:J.smoothing,outlineWidth:b,outlineColor:P,iconAtlas:s,iconMapping:o,getPosition:c,getColor:g,getSize:d,getAngle:u,getPixelOffset:f,billboard:y,sizeScale:C*n,sizeUnits:S,sizeMinPixels:z*n,sizeMaxPixels:M*n,transitions:L&&{getPosition:L.getPosition,getAngle:L.getAngle,getColor:L.getColor,getSize:L.getSize,getPixelOffset:L.getPixelOffset}},this.getSubLayerProps({id:"characters",updateTriggers:{getIcon:O.getText,getPosition:O.getPosition,getAngle:O.getAngle,getColor:O.getColor,getSize:O.getSize,getPixelOffset:O.getPixelOffset,getIconOffsets:{getText:O.getText,getTextAnchor:O.getTextAnchor,getAlignmentBaseline:O.getAlignmentBaseline,styleVersion:a}}}),{data:r,_dataDiff:l,startIndices:e,numInstances:t,getIconOffsets:this.getIconOffsets,getIcon:i})]}static set fontAtlasCacheLimit(e){!function(e){C.assert(Number.isFinite(e)&&e>=3,"Invalid cache limit"),$=new Q(e)}(e)}}u(ce,"defaultProps",le),u(ce,"layerName","TextLayer");export{S as C,T as I,W as S,ce as T};
//# sourceMappingURL=text-layer.f1b6c0de.js.map
