var t=Object.defineProperty,e=Object.defineProperties,n=Object.getOwnPropertyDescriptors,i=Object.getOwnPropertySymbols,r=Object.prototype.hasOwnProperty,o=Object.prototype.propertyIsEnumerable,s=(e,n,i)=>n in e?t(e,n,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[n]=i,a=(t,e)=>{for(var n in e||(e={}))r.call(e,n)&&s(t,n,e[n]);if(i)for(var n of i(e))o.call(e,n)&&s(t,n,e[n]);return t},c=(t,i)=>e(t,n(i)),l=(t,e,n)=>(s(t,"symbol"!=typeof e?e+"":e,n),n);import{G as h}from"./index.84f8ccb6.js";import{T as f,P as p,Q as u,R as g,S as d,W as _}from"./layer.b20bd88e.js";var m='// BC 2021-04-30: this file forked from https://github.com/visgl/deck.gl\r\n//\r\n// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the "Software"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n// THE SOFTWARE.\r\n\r\n#define SHADER_NAME icon-layer-vertex-shader\r\n\r\nattribute vec2 positions;\r\n\r\nattribute float instanceSizes;\r\nattribute vec4 instanceColors;\r\nattribute vec3 instancePickingColors;\r\nattribute vec4 instanceIconFrames;\r\nattribute float instanceColorModes;\r\nattribute vec2 instanceOffsets;\r\nattribute vec2 instancePixelOffset;\r\n\r\nuniform float sizeScale;\r\nuniform vec2 iconsTextureDim;\r\nuniform float sizeMinPixels;\r\nuniform float sizeMaxPixels;\r\nuniform bool billboard;\r\n\r\nuniform float currentTime;\r\n\r\nuniform vec2 iconStillOffsets;\r\nuniform vec4 iconStillFrames;\r\n\r\nattribute float instanceTimestamps;\r\nattribute float instanceTimestampsNext;\r\nattribute vec2 instanceStartPositions;\r\nattribute vec2 instanceEndPositions;\r\n\r\nvarying float vColorMode;\r\nvarying vec4 vColor;\r\nvarying vec2 vTextureCoords;\r\nvarying vec2 uv;\r\nvarying float vPercentComplete;\r\n\r\n// ------------------------------------------------------------------\r\n\r\nvec2 rotate_by_angle(vec2 vertex, float angle_radian) {\r\n  float cos_angle = cos(angle_radian);\r\n  float sin_angle = sin(angle_radian);\r\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\r\n  return rotationMatrix * vertex;\r\n}\r\n\r\nvec3 interpolate(in vec3 point1, in vec3 point2, in float timestepFraction) {\r\n    if (timestepFraction <= 0.0) {\r\n        return point1;\r\n    } else if (timestepFraction >= 1.0 ) {\r\n        return point2;\r\n    } else {\r\n        vec3 direction = point2 - point1;\r\n        return point1 + (direction * timestepFraction);\r\n    }\r\n}\r\n\r\nvoid main(void) {\r\n\r\n  // Calculate progress:\r\n  // Skip everything else if this vertex is outside the time window\r\n  if (currentTime < instanceTimestamps) {\r\n    vPercentComplete = -1.0;\r\n    return;\r\n  } else if (currentTime > instanceTimestampsNext) {\r\n    vPercentComplete = -1.0;\r\n    return;\r\n  } else {\r\n    vPercentComplete = (currentTime - instanceTimestamps) /\r\n                       (instanceTimestampsNext - instanceTimestamps);\r\n  }\r\n\r\n  geometry.pickingColor = instancePickingColors;\r\n\r\n  vec3 startPosition = vec3(instanceStartPositions, 5.0);\r\n  vec3 endPosition = vec3(instanceEndPositions, 5.0);\r\n\r\n  // are we stationary/still\r\n  bool still = (instanceStartPositions == instanceEndPositions);\r\n\r\n  // geometry.uv = positions;\r\n  // uv = positions;\r\n\r\n  // this could be the problem right here;\r\n  vec2 iconSize = still ? iconStillFrames.zw : instanceIconFrames.zw;\r\n  // convert size in meters to pixels, then scaled and clamp\r\n  // project meters to pixels and clamp to limits\r\n  float sizePixels = clamp(\r\n    project_size_to_pixel(instanceSizes * sizeScale),\r\n    sizeMinPixels, sizeMaxPixels\r\n  );\r\n\r\n  // scale icon height to match instanceSize\r\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\r\n\r\n  // // figure out angle based on motion direction\r\n  float angle = 0.0;\r\n  if (!still) {\r\n    vec3 direction = normalize(endPosition - startPosition);\r\n    angle = atan( direction.y / direction.x);\r\n    if (direction.x < 0.0) angle = angle - PI;\r\n  }\r\n\r\n  // scale and rotate vertex in "pixel" value and convert back to fraction in clipspace\r\n  vec2 pixelOffset = positions / 2.0 * iconSize + (still ? iconStillOffsets : instanceOffsets);\r\n  pixelOffset = rotate_by_angle(pixelOffset, angle) * instanceScale;\r\n  pixelOffset += instancePixelOffset;\r\n  pixelOffset.y *= -1.0;\r\n\r\n  vec3 newPosition = interpolate(startPosition, endPosition, vPercentComplete);\r\n\r\n  if (billboard)  {\r\n    gl_Position = project_position_to_clipspace(newPosition, vec3(0.0), vec3(0.0), geometry.position);\r\n    vec3 offset = vec3(pixelOffset, 0.0);\r\n    DECKGL_FILTER_SIZE(offset, geometry);\r\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\r\n\r\n  } else {\r\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\r\n    DECKGL_FILTER_SIZE(offset_common, geometry);\r\n    gl_Position = project_position_to_clipspace(newPosition, vec3(0.0), offset_common, geometry.position);\r\n  }\r\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\r\n\r\n  vec2 upperleft = (still ? iconStillFrames.xy : instanceIconFrames.xy);\r\n\r\n  vTextureCoords = mix(\r\n    upperleft,\r\n    upperleft + iconSize,\r\n    (positions.xy + 1.0) / 2.0\r\n  ) / iconsTextureDim;\r\n\r\n  vColor = instanceColors;\r\n  DECKGL_FILTER_COLOR(vColor, geometry);\r\n\r\n  vColorMode = instanceColorModes;\r\n}\r\n',v='// BC 2021-04-30: this file forked from https://github.com/visgl/deck.gl\r\n//\r\n// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the "Software"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n// THE SOFTWARE.\r\n\r\n#define SHADER_NAME icon-layer-fragment-shader\r\n\r\nprecision highp float;\r\n\r\nuniform float opacity;\r\nuniform sampler2D iconsTexture;\r\nuniform float alphaCutoff;\r\n\r\nvarying float vColorMode;\r\nvarying vec4 vColor;\r\nvarying vec2 vTextureCoords;\r\nvarying vec2 uv;\r\n\r\nuniform float currentTime;\r\nvarying float vPercentComplete;\r\n\r\nvoid main(void) {\r\n\r\n  if (vPercentComplete == -1.0) discard;\r\n\r\n  geometry.uv = uv;\r\n\r\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\r\n\r\n  // if colorMode == 0, use pixel color from the texture\r\n  // if colorMode == 1 or rendering picking buffer, use texture as transparency mask\r\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\r\n  // Take the global opacity and the alpha from vColor into account for the alpha component\r\n  float a = texColor.a * opacity * vColor.a;\r\n\r\n  if (a < alphaCutoff) {\r\n    discard;\r\n  }\r\n\r\n  gl_FragColor = vec4(color, a);\r\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\r\n}\r\n';const O=()=>{},T={[h.TEXTURE_MIN_FILTER]:h.LINEAR_MIPMAP_LINEAR,[h.TEXTURE_MAG_FILTER]:h.LINEAR,[h.TEXTURE_WRAP_S]:h.CLAMP_TO_EDGE,[h.TEXTURE_WRAP_T]:h.CLAMP_TO_EDGE};function E(t,e,n,i){return n===e.width&&i===e.height?e:(t.canvas.height=i,t.canvas.width=n,t.clearRect(0,0,t.canvas.width,t.canvas.height),t.drawImage(e,0,0,e.width,e.height,0,0,n,i),t.canvas)}function I(t){return t&&(t.id||t.url)}function x(t,e,n){for(let i=0;i<e.length;i++){const{icon:r,xOffset:o}=e[i];t[I(r)]=c(a({},r),{x:o,y:n})}}class R{constructor(t,{onUpdate:e=O,onError:n=O}){l(this,"gl"),l(this,"onUpdate"),l(this,"onError"),l(this,"_loadOptions"),l(this,"_getIcon"),l(this,"_texture"),l(this,"_externalTexture"),l(this,"_mapping"),l(this,"_pendingCount"),l(this,"_autoPacking"),l(this,"_xOffset"),l(this,"_yOffset"),l(this,"_rowHeight"),l(this,"_buffer"),l(this,"_canvasWidth"),l(this,"_canvasHeight"),l(this,"_canvas"),this.gl=t,this.onUpdate=e,this.onError=n,this._loadOptions=null,this._getIcon=null,this._texture=null,this._externalTexture=null,this._mapping={},this._pendingCount=0,this._autoPacking=!1,this._xOffset=0,this._yOffset=0,this._rowHeight=0,this._buffer=4,this._canvasWidth=1024,this._canvasHeight=0,this._canvas=null}finalize(){var t;null==(t=this._texture)||t.delete()}getTexture(){return this._texture||this._externalTexture}getIconMapping(t){const e=this._autoPacking?I(t):t;return this._mapping[e]||{}}setProps({loadOptions:t,autoPacking:e,iconAtlas:n,iconMapping:i,data:r,getIcon:o}){t&&(this._loadOptions=t),void 0!==e&&(this._autoPacking=e),o&&(this._getIcon=o),i&&(this._mapping=i),n&&this._updateIconAtlas(n),this._autoPacking&&(r||o)&&"undefined"!=typeof document&&(this._canvas=this._canvas||document.createElement("canvas"),this._updateAutoPacking(r))}get isLoaded(){return 0===this._pendingCount}_updateIconAtlas(t){var e;null==(e=this._texture)||e.delete(),this._texture=null,this._externalTexture=t,this.onUpdate()}_updateAutoPacking(t){const e=Object.values(function(t,e,n){if(!t||!e)return null;n=n||{};const i={},{iterable:r,objectInfo:o}=_(t);for(const s of r){o.index++;const t=e(s,o),r=I(t);if(!t)throw new Error("Icon is missing.");if(!t.url)throw new Error("Icon url is missing.");i[r]||n[r]&&t.url===n[r].url||(i[r]=c(a({},t),{source:s,sourceIndex:o.index}))}return i}(t,this._getIcon,this._mapping)||{});if(e.length>0){const{mapping:t,xOffset:n,yOffset:i,rowHeight:r,canvasHeight:o}=function({icons:t,buffer:e,mapping:n={},xOffset:i=0,yOffset:r=0,rowHeight:o=0,canvasWidth:s}){let a=[];for(let l=0;l<t.length;l++){const c=t[l];if(!n[I(c)]){const{height:t,width:l}=c;i+l+e>s&&(x(n,a,r),i=0,r=o+r+e,o=0,a=[]),a.push({icon:c,xOffset:i}),i=i+l+e,o=Math.max(o,t)}}return a.length>0&&x(n,a,r),{mapping:n,rowHeight:o,xOffset:i,yOffset:r,canvasWidth:s,canvasHeight:(c=o+r+e,Math.pow(2,Math.ceil(Math.log2(c))))};var c}({icons:e,buffer:this._buffer,canvasWidth:this._canvasWidth,mapping:this._mapping,rowHeight:this._rowHeight,xOffset:this._xOffset,yOffset:this._yOffset});this._rowHeight=r,this._mapping=t,this._xOffset=n,this._yOffset=i,this._canvasHeight=o,this._texture||(this._texture=new f(this.gl,{width:this._canvasWidth,height:this._canvasHeight,parameters:T})),this._texture.height!==this._canvasHeight&&(this._texture=function(t,e,n,i){const r=e.width,o=e.height,s=g(e,{width:n,height:i});return d(e,s,{targetY:0,width:r,height:o}),e.delete(),s}(this.gl,this._texture,this._canvasWidth,this._canvasHeight)),this.onUpdate(),this._loadIcons(e)}}_loadIcons(t){const e=this._canvas.getContext("2d");for(const n of t)this._pendingCount++,p(n.url,u,this._loadOptions).then((t=>{const i=I(n),{x:r,y:o,width:s,height:a}=this._mapping[i],c=E(e,t,s,a);this._texture.setSubImageData({data:c,x:r,y:o,width:s,height:a}),this._texture.generateMipmap(),this.onUpdate()})).catch((t=>{this.onError({url:n.url,source:n.source,sourceIndex:n.sourceIndex,loadOptions:this._loadOptions,error:t})})).finally((()=>{this._pendingCount--}))}}export{R as I,v as f,m as v};
//# sourceMappingURL=icon-manager.2c4c9b5c.js.map
